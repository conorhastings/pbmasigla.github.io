<!DOCTYPE html>
<script src='vendor/three.js/build/three.min.js'>
</script>
<script src='../threex.nyancat.js'>
</script>
<script src='../threex.nyancatsound.js'>
</script>
<script src='../threex.nyancatstars.js'>
</script>
<script src='../threex.nyancatrainbow.js'>
</script>
<script src='js/OrbitControls.js'>
</script>
<link href='css/style.css' rel='stylesheet' type='text/css'>
<body style='margin: 0px; background-color: #003366; overflow: hidden;'>
    <a id="logo" class="offline" href="https://github.com/Instrument/oculus-bridge"></a>
    <div id="info">
        <div class="button" id="toggle-render">
            toggle render mode
        </div>
        <div class="button" id="help">
            help
        </div>
        <div id="help-text" style="display:none;">
            <h1>
                Controls - stereo mode:
            </h1>
            <section>
                <div>
                    <label>
                        forward:
                    </label>
                    W or UP
                </div>
                <div>
                    <label>
                        backward:
                    </label>
                    S or DOWN
                </div>
            </section>
            <section>
                <div>
                    <label>
                        straif left:
                    </label>
                    A or LEFT
                </div>
                <div>
                    <label>
                        straif right:
                    </label>
                    D or RIGHT
                </div>
            </section>
            <section>
                <div>
                    <label>
                        turn left:
                    </label>
                    Q
                </div>
                <div>
                    <label>
                        turn right:
                    </label>
                    E
                </div>
            </section>
            <section>
                <div>
                    <label>
                        jump:
                    </label>
                    SPACE
                </div>
            </section>
            <h1>
                Controls - perspective mode:
            </h1>
            <section>
                <div>
                    <label>
                        orbit:
                    </label>
                    left-click + drag
                </div>
                <div>
                    <label>
                        pan:
                    </label>
                    right-click + drag
                </div>
                <div>
                    <label>
                        zoom:
                    </label>
                    mouse wheel
                </div>
            </section>
        </div>
    </div>
    <div id="viewport">
    </div>
    <div id="security_error">
        <p>
            This file must be served via HTTP to support the use of textures.
        </p>
        <p>
            Please host this content via a web server of some kind and try again.
        </p>
    </div>
    <div id="generic_error">
        <p>
            Oh dang, something went wrong while trying to render the scene.
        </p>
        <p>
            Exception:
            <span id="exception_message">
            </span>
        </p>
    </div>
    <script src="js/OculusBridge.min.js">
        
    </script>
    <script src="js/three.min.js">
        
    </script>
    <script src="js/RiftCamera.js">
        
    </script>
    <script>
        	var renderer = new THREE.WebGLRenderer();
    	renderer.setSize(window.innerWidth, window.innerHeight);
    	document.body.appendChild(renderer.domElement);

    	var keys = [];
    	for (var i = 0; i < 130; i++) {
    	    keys.push(false);
    	}


    	var updateFcts = [];
    	var controls;
    	var core = [];
    	var scene = new THREE.Scene();
    	var clock = new THREE.Clock();
    	var bodyPosition = new THREE.Vector3(0,15,0);
    	controls = new THREE.OrbitControls(camera);
    	scene.fog = new THREE.FogExp2(0x003366, 0.0095);

    	var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    	camera.position.z = 30;

    	var pointLight = new THREE.PointLight(0xFFFFFF);
    	pointLight.position.z = 1000;
    	scene.add(pointLight);

    	//////////////////////////////////////////////////////////////////////////////////
    	 //		comment								//
    	 //////////////////////////////////////////////////////////////////////////////////
    	var paused = false;

    	var nyanCat = new THREEx.NyanCat()
    	 scene.add(nyanCat.container)
    	 updateFcts.push(function(delta, now) {
    	    if (paused) return
    	    nyanCat.update(delta, now)
    	})

    	 var sound = new THREEx.NyanCatSound()
    	 document.body.addEventListener('mousedown', function() {
    	    paused = paused ? false : true
    	    sound.toggle()
    	})

    	 var nyanStars = new THREEx.NyanCatStars()
    	 scene.add(nyanStars.container)
    	 updateFcts.push(function(delta, now) {
    	    if (paused) return
    	    nyanStars.update(delta, now)
    	})

    	 var nyanRainbow = new THREEx.NyanCatRainbow()
    	 scene.add(nyanRainbow.container)
    	 updateFcts.push(function(delta, now) {
    	    if (paused) return
    	    nyanRainbow.update(delta, now)
    	})

    	//////////////////////////////////////////////////////////////////////////////////
    	 //		Camera Controls							//
    	 //////////////////////////////////////////////////////////////////////////////////
    	var mouse = {
    	    x: 0,
    	    y: 0
    	}
    	document.addEventListener('mousemove', function(event) {
    	    mouse.x = (event.clientX / window.innerWidth) - 0.5
    	    mouse.y = (event.clientY / window.innerHeight) - 0.5
    	}, false)
    	 updateFcts.push(function(delta, now) {
    	    camera.position.x += (mouse.x * 500 - camera.position.x) * 0.01
    	    camera.position.y += (mouse.y * 500 - camera.position.y) * 0.01
    	    camera.lookAt(scene.position)
    	})

    	//////////////////////////////////////////////////////////////////////////////////
    	 //		render the scene						//
    	 //////////////////////////////////////////////////////////////////////////////////
    	updateFcts.push(function() {
    	    renderer.render(scene, camera);
    	})

    	//////////////////////////////////////////////////////////////////////////////////
    	 //		loop runner							//
    	 //////////////////////////////////////////////////////////////////////////////////
    	var lastTimeMsec = null
    	 requestAnimationFrame(function animate(nowMsec) {
    	    // keep looping
    	    requestAnimationFrame(animate);
    	    // measure time
    	    lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
    	    var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
    	    lastTimeMsec = nowMsec
    	    // call each update function
    	    updateFcts.forEach(function(updateFn) {
    	        updateFn(deltaMsec / 1000, nowMsec / 1000)
    	    })
    	})

    	 /*New Code*/

    	var useRift = false;
    	var time;

    	function init() {
    	    document.getElementById("toggle-render").addEventListener("click", function() {
    	        useRift = !useRift;
    	        onResize();
    	    });

    	    document.getElementById("help").addEventListener("click", function() {
    	        var el = document.getElementById("help-text");
    	        el.style.display = (el.style.display == "none") ? "" : "none";
    	    });

    	    window.addEventListener('resize', onResize, false);

    	    time = Date.now();

    	    oculusBridge = new OculusBridge({
    	        "debug": true,
    	        "onOrientationUpdate": bridgeOrientationUpdated,
    	        "onConfigUpdate": bridgeConfigUpdated,
    	        "onConnect": bridgeConnected,
    	        "onDisconnect": bridgeDisconnected
    	    });
    	    oculusBridge.connect();

    	    riftCam = new THREE.OculusRiftEffect(renderer);
    	}

    	function onResize() {
    	    if (!useRift) {
    	        windowHalf = new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2);
    	        aspectRatio = window.innerWidth / window.innerHeight;

    	        camera.aspect = aspectRatio;
    	        camera.updateProjectionMatrix();

    	        renderer.setSize(window.innerWidth, window.innerHeight);
    	    } else {
    	        riftCam.setSize(window.innerWidth, window.innerHeight);
    	    }
    	}

    	function bridgeConnected() {
    	    document.getElementById("logo").className = "";
    	}

    	function bridgeDisconnected() {
    	    document.getElementById("logo").className = "offline";
    	}

    	function bridgeConfigUpdated(config) {
    	    console.log("Oculus config updated.");
    	    riftCam.setHMD(config);
    	}

    	function bridgeOrientationUpdated(quatValues) {

    	    // Do first-person style controls (like the Tuscany demo) using the rift and keyboard.
    	    // TODO: Don't instantiate new objects in here, these should be re-used to avoid garbage collection.
    	    // make a quaternion for the the body angle rotated about the Y axis.
    	    var quat = new THREE.Quaternion();
    	    quat.setFromAxisAngle(bodyAxis, bodyAngle);

    	    // make a quaternion for the current orientation of the Rift
    	    var quatCam = new THREE.Quaternion(quatValues.x, quatValues.y, quatValues.z, quatValues.w);

    	    // multiply the body rotation by the Rift rotation.
    	    quat.multiply(quatCam);


    	    // Make a vector pointing along the Z axis and rotate it accoring to the combined look/body angle.
    	    var xzVector = new THREE.Vector3(0, 0, 1);
    	    xzVector.applyQuaternion(quat);

    	    // Compute the X/Z angle based on the combined look/body angle.  This will be used for FPS style movement controls
    	    // so you can steer with a combination of the keyboard and by moving your head.
    	    viewAngle = Math.atan2(xzVector.z, xzVector.x) + Math.PI;

    	    // Apply the combined look/body angle to the camera.
    	    camera.quaternion.copy(quat);
    	}

    	function onMouseMove(event) {
    	    mouse.set((event.clientX / window.innerWidth - 0.5) * 2, (event.clientY / window.innerHeight - 0.5) * 2);
    	}


    	function onMouseDown(event) {
    	    // Stub
    	    floorTexture.needsUpdate = true;
    	    console.log("update.");
    	}


    	function onKeyDown(event) {

    	    if (event.keyCode == 48) { // zero key.
    	        useRift = !useRift;
    	        onResize();
    	    }


    	    keys[event.keyCode] = true;
    	}


    	function onKeyUp(event) {
    	    keys[event.keyCode] = false;
    	}


    	function updateInput(delta) {

    	    var step = 25 * delta;
    	    var turn_speed = (55 * delta) * Math.PI / 180;


    	    // Forward/backward
    	    if (keys[87] || keys[38]) { // W or UP
    	        bodyPosition.x += Math.cos(viewAngle) * step;
    	        bodyPosition.z += Math.sin(viewAngle) * step;
    	    }

    	    if (keys[83] || keys[40]) { // S or DOWN
    	        bodyPosition.x -= Math.cos(viewAngle) * step;
    	        bodyPosition.z -= Math.sin(viewAngle) * step;
    	    }

    	    // Turn
    	    if (keys[81]) { // E
    	        bodyAngle += turn_speed;
    	    }

    	    if (keys[69]) { // Q
    	        bodyAngle -= turn_speed;
    	    }

    	    // Straif
    	    if (keys[65] || keys[37]) { // A or LEFT
    	        bodyPosition.x -= Math.cos(viewAngle + Math.PI / 2) * step;
    	        bodyPosition.z -= Math.sin(viewAngle + Math.PI / 2) * step;
    	    }

    	    if (keys[68] || keys[39]) { // D or RIGHT
    	        bodyPosition.x += Math.cos(viewAngle + Math.PI / 2) * step;
    	        bodyPosition.z += Math.sin(viewAngle + Math.PI / 2) * step;
    	    }


    	    // VERY simple gravity/ground plane physics for jumping.
    

    	    if (bodyPosition.y < 15) {
    	        bodyPosition.y = 15;
    	    }

    	    // update the camera position when rendering to the oculus rift.
    	    if (useRift) {
    	        camera.position.set(bodyPosition.x, bodyPosition.y, bodyPosition.z);
    	    }
    	}

    	function animate() {
    	    var delta = clock.getDelta();
    	    time += delta;

    	    updateInput(delta);
    	    for (var i = 0; i < core.length; i++) {
    	        core[i].rotation.x += delta * 0.25;
    	        core[i].rotation.y -= delta * 0.33;
    	        core[i].rotation.z += delta * 0.1278;
    	    }



    	    if (render()) {
    	        requestAnimationFrame(animate);
    	    }
    	}

    	function crashSecurity(e) {
    	    oculusBridge.disconnect();
    	    document.getElementById("viewport").style.display = "none";
    	    document.getElementById("security_error").style.display = "block";
    	}

    	function crashOther(e) {
    	    oculusBridge.disconnect();
    	    document.getElementById("viewport").style.display = "none";
    	    document.getElementById("generic_error").style.display = "block";
    	    document.getElementById("exception_message").innerHTML = e.message;
    	}

    	function render() {
    	    try {
    	        if (useRift) {
    	            riftCam.render(scene, camera);
    	        } else {
    	            controls.update();
    	            renderer.render(scene, camera);
    	        }
    	    } catch (e) {
    	        console.log(e);
    	        if (e.name == "SecurityError") {
    	            crashSecurity(e);
    	        } else {
    	            crashOther(e);
    	        }
    	        return false;
    	    }
    	    return true;
    	}

    	window.onload = function() {
    	    init();
    	    animate();
    	}

    	
    </script>
</body>