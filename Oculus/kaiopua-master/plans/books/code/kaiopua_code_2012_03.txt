/*
 *
 * Kaiopua.js
 * Main module.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
var KAIOPUA = (function (main) {

    var shared = main.shared = main.shared || {},
        _AssetLoader, _Game, lastGamma, lastBeta, libList = ["js/lib/jquery-1.7.1.min.js", "js/lib/RequestAnimationFrame.js", "js/lib/requestInterval.js", "js/lib/requestTimeout.js", "js/lib/signals.min.js", "js/lib/sylvester.js", "assets/modules/utils/AssetLoader.js"],
        setupList = ["assets/modules/core/Game.js",
                    //"assets/modules/utils/Dev.js"
                            ];

    /*===================================================
    
	compatibility
    
    =====================================================*/

    // array indexOf
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }

    /*===================================================
    
    internal init
    
    =====================================================*/

    // force cache-busting
    $LAB.setGlobalDefaults({
        CacheBust: true
    });

    // load scripts
    $LAB.script(libList).wait(init_basics);

    function init_basics() {

        // shared
        shared.mice = [];
        shared.screenWidth = $(window).width();
        shared.screenHeight = $(window).height();
        shared.originLink = window.location.pathname.toString();
        shared.pathToAssets = 'assets/';
        shared.pathToModules = shared.pathToAssets + 'modules/';
        shared.pathToModels = shared.pathToAssets + 'models/';
        shared.pathToIcons = shared.pathToAssets + 'icons/';
        shared.pathToTextures = shared.pathToAssets + 'textures/';

        shared.frameRateMax = 60;
        shared.frameRateMin = 20;
        shared.time = new Date().getTime();
        shared.timeLast = shared.time;
        shared.timeDeltaExpected = 1000 / 60;

        shared.multitouch = false;

        shared.html = {
            footerMenu: $('#footer_menu'),
            gameContainer: $('#game'),
            errorContainer: $('#errors')
        };

        shared.signals = {

            focuslose: new signals.Signal(),
            focusgain: new signals.Signal(),

            mousedown: new signals.Signal(),
            mouseup: new signals.Signal(),
            mousemoved: new signals.Signal(),
            mousewheel: new signals.Signal(),
            mouseenter: new signals.Signal(),
            mouseleave: new signals.Signal(),

            keydown: new signals.Signal(),
            keyup: new signals.Signal(),

            windowresized: new signals.Signal(),

            loadItemCompleted: new signals.Signal(),
            loadListCompleted: new signals.Signal(),
            loadAllCompleted: new signals.Signal(),

            assetReady: new signals.Signal(),

            error: new signals.Signal()

        };

        // add listeners for events
        // each listener dispatches shared signal
        $(window).on('blur', on_focus_lose);
        $(window).on('focus', on_focus_gain);

        $(document).on('mousedown touchstart', on_mouse_down);
        $(document).on('mouseup touchend', on_mouse_up);
        $(document).on('mousemove touchmove', on_mouse_move);
        $(document).on('mouseenter touchenter', on_mouse_enter);
        $(document).on('mouseleave touchleave', on_mouse_leave);
        $(document).on('mousewheel', on_mouse_wheel);
        $(shared.html.gameContainer).on('contextmenu', on_game_context_menu);

        $(document).on('keydown', on_key_down);
        $(document).on('keyup', on_key_up);

        $(window).on('deviceorientation', on_window_device_orientation);
        $(window).on('MozOrientation', on_window_device_orientation);

        $(window).on('resize', on_window_resize);

        window.onerror = on_error;

        // asset loader and setup
        _AssetLoader = main.get_asset_data('assets/modules/utils/AssetLoader.js');

        _AssetLoader.add_loaded_locations(libList);

        main.asset_require(setupList, init_setup, true);

    }

    function init_setup(g) {

        // assets
        _Game = g;

        // resize once
        on_window_resize();

    }

    /*===================================================
    
    helper functions
    
    =====================================================*/

    // better type checking
    // trade off is performance
    main.type = function (o) {
        return o == null ? o + '' : Object.prototype.toString.call(o).slice(8, -1).toLowerCase();
    };

    main.is_object = function (target) {
        return target !== null && target !== undefined && Object.prototype.toString.call(target) === '[object Object]';
    };

    main.is_array = function (target) {
        return Object.prototype.toString.call(target) === '[object Array]';
    };

    main.is_number = function (n) {
        return isNaN(n) === false && isFinite(n);
    };

    main.is_image = function (target) {
        return (typeof target !== 'undefined' && target.hasOwnProperty('nodeName') && target.nodeName.toLowerCase() === 'img');
    };

    main.is_touch_event = function (e) {

        var eOriginal = e.originalEvent;

        return eOriginal && eOriginal.touches && eOriginal.changedTouches;

    }

    // shared mouse
    main.get_mouse = function (parameters, allowNew) {

        return mouse = shared.mice[0] = shared.mice[0] || {
            x: 0,
            lx: 0,
            y: 0,
            ly: 0,
            down: false
        };

        parameters = parameters || {};

        var id = parameters.identifier = (shared.multitouch === true && parameters.identifier) ? parameters.identifier : 0,
            mouse;

        mouse = shared.mice[id] = (allowNew !== true || id < shared.mice.length) ? shared.mice[id] : {
            x: 0,
            lx: 0,
            y: 0,
            ly: 0,
            down: false
        };

        return mouse;

    }

    // object cloning/extending
    // copies both enumerable and non-enumerable properties
    // copies getters and setters correctly
    // optional: deep copying while avoiding infinite recursion
    // deep copy only makes one copy of any object, regardless of how many times / places it is referenced
    main.extend = function (source, destination, deep, records) {

        var i, l, propertyNames, name, descriptor, value, valueType, recordSources, recordCopies, recordSourceIndex, recordCopyIndex, recordSource, recordCopy;

        if (typeof source !== 'undefined') {

            destination = destination || {};

            propertyNames = Object.getOwnPropertyNames(source);

            for (i = 0, l = propertyNames.length; i < l; i++) {

                name = propertyNames[i];

                descriptor = Object.getOwnPropertyDescriptor(source, name);

                Object.defineProperty(destination, name, descriptor);

                // if deep copy
                if (deep === true) {

                    // get descriptor that was just set
                    descriptor = Object.getOwnPropertyDescriptor(destination, name);

                    value = descriptor.value;

                    valueType = main.type(value);

                    // if the value of the descriptor is an object or array
                    if (valueType === 'object' || valueType === 'array') {

                        records = records || {
                            sources: [],
                            copies: []
                        };

                        recordSources = records.sources;

                        recordCopies = records.copies;

                        recordSourceIndex = recordSources.indexOf(value);

                        // if value does not yet exist in records
                        if (recordSourceIndex === -1) {

                            recordSource = recordSources[recordSources.length] = value;

                            recordCopy = recordCopies[recordCopies.length] = (valueType === 'object' ? {} : []);

                            // special case when object has a reference to itself
                            if (value === source) {
                                value[name] = recordCopy;
                            }

                            descriptor.value = main.extend(value, recordCopy, true, records);

                        } else {

                            descriptor.value = recordCopies[recordSourceIndex];

                        }

                        // set descriptor again with new deep copied value
                        Object.defineProperty(destination, name, descriptor);

                    }

                }

            }

        }

        return destination;

    };

    main.index_of_object_with_property_value = function (array, property, value) {

        var i, l, index = -1,
            object;

        if (main.type(array) === 'array') {

            for (i = 0, l = array.length; i < l; i++) {

                object = array[i];

                if (value === object[property]) {

                    index = i;

                    break;

                }

            }

        }

        return index;

    }

    main.ensure_array = function (target) {

        target = target || [];

        if (main.is_array(target) !== true) {
            target = [target];
        }

        return target;

    };

    main.modify_array = function (target, elements, remove) {

        var i, l, element, index;

        if (typeof target !== 'undefined' && typeof elements !== 'undefined' && typeof forEach === 'function') {

            elements = main.ensure_array(elements);

            // for each element
            for (i = 0, l = elements.length; i < l; i++) {

                element = elements[i];

                index = target.indexof(element);

                if (remove === true) {

                    if (index !== -1) {

                        target.splice(index, 1);

                    }

                } else {

                    if (index === -1) {

                        target.push(element);

                    }

                }

            }

        }

    };

    main.get_asset_path = function (location) {

        return location.path || location

    };

    main.get_ext = function (location) {

        var path, dotIndex, ext = '';

        path = main.get_asset_path(location);

        dotIndex = path.lastIndexOf('.');

        if (dotIndex !== -1) {
            ext = path.substr(dotIndex + 1).toLowerCase();
        }

        return ext;

    };

    main.add_default_ext = function (location) {

        var path = main.remove_ext(location);

        path = path.replace(/\./g, "") + ".js";

        return path;

    };

    main.remove_ext = function (location) {

        var path, dotIndex;

        path = main.get_asset_path(location);

        dotIndex = path.lastIndexOf('.');

        if (dotIndex !== -1) {
            path = path.substr(0, dotIndex);
        }

        return path;

    };

    main.get_alt_path = function (location) {

        var path, ext;

        path = main.get_asset_path(location);
        ext = main.get_ext(path);

        // if has no extension, add default
        if (ext === '') {

            return main.add_default_ext(path);

        }
        // if has extension, remove
        else {

            return main.remove_ext(path);

        }

    };

    main.is_image_ext = function (ext) {

        if (ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'gif' || ext === 'bmp') {
            return true;
        } else {
            return false;
        }

    };

    /*===================================================
    
    event functions
    
    =====================================================*/

    main.handle_touch_event = function (e, eventActual) {

        var i, l, fingers, touch;

        // for each finger involved in the event
        fingers = e.changedTouches;

        for (i = 0, l = fingers.length; i < l; i += 1) {

            touch = fingers[touchIndex];

            touch.button = 0;

            // send as individual event
            eventActual(touch);

        }

    }

    function on_mouse_down(e) {

        var mouse;

        // is touch event
        if (main.is_touch_event(e)) {

            main.handle_touch_event(e.originalEvent, on_mouse_down);

        } else {

            mouse = main.get_mouse(e, true);

            mouse.down = true;

            shared.signals.mousedown.dispatch(e);

        }

        e.preventDefault();
        e.stopPropagation();
        return false;
    }

    function on_mouse_up(e) {

        // is touch event
        if (main.is_touch_event(e)) {

            main.handle_touch_event(e.originalEvent, on_mouse_up);
        } else {

            mouse = main.get_mouse(e, true);

            mouse.down = false;

            shared.signals.mouseup.dispatch(e);

        }

        e.preventDefault();
        e.stopPropagation();
        return false;
    }

    function on_mouse_move(e) {

        var mouse;

        // is touch event
        if (main.is_touch_event(e)) {

            main.handle_touch_event(e.originalEvent, on_mouse_move);
        } else {

            mouse = main.get_mouse(e, true);

            mouse.lx = mouse.x;
            mouse.ly = mouse.y;

            mouse.x = e.clientX;
            mouse.y = e.clientY;

            mouse.dx = mouse.x - mouse.lx;
            mouse.dy = mouse.y - mouse.ly;

            shared.signals.mousemoved.dispatch(e);

        }

        e.preventDefault();
        e.stopPropagation();
        return false;
    }

    function on_mouse_enter(e) {

        // is touch event
        if (main.is_touch_event(e)) {

            main.handle_touch_event(e.originalEvent, on_mouse_enter);
        } else {

            main.get_mouse(e, true);

            shared.signals.mouseenter.dispatch(e);

        }

        e.preventDefault();
        e.stopPropagation();
        return false;
    }

    function on_mouse_leave(e) {

        var mouse;

        // is touch event
        if (main.is_touch_event(e)) {

            main.handle_touch_event(e.originalEvent, on_mouse_leave);
        } else {

            mouse = main.get_mouse(e, true);

            shared.signals.mouseleave.dispatch(e);

            if (mouse.down === true) {

                on_mouse_up(e);

            }

        }

        e.preventDefault();
        e.stopPropagation();
        return false;
    }

    function on_mouse_wheel(e) {
        shared.signals.mousewheel.dispatch(e);

        e.preventDefault();
        e.stopPropagation();
        return false;
    }

    function on_game_context_menu(e) {

        e.preventDefault();
        e.stopPropagation();
        return false;

    }

    function on_window_device_orientation(e) {
        var i, l, mice, mouse, eCopy, overThreshold, gamma, beta, x, y;

        if (!e.gamma && !e.beta) {
            e.gamma = -(e.x * (180 / Math.PI));
            e.beta = -(e.y * (180 / Math.PI));
        } else if (e.alpha === null && e.beta === null && e.gamma === null) {
            $(window).unbind("deviceorientation", on_window_device_orientation);
            $(window).unbind("MozOrientation", on_window_device_orientation);
        }

        overThreshold = Math.abs(e.gamma) > 4 || Math.abs(e.beta) > 4;
        gamma = overThreshold ? e.gamma : 0;
        beta = overThreshold ? e.beta : 0;

        if (lastGamma !== gamma || lastBeta !== beta) {

            mice = shared.mice;

            for (i = 0, l = mice.length; i < l; i += 1) {

                mouse = mice[i];

                x = Math.round(1.5 * gamma) + mouse.x;
                y = (-Math.round(1.5 * beta)) + mouse.y;

                if (Math.abs(x) > window.innerWidth) {
                    if (x < 0) {
                        x = -window.innerWidth;
                    } else {
                        x = window.innerWidth;
                    }
                }

                if (Math.abs(y) > window.innerHeight) {
                    if (y < 0) {
                        y = -window.innerHeight;
                    } else {
                        y = window.innerHeight;
                    }
                }

                mouse.x = x;
                mouse.y = y;

                eCopy = $.extend({}, e);

                eCopy.identifier = i;

                shared.signals.mousemoved.dispatch(eCopy);

            }

            lastGamma = gamma;
            lastBeta = beta;

            e.preventDefault();
            e.stopPropagation();
            return false;
        }
    }

    function on_key_down(e) {
        shared.signals.keydown.dispatch(e);

        /*
        e.preventDefault();
        e.stopPropagation();
        return false;
        */
    }

    function on_key_up(e) {
        shared.signals.keyup.dispatch(e);

        /*
        e.preventDefault();
        e.stopPropagation();
        return false;
        */
    }

    function on_focus_lose(e) {

        shared.signals.focuslose.dispatch(e);

        if (typeof _Game !== 'undefined') {

            _Game.pause();

        }

    }

    function on_focus_gain(e) {

        shared.signals.focusgain.dispatch(e);

        if (typeof _Game !== 'undefined' && _Game.started !== true) {

            _Game.resume();

        }

    }

    function on_window_resize(e) {

        shared.screenWidth = $(window).width();
        shared.screenHeight = $(window).height();

        shared.signals.windowresized.dispatch(shared.screenWidth, shared.screenHeight);

        if (typeof e !== 'undefined') {
            e.preventDefault();
            e.stopPropagation();
        }
        return false;
    }

    function on_error(error, url, lineNumber) {

        shared.signals.error.dispatch(error, url, lineNumber);

        return true;

    }

    /*===================================================
    
    asset handling
    
    =====================================================*/

    function asset_path_cascade(path) {

        var cascade, part, dotIndex;

        // split path based on \ or /
        // each split is a parent module
        // last is actual module
        cascade = path.split(/[\\\/]/);

        for (i = 0, l = cascade.length; i < l; i++) {

            part = cascade[i];

            // remove all non-alphanumeric
            part = part.replace(/[^\w\.-]+/g, "");

            // cannot be empty
            if (part === '') {

                on_error('Invalid asset cascade', 'Main', 'N/A');

                return;

            }

            cascade[i] = part;

        }

        return cascade;

    }

    main.get_asset = function (location, attempts) {

        var path, cascade, parent, assetName, asset, i, l;

        // init parent and asset
        asset = parent = main;

        // cascade path
        path = main.get_asset_path(location);

        cascade = asset_path_cascade(path);

        // get asset
        for (i = 0, l = cascade.length; i < l; i++) {

            // set as parent for next
            parent = asset;

            assetName = cascade[i];

            asset = parent[assetName];

            // if not a valid cascade point
            if (typeof asset === 'undefined') {

                break;

            }

        }

        // check attempts
        attempts = attempts || 1;

        // if no asset and this is first attempt at finding
        if (typeof asset === 'undefined') {

            // try again with alternate path
            if (attempts === 1) {

                return main.get_asset(main.get_alt_path(path), attempts + 1);

            }

        }

        return asset;

    }

    main.set_asset = function (location, assetNew) {

        var path, cascade, parent, assetName, asset, data, dataNew, i, l;

        // if new asset passed
        if (assetNew instanceof KaiopuaAsset) {

            // init parent and asset
            asset = parent = main;

            // cascade path
            path = main.get_asset_path(location);

            cascade = asset_path_cascade(path);

            // setup asset path
            for (i = 0, l = cascade.length; i < l; i++) {

                // set as parent for next
                parent = asset;

                // get name of current point in cascade
                assetName = cascade[i];

                // get or build asset
                asset = parent[assetName] = parent[assetName] || {};

            }

            // if asset at path and is not empty
            if (asset instanceof KaiopuaAsset && asset.is_empty() === false) {

                // if new asset is not empty
                if (assetNew.is_empty() === false) {

                    // merge new asset into current
                    asset.merge_asset_self(assetNew);

                }

            }
            // else replace current empty asset with new asset
            else {

                parent[assetName] = asset = assetNew;

            }

        }

        return asset;

    }

    main.get_asset_data = function (location) {

        var asset, data;

        // get asset at location
        asset = main.get_asset(location);

        // asset data, assume asset is data if not instance of asset
        data = (asset instanceof KaiopuaAsset) ? asset.data : asset;

        return data;

    }

    main.asset_register = function (path, parameters) {

        var assetNew, assetCurrent, assetCurrentWaiting;

        // initialize new asset
        assetNew = new KaiopuaAsset(path, parameters);

        // asset is usually only useful internally
        // so return asset data
        return assetNew.data;

    }

    main.asset_ready = function (path, asset) {

        var i, l;

        asset = asset || main.get_asset(path);

        if (asset instanceof KaiopuaAsset) {

            // ready and not waiting
            asset.ready = true;

            asset.wait = false;

            // dispatch signal
            if (typeof shared.signals !== 'undefined' && typeof shared.signals.assetReady !== 'undefined') {

                shared.signals.assetReady.dispatch(path);

            }

        }

    }

    main.asset_require = function (requirements, callbackList, waitForAssetsReady, loaderUIContainer, assetSource) {

        var callback_outer, on_asset_ready, on_all_assets_ready, assetsRequired = [],
            assetsWaitingFor = [],
            assetsReady = [],
            listeningForReadySignal = false;

        // get if arguments are not array
        requirements = main.ensure_array(requirements);

        callbackList = main.ensure_array(callbackList);

        // modify original callback to wrap in new function
        // that parses requirements and applies each asset as argument to callback
        // also handle if each asset required needs to be ready before triggering callback
        on_asset_ready = function (path, secondAttempt) {

            var indexWaiting;

            indexWaiting = assetsWaitingFor.indexOf(path);

            // if waiting for asset to be ready
            if (indexWaiting !== -1) {

                assetsWaitingFor.splice(indexWaiting, 1);

                assetsReady.push(path);

                // check if no more to wait for
                if (assetsWaitingFor.length === 0 && assetsReady.length === requirements.length) {

                    // remove signal
                    if (listeningForReadySignal === true) {

                        shared.signals.assetReady.remove(on_asset_ready);

                        listeningForReadySignal = false;

                    }

                    on_all_assets_ready();

                }

            }
            // make one extra attempt with alternative path to check if waiting for asset to be ready
            else if (secondAttempt !== true) {

                on_asset_ready(main.get_alt_path(path), true);

            }

        };

        on_all_assets_ready = function () {

            var i, l, callback;

            // apply all required assets to original callbacks
            for (i = 0, l = callbackList.length; i < l; i++) {

                callback = callbackList[i];

                callback.apply(this, assetsRequired);

            }

            // if source asset passed and needs auto ready update
            if (assetSource instanceof KaiopuaAsset && assetSource.readyAutoUpdate === true) {

                assetSource.on_ready();

            }

        };

        callback_outer = function () {

            var i, l, location, path, asset;

            // hide loader ui
            if (typeof loaderUIContainer !== 'undefined') {

                _AssetLoader.hide_ui({
                    remove: true
                });

            }

            // find all assets
            for (i = 0, l = requirements.length; i < l; i++) {

                location = requirements[i];

                path = main.get_asset_path(location);

                // get asset
                asset = main.get_asset(location);

                // add data to required list
                if (asset instanceof KaiopuaAsset) {

                    assetsRequired.push(asset.data);

                }

                // if needed ready
                if (waitForAssetsReady === true) {

                    assetsWaitingFor.push(path);

                    // check ready status
                    if (asset instanceof KaiopuaAsset && asset.ready === true) {

                        on_asset_ready(path);

                    }
                    // asset not ready, listen for ready signal if not already
                    else if (listeningForReadySignal === false) {

                        listeningForReadySignal = true;

                        shared.signals.assetReady.add(on_asset_ready);

                    }

                }

            }

            // if not waiting for assets to be ready
            if (waitForAssetsReady !== true || requirements.length === 0) {

                on_all_assets_ready();

            }

        };

        // set loader manually if needed
        if (typeof _AssetLoader === 'undefined') {

            _AssetLoader = main.get_asset_data('assets/modules/utils/AssetLoader.js');

        }

        // show loader ui
        if (typeof loaderUIContainer !== 'undefined') {

            _AssetLoader.show_ui({
                parent: loaderUIContainer
            });

        }

        // pass all requirements to loader
        _AssetLoader.load(requirements, callback_outer);

    }

    /*===================================================
    
    asset instance
    
    =====================================================*/

    function KaiopuaAsset(path, parameters) {

        var assetNew = this;

        // handle parameters
        parameters = parameters || {};

        parameters.path = path;

        assetNew.merge_asset_self(parameters, true);

        // if asset has path
        if (typeof assetNew.path !== 'undefined') {

            // store this new asset
            // returned asset from store is new asset merged into current asset if exists
            // or this new asset if no assets at path yet
            assetNew = main.set_asset(assetNew.path, assetNew);

            // regardless of storage results
            // handle this new asset's readiness and requirements
            if (assetNew === this && this.readyAutoUpdate === true && (this.requirements.length === 0 || this.wait !== true)) {

                this.on_ready();

            }

            if (this.requirements.length > 0) {

                main.asset_require(this.requirements, this.callbacksOnReqs, this.wait, this.loaderUIContainer, this);

            }

        }

        return assetNew;

    }

    KaiopuaAsset.prototype = new Object();
    KaiopuaAsset.prototype.constructor = KaiopuaAsset;

    KaiopuaAsset.prototype.handle_requirements = function () {



    }

    KaiopuaAsset.prototype.merge_asset_self = function (asset, includeRequirements) {

        var readyCallbackIndex;

        // TODO:
        // make sure merging accounts for new requirements and loading
        if (typeof asset !== 'undefined') {

            this.path = asset.path;

            // merge asset data into this data
            this.merge_asset_data_self(asset);

            // if either asset is waiting
            if (typeof this.wait !== 'boolean' || this.wait === false) {

                if (asset.wait === true) {

                    this.wait = asset.wait;

                } else {

                    this.wait = false;

                }

            }

            // if asset is not ready
            if (this.ready !== true) {

                this.ready = false;

            }

            // requirements basics
            if (typeof this.readyAutoUpdate !== 'boolean') {

                if (asset.hasOwnProperty('readyAutoUpdate')) {

                    this.readyAutoUpdate = asset.readyAutoUpdate;

                } else {

                    this.readyAutoUpdate = true;

                }

            }

            this.requirements = main.ensure_array(this.requirements);

            this.callbacksOnReqs = main.ensure_array(this.callbacksOnReqs);

            // if should also copy requirements
            if (includeRequirements === true) {

                this.requirements = this.requirements.concat(main.ensure_array(asset.requirements));

                this.callbacksOnReqs = this.callbacksOnReqs.concat(main.ensure_array(asset.callbacksOnReqs));

                this.loaderUIContainer = this.loaderUIContainer || asset.loaderUIContainer;

            }

        }

    }

    KaiopuaAsset.prototype.merge_asset_data_self = function (source) {

        var dataSrc = source.data;

        // if source data exists
        if (typeof dataSrc !== 'undefined') {

            // if this data does not exist or source data is image, set as data instead of merging, as merging causes issues
            if (typeof this.data === 'undefined' || main.is_image(dataSrc)) {

                this.data = dataSrc;

            } else {

                // copy properties of source asset data into this data
                // order is important to ensure this data remains an instance of whatever it is
                main.extend(dataSrc, this.data);

            }

        }

    }

    KaiopuaAsset.prototype.is_empty = function () {

        var isEmpty = true;

        if (typeof this.data !== 'undefined' || (this.ready === false && this.requirements.length > 0)) {

            isEmpty = false;

        }

        return isEmpty;

    }

    KaiopuaAsset.prototype.on_ready = function () {

        main.asset_ready(this.path, this);

    }

    return main;

}(KAIOPUA || {}));

/*
 *
 * AssetLoader.js
 * Handles loading all assets, including images, scripts, and models.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/utils/AssetLoader.js",
        _AssetLoader = {},
        _UIElement, threeLoaderJSON, threeLoaderBIN, threeLoaderErrorMessage = 'Attempted to load model before THREE',
        listIDBase = 'loadList',
        loadingHeaderBase = 'Loading...',
        loadingTips = ['Please wait.'],
        listNumber = 0,
        loading = false,
        listsToLoad = [],
        loadingMessages = {},
        locations = {},
        callbacks = {},
        loaded = {},
        allLoading = [],
        allLoadingListIDs = [],
        allStarted = [],
        allLoaded = [],
        allLoadingOrLoaded = [],
        listCurrent, loadTypeDefault = 'script',
        containerWidth = 260,
        barWidth = containerWidth - 40,
        barHeight = 10,
        barRadius = 5,
        barToFillSpace = 2,
        barMargin = 15,
        container, bar, fill, header, message, domElement;

    /*===================================================
	
	public properties
	
	=====================================================*/

    _AssetLoader.init_ui = init_ui;
    _AssetLoader.hide_ui = hide_ui;
    _AssetLoader.show_ui = show_ui;
    _AssetLoader.clear_ui_progress = clear_ui_progress;
    _AssetLoader.load = load_list;

    _AssetLoader.add_loaded_locations = add_loaded_locations;
    _AssetLoader.get_is_loaded = get_is_loaded;
    _AssetLoader.get_is_loading = get_is_loading;
    _AssetLoader.get_is_loading_or_loaded = get_is_loading_or_loaded;

    Object.defineProperty(_AssetLoader, 'loadingHeader', {
        get: function () {
            return loadingHeaderBase;
        },
        set: function (newHeader) {
            loadingHeaderBase = newHeader;
        }
    });

    Object.defineProperty(_AssetLoader, 'loadingTips', {
        get: function () {
            return loadingTips;
        },
        set: function (newTips) {
            loadingTips = newTips.slice(0);
        }
    });

    main.asset_register(assetPath, {
        data: _AssetLoader,
        requirements: "assets/modules/ui/UIElement.js",
        callbacksOnReqs: init_ui,
        wait: true
    });

    /*===================================================
	
	helper functions
	
	=====================================================*/

    function add_loaded_locations(locationsList) {

        var i, l, location, path, indexLoaded, indexLoading, locationAdded = false;

        if (typeof locationsList !== 'undefined') {

            // get if list is not array
            if (typeof locationsList === 'string' || locationsList.hasOwnProperty('length') === false) {
                locationsList = [locationsList];
            }

            // for each location
            for (i = 0, l = locationsList.length; i < l; i++) {

                location = locationsList[i];

                path = main.get_asset_path(location);

                // update all loading
                indexLoading = allLoading.indexOf(path);

                if (indexLoading !== -1) {

                    allLoadingListIDs.splice(indexLoading, 1);

                    allLoading.splice(indexLoading, 1);

                }

                // update all loaded
                indexLoaded = allLoaded.indexOf(path);

                if (indexLoaded === -1) {

                    allLoaded.push(path);

                    locationAdded = true;

                }

            }

            if (locationAdded === true) {

                allLoadingOrLoaded = allLoaded.concat(allLoading);

            }
        }

    }

    function get_is_path_in_list(location, list) {

        var path, index;

        path = main.get_asset_path(location);

        index = list.indexOf(path);

        if (index !== -1) {

            return true;

        } else {

            return false;

        }

    }

    function get_is_loading_or_loaded(location) {

        return get_is_path_in_list(location, allLoadingOrLoaded);

    }

    function get_is_loaded(location) {

        return get_is_path_in_list(location, allLoaded);

    }

    function get_is_loading(location) {

        return get_is_path_in_list(location, allLoading);

    }

    function get_load_type(location) {

        return location.type || loadTypeDefault;

    }

    /*===================================================
	
	ui functions
	
	=====================================================*/

    function init_ui(uie) {

        _UIElement = uie;

        container = new _UIElement.Instance({
            id: 'asset_loader',
            elementType: 'section',
            classes: 'info_panel',
            width: containerWidth
        });

        // bar
        bar = new _UIElement.Instance({
            width: barWidth,
            cssmap: {
                'position': 'relative',
                'border-style': 'solid',
                'border-color': '#FFFFFF',
                'border-width': '1px',
                'border-radius': barRadius + 'px',
                'padding': barToFillSpace + 'px',
                'margin-top': barMargin + 'px',
                'margin-bottom': barMargin + 'px',
                'margin-left': 'auto',
                'margin-right': 'auto'
            }
        });

        // fill
        fill = new _UIElement.Instance({
            width: 0,
            height: barHeight,
            cssmap: {
                'position': 'relative',
                'background': '#FFFFFF',
                'border-radius': barRadius + 'px'
            }
        });

        // header
        header = new _UIElement.Instance({
            elementType: 'header',
            classes: 'text_large title_alt',
            width: barWidth,
            html: loadingHeaderBase,
            cssmap: {
                'position': 'relative',
                'margin-top': barMargin + 'px',
                'margin-left': 'auto',
                'margin-right': 'auto'
            }
        });

        // message
        message = new _UIElement.Instance({
            elementType: 'p',
            width: barWidth,
            html: loadingTips[0],
            cssmap: {
                'position': 'relative',
                'margin-bottom': barMargin + 'px',
                'margin-left': 'auto',
                'margin-right': 'auto'
            }
        });

        // display
        fill.parent = bar;

        header.parent = container;
        bar.parent = container;
        message.parent = container;

        // center
        container.alignment = 'center';

        // hide
        container.hide({
            remove: false,
            time: 0
        });

    }

    function hide_ui() {

        container.hide.apply(container, arguments);

    }

    function show_ui() {

        container.show.apply(container, arguments);

    }

    function update_ui_progress(message) {
        var locationsList, loadedList, total, pct = 1;

        if (typeof fill !== 'undefined') {

            // set loading message
            if (typeof message !== 'undefined') {

                $(message.domElement).html(message);

            }

            if (typeof listCurrent !== 'undefined') {

                locationsList = locations[listCurrent];
                loadedList = loaded[listCurrent];
                total = locationsList.length + loadedList.length;

                if (isNaN(total) === false) {
                    pct = loadedList.length / total;
                }

                fill.width = fill.parent.width * pct;

            } else {
                clear_ui_progress();
            }

        }

    }

    function clear_ui_progress() {
        if (typeof fill !== 'undefined') {

            fill.width = 0;

        }
    }

    /*===================================================
	
	loading functions
	
	=====================================================*/

    function load_list(locationsList, callbackList, listID, loadingMessage) {

        var i, l, location, path, indexLoading, indexLoaded, allLocationsLoaded = true,
            assetData;

        if (typeof locationsList !== 'undefined') {

            // get if list is not array
            if (typeof locationsList === 'string' || locationsList.hasOwnProperty('length') === false) {
                locationsList = [locationsList];
            }

            // make a copy of locations list
            locationsList = locationsList.slice(0);

            // handle list id
            if (typeof listID !== 'string' || locations.hasOwnProperty(listID)) {

                listID = listIDBase + listNumber;

            }

            // permanent store of all loading
            for (i = 0, l = locationsList.length; i < l; i++) {

                location = locationsList[i];

                path = main.get_asset_path(location);

                indexLoading = allLoading.indexOf(path);
                indexLoaded = allLoaded.indexOf(path);

                // if not already loading or loaded item
                // load new location
                if (indexLoading === -1 && indexLoaded == -1) {

                    allLoading.push(path);

                    allLoadingListIDs.push(listID);

                    newLocations = true;

                }

                // if not yet loaded, mark list for loading
                if (indexLoaded === -1) {

                    allLocationsLoaded = false;

                }

            }

            allLoadingOrLoaded = allLoaded.concat(allLoading);

            // increase list number
            listNumber += 1;

            // temporary store locations
            locations[listID] = locationsList;

            // temporary store callback list
            if (typeof callbackList === 'undefined') {
                callbackList = [];
            } else if (typeof callbackList === 'function' || callbackList.hasOwnProperty('length') === false) {
                callbackList = [callbackList];
            }

            callbacks[listID] = callbackList;

            // store load message
            if (typeof loadingMessage !== 'string') {

                loadingMessage = loadingTips[Math.max(0, Math.min(loadingTips.length - 1, Math.round(Math.random() * loadingTips.length) - 1))];
            }

            loadingMessages[listID] = loadingMessage;

            // init new loaded array
            loaded[listID] = [];

            // add list ID to lists to load
            listsToLoad.push(listID);

            // if all locations in list are already loaded, skip loading process
            if (allLocationsLoaded === true) {

                list_completed(listID);

            } else {

                // start loading
                load_next_list();

            }

        }

    }

    function load_next_list() {
        var i, l, locationsList, location, path;

        // if any lists to load
        if (loading === false && listsToLoad.length > 0) {

            loading = true;

            // get next list 
            listCurrent = listsToLoad[0];

            // update ui to reset fill
            update_ui_progress(loadingMessages[listCurrent]);

            // get locations, make copy because already loaded items will be removed from list immediately
            locationsList = locations[listCurrent].slice(0);

            // for each item location
            for (i = 0, l = locationsList.length; i < l; i += 1) {

                location = locationsList[i];

                path = main.get_asset_path(location);

                // if already loaded
                if (allLoaded.indexOf(path) !== -1) {

                    // make duplicate complete event
                    load_single_completed(location);

                }
                // if not started loading yet
                else if (allStarted.indexOf(path) === -1) {

                    // load it
                    allStarted.push(path);

                    load_single(location);

                }

            }

        } else {

            // no longer loading
            listCurrent = undefined;

            shared.signals.loadAllCompleted.dispatch();

        }

    }

    function load_single(location) {
        var path, ext, loadType, data, defaultCallback = function () {
                load_single_completed(location, data);
            },
            modelCallback = function (geometry) {
                load_single_completed(location, geometry);
            };

        if (typeof location !== 'undefined') {

            // load based on type of location and file extension
            // LAB handles scripts (js)
            // THREE handles models (ascii/bin js) and images (jpg/png/gif/bmp)
            // get type
            loadType = location.type || loadTypeDefault;

            // get location path
            path = main.get_asset_path(location);

            // get extension
            ext = main.get_ext(path);

            // ensure path has extension
            if (ext === '') {

                path = main.add_default_ext(path);

            }

            // type and/or extension check
            if (loadType === 'image' || main.is_image_ext(ext)) {

                // load
                data = new Image();
                data.onload = defaultCallback;
                data.crossOrigin = '';
                data.src = path;

                // store empty image data in assets immediately
                main.asset_register(path, {
                    data: data
                });

            } else if (loadType === 'model' || loadType === 'model_ascii') {

                if (typeof THREE === 'undefined') {
                    main.utils.error.generate(threeLoaderErrorMessage, 'Loader');
                } else {

                    // init loader if needed
                    if (typeof threeLoaderJSON === 'undefined') {
                        threeLoaderJSON = new THREE.JSONLoader(true);
                    }

                    threeLoaderJSON.load(path, modelCallback);
                }
            }
            // default to script loading
            else {

                $LAB.script(path).wait(defaultCallback);

            }

        }

    }

    function load_single_completed(location, data) {
        var i, l, listID, locationsList, locationInCurrentList = false,
            index, path, loadType, listsCompleted;

        // get location path and type
        path = main.get_asset_path(location);

        loadType = get_load_type(location);

        // register asset
        main.asset_register(path, {
            data: data
        });

        // add as loaded
        add_loaded_locations(path);

        // shared signal
        if (typeof shared !== 'undefined') {

            shared.signals.loadItemCompleted.dispatch(path);

        }

        // for each list loading
        for (i = 0, l = listsToLoad.length; i < l; i++) {

            listID = listsToLoad[i];

            locationsList = locations[listID];

            // get index in locations list
            index = locationsList.indexOf(location);

            // if is in list
            if (index !== -1) {

                // remove location from locations list
                locationsList.splice(index, index !== -1 ? 1 : 0);

                // add location to loaded list
                loaded[listID].push(location);

                // if is current list
                if (listID === listCurrent) {

                    // update ui
                    update_ui_progress();

                }

                // if current list is complete, defer until all checked
                if (locationsList.length === 0) {

                    listsCompleted = listsCompleted || [];

                    listsCompleted.push(listID);

                }

            }

        }

        // complete any completed lists
        if (typeof listsCompleted !== 'undefined') {

            for (i = 0, l = listsCompleted.length; i < l; i++) {

                list_completed(listsCompleted[i]);

            }

        }

    }

    function list_completed(listID) {
        var i, l, callbackList, callback, listIndex;

        // remove list from all lists to load
        listIndex = listsToLoad.indexOf(listID);

        if (listIndex !== -1) {

            listsToLoad.splice(listIndex, 1);

        }

        // do callbacks before clear
        callbackList = callbacks[listID];

        for (i = 0, l = callbackList.length; i < l; i++) {

            callback = callbackList[i];

            if (typeof callback !== 'undefined') {

                callback.call(this);

            }

        }

        // shared signal
        if (typeof shared !== 'undefined') {

            shared.signals.loadListCompleted.dispatch(listID);

        }

        // clear
        delete locations[listID];

        delete callbacks[listID];

        delete loadingMessages[listID];

        delete loaded[listID];

        loading = false;

        // start next list
        load_next_list();

    }

}(KAIOPUA));

/*
 *
 * Game.js
 * Game specific methods and functionality.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/core/Game.js",
        _Game = {},
        _AssetLoader, _ErrorHandler, _MathHelper, _ObjectHelper, _Physics, _GUI, _UIElement, _Menu, _Button, _Launcher, _Intro, renderer, renderTarget, renderComposer, renderPasses, scene, sceneBG, sceneDefault, sceneBGDefault, fog, camera, cameraBG, cameraDefault, cameraBGDefault, bg, menus = {},
        currentSection, previousSection, paused = false,
        started = false,
        utilProjector1Selection, utilRay1Selection, utilVec31Selection, sectionChangePauseTime = 500,
        dependencies = ["assets/modules/utils/AssetLoader.js", "assets/modules/utils/ErrorHandler.js", ],
        assetsBasic = ["assets/modules/ui/UIElement.js", "assets/modules/ui/Button.js", "assets/modules/ui/Menu.js", "assets/modules/ui/GUI.js", "assets/modules/utils/MathHelper.js", "js/lib/three/Three.js", "js/lib/Tween.js", "js/lib/jquery.transform2d.min.js", "js/lib/jquery.tipTip.min.js"],
        assetsThreeExtras = ["js/lib/three/ThreeExtras.js", "js/lib/three/postprocessing/ShaderExtras.js", "js/lib/three/postprocessing/EffectComposer.js", "js/lib/three/postprocessing/RenderPass.js", "js/lib/three/postprocessing/ShaderPass.js", "js/lib/three/postprocessing/MaskPass.js", "js/lib/three/physics/Collisions.js", "js/lib/three/physics/CollisionUtils.js", "assets/modules/effects/FocusVignette.js"],
        assetsLauncher = ["assets/modules/sections/Launcher.js", "assets/modules/env/WaterLauncher.js", "assets/modules/env/SkyLauncher.js", "assets/textures/cloud_256.png", "assets/textures/light_ray.png", "assets/textures/skybox_launcher_xz.jpg", "assets/textures/skybox_launcher_posy.jpg", "assets/textures/skybox_launcher_negy.jpg"],
        assetsGame = [
            /*"js/lib/ammo.js",*/ "assets/modules/core/Physics.js", "assets/modules/core/Player.js", "assets/modules/core/Model.js", "assets/modules/core/CameraControls.js", "assets/modules/ui/Messenger.js", "assets/modules/ui/Button.js", "assets/modules/ui/Menu.js", "assets/modules/ui/Inventory.js", "assets/modules/utils/ObjectMaker.js", "assets/modules/utils/ObjectHelper.js", "assets/modules/characters/Character.js", "assets/modules/characters/Hero.js", "assets/modules/env/World.js", "assets/modules/env/WorldIsland.js", "assets/modules/env/Water.js", "assets/modules/env/Sky.js", "assets/modules/puzzles/Puzzle.js", "assets/modules/puzzles/Grid.js", "assets/modules/puzzles/GridModule.js", "assets/modules/puzzles/GridModuleState.js", "assets/modules/puzzles/GridElement.js", "assets/modules/farming/Farming.js", "assets/modules/farming/Planting.js", "assets/modules/farming/Field.js", "assets/modules/farming/Plant.js", "assets/modules/sections/Intro.js",
        {
            path: "assets/models/Whale_Head.js",
            type: 'model'
        }, {
            path: "assets/models/Whale_Tail.js",
            type: 'model'
        }, {
            path: "assets/models/Hero.js",
            type: 'model'
        }, {
            path: "assets/models/Sun_Moon.js",
            type: 'model'
        }, {
            path: "assets/models/Cloud_001.js",
            type: 'model'
        }, {
            path: "assets/models/Cloud_002.js",
            type: 'model'
        }, {
            path: "assets/models/Hut.js",
            type: 'model'
        }, {
            path: "assets/models/Hut_Hill.js",
            type: 'model'
        }, {
            path: "assets/models/Hut_Steps.js",
            type: 'model'
        }, {
            path: "assets/models/Bed.js",
            type: 'model'
        }, {
            path: "assets/models/Banana_Leaf_Door.js",
            type: 'model'
        }, {
            path: "assets/models/Surfboard.js",
            type: 'model'
        }, {
            path: "assets/models/Grass_Clump_001.js",
            type: 'model'
        }, {
            path: "assets/models/Grass_Clump_002.js",
            type: 'model'
        }, {
            path: "assets/models/Grass_Line_001.js",
            type: 'model'
        }, {
            path: "assets/models/Grass_Line_002.js",
            type: 'model'
        }, {
            path: "assets/models/Palm_Tree.js",
            type: 'model'
        }, {
            path: "assets/models/Palm_Trees.js",
            type: 'model'
        }, {
            path: "assets/models/Kukui_Tree.js",
            type: 'model'
        }, {
            path: "assets/models/Kukui_Trees.js",
            type: 'model'
        }, {
            path: "assets/models/Taro_Plant.js",
            type: 'model'
        }, {
            path: "assets/models/Taro_Plant_Double.js",
            type: 'model'
        }, {
            path: "assets/models/Rock.js",
            type: 'model'
        }, {
            path: "assets/models/Rock_Purple.js",
            type: 'model'
        }, {
            path: "assets/models/Rock_Blue.js",
            type: 'model'
        }, {
            path: "assets/models/Volcano_Large.js",
            type: 'model'
        }, {
            path: "assets/models/Volcano_Small.js",
            type: 'model'
        }, {
            path: "assets/models/Volcano_Rocks_001.js",
            type: 'model'
        }, {
            path: "assets/models/Volcano_Rocks_002.js",
            type: 'model'
        }, {
            path: "assets/models/Volcano_Rocks_003.js",
            type: 'model'
        }, {
            path: "assets/models/Volcano_Rocks_004.js",
            type: 'model'
        }, {
            path: "assets/models/Volcano_Rocks_005.js",
            type: 'model'
        }, {
            path: "assets/models/Field_Tutorial.js",
            type: 'model'
        }, "assets/textures/skybox_world_posx.jpg", "assets/textures/skybox_world_negx.jpg", "assets/textures/skybox_world_posy.jpg", "assets/textures/skybox_world_negy.jpg", "assets/textures/skybox_world_posz.jpg", "assets/textures/skybox_world_negz.jpg", "assets/textures/waves_512.png"],
        loadingHeader = 'Hold on, we need some stuff from Hawaii...',
        loadingTips = [
            ///////////////////////////////////////////// = bad sentence size
                    "Aloha kaua means may there be friendship or love between us.", "Mahalo nui loa means thanks very much.", "Kali iki means wait a moment.", "Ko'u hoaloha means my friend.", "Kane means male or man.", "Wahine means female or woman.", "Ali'i kane means king or chieftan.", "Ali'i wahine means queen or chiefess.", "He mea ho'opa'ani means to play a game.", "Kai means sea or ocean.", "'Opua means puffy clouds.", "Kai 'Opua means clouds over the ocean.", "Iki means small or little.", "Nui means large or huge."];

    /*===================================================
    
    public properties
    
    =====================================================*/

    // functions
    _Game.resume = resume;
    _Game.pause = pause;

    _Game.add_to_scene = add_to_scene;
    _Game.remove_from_scene = remove_from_scene;

    _Game.get_intersection_from_mouse = get_intersection_from_mouse;
    _Game.get_object_under_mouse = get_object_under_mouse;

    _Game.is_event_in_game = is_event_in_game;

    // getters and setters
    Object.defineProperty(_Game, 'paused', {
        get: function () {
            return paused;
        }
    });

    Object.defineProperty(_Game, 'started', {
        get: function () {
            return started;
        }
    });

    Object.defineProperty(_Game, 'scene', {
        get: function () {
            return scene;
        },
        set: set_scene
    });

    Object.defineProperty(_Game, 'sceneBG', {
        get: function () {
            return sceneBG;
        },
        set: set_scene_bg
    });

    Object.defineProperty(_Game, 'camera', {
        get: function () {
            return camera;
        },
        set: set_camera
    });

    Object.defineProperty(_Game, 'cameraBG', {
        get: function () {
            return cameraBG;
        },
        set: set_camera_bg
    });

    main.asset_register(assetPath, {
        data: _Game,
        readyAutoUpdate: false,
        requirements: dependencies,
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init and loading
    
    =====================================================*/

    function init_internal(al, err) {
        console.log('internal game');
        _AssetLoader = al;
        _ErrorHandler = err;

        // register error listeners
        shared.signals.error.add(on_error);

        // check for errors
        if (_ErrorHandler.check()) {

            _ErrorHandler.process();

        }
        // safe to start game
        else {

            // set loading messages
            _AssetLoader.loadingHeader = loadingHeader;
            _AssetLoader.loadingTips = loadingTips;

            // start loading
            load_basics();

        }

    }

    function load_basics() {

        main.asset_require(assetsBasic, [load_three_extras]);

    }

    function load_three_extras() {

        main.asset_require(assetsThreeExtras, [init_basics, load_launcher]);

    }

    function load_launcher() {

        main.asset_require(assetsLauncher, [init_launcher, load_game]);

    }

    function load_game() {

        main.asset_require(assetsGame, init_game, true, _GUI.layers.ui.domElement);

    }

    /*===================================================
    
    init with basic assets
    
    =====================================================*/

    function init_basics() {

        var shaderScreen = THREE.ShaderExtras["screen"],
            shaderFocusVignette = main.get_asset_data("assets/modules/effects/FocusVignette");

        // modify THREE classes
        add_three_modifications();

        // utility
        _UIElement = main.get_asset_data("assets/modules/ui/UIElement.js");
        _GUI = main.get_asset_data("assets/modules/ui/GUI.js");
        _MathHelper = main.get_asset_data("assets/modules/utils/MathHelper.js");

        utilProjector1Selection = new THREE.Projector();
        utilRay1Selection = new THREE.Ray();
        utilVec31Selection = new THREE.Vector3();

        // cardinal axes
        shared.cardinalAxes = {
            up: new THREE.Vector3(0, 1, 0),
            forward: new THREE.Vector3(0, 0, 1),
            right: new THREE.Vector3(-1, 0, 0)
        }

        // game signals
        shared.signals = shared.signals || {};
        shared.signals.paused = new signals.Signal();
        shared.signals.resumed = new signals.Signal();
        shared.signals.update = new signals.Signal();

        // tween update
        // wrap because update signal passes time delta, and tween update needs time
        shared.signals.update.add(function () {
            TWEEN.update();
        });

        // renderer
        renderer = new THREE.WebGLRenderer({
            antialias: false,
            clearColor: 0x000000,
            clearAlpha: 0,
            maxLights: 4
        });
        renderer.setSize(shared.screenWidth, shared.screenHeight);
        renderer.autoClear = false;

        // shadows
        /*
		renderer.shadowCameraNear = 3;
		renderer.shadowCameraFar = 20000;
		renderer.shadowCameraFov = 90;
		
		renderer.shadowMapBias = 0.0039;
		renderer.shadowMapDarkness = 0.5;
		renderer.shadowMapWidth = 2048;
		renderer.shadowMapHeight = 2048;
		
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		*/
        // render target
        renderTarget = new THREE.WebGLRenderTarget(shared.screenWidth, shared.screenHeight, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.NearestFilter
        });

        // share renderer
        shared.renderer = renderer;
        shared.renderTarget = renderTarget;

        // scenes
        sceneDefault = new THREE.Scene();
        sceneBGDefault = new THREE.Scene();

        // fog
        fog = new THREE.Fog(0xffffff, -100, 10000);

        sceneDefault.fog = fog;

        // camera
        cameraDefault = new THREE.PerspectiveCamera(60, shared.screenWidth / shared.screenHeight, 1, 20000);
        cameraBGDefault = new THREE.PerspectiveCamera(60, shared.screenWidth / shared.screenHeight, 1, 20000);

        cameraDefault.useQuaternion = cameraBGDefault.useQuaternion = true;

        // passes
        renderPasses = {
            bg: new THREE.RenderPass(sceneBGDefault, cameraBGDefault),
            env: new THREE.RenderPass(sceneDefault, cameraDefault),
            screen: new THREE.ShaderPass(shaderScreen),
            focusVignette: new THREE.ShaderPass(shaderFocusVignette)
        };

        // settings
        renderPasses.env.clear = false;

        renderPasses.screen.renderToScreen = true;

        renderPasses.focusVignette.uniforms["screenWidth"].value = shared.screenWidth;
        renderPasses.focusVignette.uniforms["screenHeight"].value = shared.screenHeight;
        renderPasses.focusVignette.uniforms["vingenettingOffset"].value = 0.6;
        renderPasses.focusVignette.uniforms["vingenettingDarkening"].value = 0.5;
        renderPasses.focusVignette.uniforms["sampleDistance"].value = 0.1;
        renderPasses.focusVignette.uniforms["waveFactor"].value = 0.3;

        // set default scene and camera
        set_default_cameras_scenes();

        // composer
        set_render_processing();

        // add basic ui to display
        _GUI.renderer = new _UIElement.Instance({
            id: 'renderer',
            domElement: renderer.domElement
        });
        _GUI.layers.display.add(_GUI.renderer);

        // resize
        shared.signals.windowresized.add(resize);
        resize(shared.screenWidth, shared.screenHeight);

        // set ready
        main.asset_ready(assetPath);

        // start drawing
        animate();

    }

    function add_three_modifications() {

        // quaternion normalized lerp
        THREE.Quaternion.nlerp = function (qa, qb, qr, t) {

            var tFrom = 1 - t;

            qr.x = qa.x * tFrom + qb.x * t;
            qr.y = qa.y * tFrom + qb.y * t;
            qr.z = qa.z * tFrom + qb.z * t;
            qr.w = qa.w * tFrom + qb.w * t;

            qr.normalize();

            return qr;

        }

        // vector3 normalized lerp
        THREE.Vector3.nlerp = function (va, vb, vr, t) {

            var tFrom = 1 - t;

            vr.x = va.x * tFrom + vb.x * t;
            vr.y = va.y * tFrom + vb.y * t;
            vr.z = va.z * tFrom + vb.z * t;

            vr.normalize();

            return vr;

        }

    }

    /*===================================================
    
    init launcher
    
    =====================================================*/

    function init_launcher(l) {

        _Launcher = l;
        console.log('init launcher', _Launcher);
        set_section(_Launcher);

    }

    /*===================================================
    
    init game
    
    =====================================================*/

    function init_game() {

        var m = _GUI.menus,
            b = _GUI.buttons;

        // assets
        _ObjectHelper = main.get_asset_data("assets/modules/utils/ObjectHelper.js");
        _Button = main.get_asset_data('assets/modules/ui/Button.js');
        _Menu = main.get_asset_data('assets/modules/ui/Menu.js');

        // ui
        m.start.childrenByID.play.callback = function () {
            start_game();
        };
        m.start.childrenByID.play.context = this;

        m.main.childrenByID.resume.callback = function () {
            resume();
        };
        m.main.childrenByID.resume.context = this;

        b.end.callback = function () {
            stop_game();
        };
        b.end.context = this;

        b.mainMenu.callback = function () {
            _Game.pause();
        };
        b.mainMenu.context = this;

        // menus
        m.start.alignment = 'center';
        m.main.alignment = 'center';

        m.navigation.spacingBottom = 20;
        m.navigation.alignment = 'bottomcenter';

        // setup ui groups
        _GUI.add_to_group('start', [{
            child: m.start,
            parent: _GUI.layers.ui
        }, {
            child: m.footer,
            parent: _GUI.container
        }]);

        _GUI.add_to_group('pause', [{
            child: m.main,
            parent: _GUI.layers.ui
        }, {
            child: m.footer,
            parent: _GUI.container
        }]);

        _GUI.add_to_group('ingame', [{
            child: m.navigation,
            parent: _GUI.layers.ui
        }]);

        _GUI.add_to_group('constant', [{
            child: b.fullscreenEnter,
            parent: _GUI.layers.ui
        }]);

        // show initial groups
        _GUI.show_group('constant');
        _GUI.show_group('start');

    }

    /*===================================================
    
    render functions
    
    =====================================================*/

    function set_render_processing(passesNames) {

        var i, l, requiredPre = ['bg', 'env'],
            requiredPost = ['screen'],
            passName, bgPass = renderPasses.bg,
            envPass = renderPasses.env,
            defaultPassIndex;

        // init composer
        renderComposer = new THREE.EffectComposer(renderer);

        // check that passes camera and scene match current
        // bg
        if (bgPass.scene !== sceneBG) {
            bgPass.scene = sceneBG;
        }

        if (bgPass.camera !== cameraBG) {
            bgPass.camera = cameraBG;
        }

        // env
        if (envPass.scene !== scene) {
            envPass.scene = scene;
        }

        if (envPass.camera !== camera) {
            envPass.camera = camera;
        }

        // if should use default passes
        if (typeof passesNames === 'undefined' || passesNames.hasOwnProperty('length') === false) {

            passesNames = [];

        }

        // add required
        // required pre
        for (i = requiredPre.length - 1; i >= 0; i--) {

            passName = requiredPre[i];

            defaultPassIndex = passesNames.indexOf(passName);

            if (defaultPassIndex === -1) {

                passesNames.unshift(passName);

            }

        }

        // required post
        for (i = requiredPost.length - 1; i >= 0; i--) {

            passName = requiredPost[i];

            defaultPassIndex = passesNames.indexOf(passName);

            if (defaultPassIndex === -1) {

                passesNames.push(passName);

            }

        }

        // add each pass in passes names
        for (i = 0, l = passesNames.length; i < l; i++) {

            passName = passesNames[i];

            if (typeof renderPasses[passName] !== 'undefined') {

                renderComposer.addPass(renderPasses[passName]);

            }

        }

    }

    /*===================================================
    
    scene functions
    
    =====================================================*/

    function set_scene(sceneNew) {

        var scenePrev = scene;

        renderPasses.env.scene = scene = sceneNew || sceneDefault;

        if (scene !== scenePrev && typeof camera !== 'undefined') {

            if (typeof scenePrev !== 'undefined') {
                scenePrev.remove(camera);
            }

            scene.add(camera);

        }

    }

    function set_scene_bg(sceneNew) {

        var sceneBGPrev = sceneBG;

        renderPasses.bg.scene = sceneBG = sceneNew || sceneBGDefault;

        if (sceneBG !== sceneBGPrev && typeof cameraBG !== 'undefined') {

            if (typeof sceneBGPrev !== 'undefined') {
                sceneBGPrev.remove(cameraBG);
            }

            sceneBG.add(cameraBG);

        }

    }

    function add_to_scene(objects, sceneDefault) {

        var i, l, object, object3D, sceneTarget, callback;

        // handle parameters
        sceneDefault = sceneDefault || scene;

        // for each object
        if (objects.hasOwnProperty('length') === false) {
            objects = [objects];
        }

        for (i = 0, l = objects.length; i < l; i++) {

            object = objects[i];

            callback = object.callbackAdd;

            sceneTarget = object.sceneTarget || sceneDefault;

            object3D = object.addTarget || object;

            // add
            if (typeof object3D !== 'undefined') {

                sceneTarget.add(object3D);

            }

            // if callback passed
            if (typeof callback === 'function') {

                callback.call(this);

            }

        }

    }

    function remove_from_scene(objects, sceneDefault) {

        var i, l, object, object3D, sceneTarget, callback;

        // handle parameters
        sceneDefault = sceneDefault || scene;

        // for each object
        if (objects.hasOwnProperty('length') === false) {
            objects = [objects];
        }

        for (i = 0, l = objects.length; i < l; i++) {

            object = objects[i];

            callback = object.callbackRemove;

            sceneTarget = object.sceneTarget || sceneDefault;

            object3D = object.addTarget || object;

            // remove
            if (typeof object3D !== 'undefined') {

                sceneTarget.remove(object3D);

            }

            // if callback passed
            if (typeof callback === 'function') {

                callback.call(this);

            }

        }

    }

    /*===================================================
    
    camera functions
    
    =====================================================*/

    function set_camera(cameraNew) {

        var cameraPrev = camera;

        if (typeof cameraPrev !== 'undefined' && typeof scene !== 'undefined') {

            scene.remove(cameraPrev);

        }

        renderPasses.env.camera = camera = cameraNew || cameraDefault;

        if (typeof scene !== 'undefined') {

            scene.add(camera);

        }

    }

    function set_camera_bg(cameraNew) {

        var cameraBGPrev = cameraBG;

        if (typeof cameraBGPrev !== 'undefined' && typeof sceneBG !== 'undefined') {

            sceneBG.remove(cameraBGPrev);

        }

        renderPasses.bg.camera = cameraBG = cameraNew || cameraBGDefault;

        if (typeof sceneBG !== 'undefined') {

            sceneBG.add(cameraBG);

        }

    }

    /*===================================================
    
    mouse functions
    
    =====================================================*/

    function get_intersection_from_mouse(objects, traverseHierarchy, mouse, cameraTarget) {

        var projector = utilProjector1Selection,
            ray = utilRay1Selection,
            mousePosition = utilVec31Selection,
            intersections, intersectedMesh;

        // handle parameters
        objects = objects || scene;

        traverseHierarchy = (typeof traverseHierarchy === 'boolean') ? traverseHierarchy : true;

        mouse = mouse || main.get_mouse();

        cameraTarget = cameraTarget || camera;

        // account for hierarchy and extract all children
        if (traverseHierarchy !== false) {

            objects = _ObjectHelper.extract_children_from_objects(objects, objects);

        }

        // get corrected mouse position
        mousePosition.x = (mouse.x / shared.screenWidth) * 2 - 1;
        mousePosition.y = -(mouse.y / shared.screenHeight) * 2 + 1;
        mousePosition.z = 0.5;

        // unproject mouse position
        projector.unprojectVector(mousePosition, cameraTarget);

        // set ray
        ray.origin = cameraTarget.position;
        ray.direction = mousePosition.subSelf(cameraTarget.position).normalize();

        // find ray intersections
        intersections = ray.intersectObjects(objects);

        if (intersections.length > 0) {

            return intersections[0];

        }

    }

    function get_object_under_mouse(objects, traverseHierarchy, mouse, cameraTarget) {

        var intersection = get_intersection_from_mouse(objects, traverseHierarchy, mouse, cameraTarget);

        if (typeof intersection !== 'undefined') {

            return intersection.object;

        }

    }

    /*===================================================
    
    section functions
    
    =====================================================*/

    function set_default_cameras_scenes() {

        set_scene();
        set_scene_bg();

        set_camera();
        set_camera_bg();

    }

    function set_section(section, callback) {

        var hadPreviousSection = false,
            newSectionCallback = function () {

                if (typeof previousSection !== 'undefined') {

                    previousSection.remove();

                }

                section.resize(shared.screenWidth, shared.screenHeight);

                section.show();

                currentSection = section;

                resume();

                if (typeof callback !== 'undefined') {

                    callback.call();

                }

            };

        // pause game while switching
        pause();

        // hide current section
        if (typeof currentSection !== 'undefined') {

            hadPreviousSection = true;

            previousSection = currentSection;

            previousSection.hide();

            _GUI.transitioner.show({
                parent: _GUI.layers.overlayAll,
                opacity: 1
            });

        }

        // no current section
        currentSection = undefined;

        // default scene and camera
        set_default_cameras_scenes();

        // set started
        if (typeof startedValue !== 'undefined') {

            started = startedValue;

        }

        // start and show new section
        if (typeof section !== 'undefined') {

            // wait for transitioner to finish fading in
            if (hadPreviousSection === true) {

                window.requestTimeout(function () {

                    newSectionCallback();

                }, _GUI.transitioner.timeShow);

            }
            // no previous section, create new immediately
            else {

                newSectionCallback();

            }

        }

    }

    /*===================================================
    
    start / stop game
    
    =====================================================*/

    function start_game() {
        console.log('start game');
        // assets
        _Physics = main.get_asset_data('assets/modules/core/Physics.js');
        _Intro = main.get_asset_data('assets/modules/sections/Intro.js');

        // ui
        _GUI.hide_group('start', {
            remove: true
        });

        // set intro section
        set_section(_Intro, function () {

            _GUI.show_group('ingame');

        });

        // set started
        started = true;

    }

    function stop_game() {

        started = false;

        _GUI.hide_group('pause', {
            remove: true
        });

        // set launcher section
        set_section(_Launcher, function () {

            _GUI.show_group('start');

        });

    }

    /*===================================================
    
    pause / resume
    
    =====================================================*/

    function pause(preventDefault) {

        // set state
        if (paused === false) {

            paused = true;

            // handle ui
            if (started === true) {

                _GUI.transitioner.show({
                    parent: _GUI.layers.overlayDisplay
                });

                if (preventDefault !== true) {

                    _GUI.hide_group('ingame', {
                        remove: true,
                        time: 0
                    });
                    _GUI.show_group('pause');

                }

            } else {

                _GUI.transitioner.show({
                    parent: _GUI.layers.overlayAll
                });

            }

            // add listener for click on transitioner
            _GUI.transitioner.domElement.on('mouseup.resume touchend.resume', resume);

            // signal
            shared.signals.paused.dispatch();

            // render once to ensure user is not surprised when resuming
            render();

        }

    }

    function resume() {

        if (paused === true && _ErrorHandler.errorState !== true) {

            // add listener for click on transitioner
            _GUI.transitioner.domElement.off('.resume');

            if (started === true) {

                _GUI.hide_group('pause', {
                    remove: true,
                    time: 0
                });
                _GUI.show_group('ingame');

            }

            _GUI.transitioner.hide({
                remove: true
            });

            paused = false;

            shared.signals.resumed.dispatch();

        }
    }

    /*===================================================
    
    animate / render
    
    =====================================================*/

    function animate() {

        var timeDelta, timeDeltaMod;

        requestAnimationFrame(animate);

        // handle time
        shared.timeLast = shared.time;

        shared.time = new Date().getTime();

        timeDelta = shared.time - shared.timeLast;

        // get time delta modifier from timeDelta vs expected refresh interval
        timeDeltaMod = _MathHelper.round(timeDelta / shared.timeDeltaExpected, 2);

        if (main.is_number(timeDeltaMod) !== true) {

            timeDeltaMod = 1;

        }

        // update
        if (paused !== true) {

            // update physics
            if (typeof _Physics !== 'undefined') {
                _Physics.update(timeDelta, timeDeltaMod);
            }

            // update all others
            shared.signals.update.dispatch(timeDelta, timeDeltaMod);

            // have camera bg mimic camera rotation
            cameraBG.quaternion.copy(camera.quaternion);

            // finish frame
            render();

        }

    }

    function render() {

        renderer.setViewport(0, 0, shared.screenWidth, shared.screenHeight);

        renderer.clear();

        renderComposer.render();

    }

    function resize(W, H) {

        // render passes
        renderPasses.focusVignette.uniforms["screenWidth"].value = W;
        renderPasses.focusVignette.uniforms["screenHeight"].value = H;

        // renderer
        renderer.setSize(W, H);
        renderTarget.width = W;
        renderTarget.height = H;

        // cameras
        camera.aspect = W / H;
        camera.updateProjectionMatrix();

        cameraBG.aspect = W / H;
        cameraBG.updateProjectionMatrix();

        // composer
        renderComposer.reset();

        // re-render
        render();

    }

    /*===================================================
	
	utility
	
	=====================================================*/

    function is_event_in_game(e) {

        var result = false;

        if (_GUI && _GUI.layers.display instanceof _UIElement.Instance) {

            result = _GUI.layers.display.domElement.find(e.target).length > 0;

        }

        return result;

    }

    function on_error(error, url, lineNumber) {

        // pause game
        pause(true);

        // check error handler state
        if (_ErrorHandler.errorState !== true) {

            _ErrorHandler.generate(error, url, lineNumber);

        }

        // save game
        // TODO
        // debug
        throw error + " at " + lineNumber + " in " + url;

    }

}(KAIOPUA));

/*
 *
 * Model.js
 * Adds additional functionality to basic Mesh.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */

(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/core/Model.js",
        _Model = {},
        _Physics, _ObjectHelper, _MathHelper, durationBase = 1000,
        durationPerFrameMinimum = shared.timeDeltaExpected || 1000 / 60;
    objectCount = 0, morphsNumMin = 5;

    main.asset_register(assetPath, {
        data: _Model,
        requirements: ["assets/modules/core/Physics.js", "assets/modules/utils/ObjectHelper.js", "assets/modules/utils/MathHelper.js", "js/lib/Tween.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    function init_internal(p, oh, mh) {
        console.log('internal model', _Model);
        _Physics = p;
        _ObjectHelper = oh;
        _MathHelper = mh;

        // instance
        _Model.Instance = Model;
        _Model.Instance.prototype = new THREE.Mesh();
        _Model.Instance.prototype.constructor = _Model.Instance;
        _Model.Instance.prototype.tween_properties = tween_properties;

        // catch parent changes and add / remove physics automatically
        Object.defineProperty(_Model.Instance.prototype, 'parent', {
            get: function () {
                return this._parent;
            },
            set: function (newParent) {

                var scene;

                // store new parent
                this._parent = newParent;

                // search for scene
                scene = this;

                while (typeof scene.parent !== 'undefined') {

                    scene = scene.parent;

                }

                // if parent is child of scene, add physics
                if (scene instanceof THREE.Scene) {

                    _Physics.add(this);

                }
                // else default to remove
                else {

                    _Physics.remove(this);

                }

            }

        });

    }

    /*===================================================
	
	model
	
	=====================================================*/

    // adds functionality to and inherits from THREE.Mesh
    function Model(parameters) {

        var i, l, geometry, vertices, vertex, vertPos, materials, materialsToModify, material, rotation, position, morphs;

        // handle parameters
        parameters = parameters || {};

        // geometry
        if (parameters.geometry instanceof THREE.Geometry) {

            geometry = parameters.geometry;

        } else if (typeof parameters.geometry === 'string') {

            geometry = main.get_asset_data(parameters.geometry);

        } else {

            geometry = new THREE.Geometry();

        }

        // materials
        materials = parameters.materials || [];

        if (materials.hasOwnProperty('length') === false) {
            materials = [materials];
        }

        materialsToModify = materials.slice(0);

        // if has geometry materials
        if (geometry.materials && geometry.materials.length > 0) {

            // add to all
            for (i = 0, l = geometry.materials.length; i < l; i++) {

                material = geometry.materials[i];

                materialsToModify.push(material);
            }

        }

        // if no materials yet, add default
        if (materials.length === 0) {

            materials = [new THREE.MeshFaceMaterial()];

            materialsToModify = materialsToModify.concat(materials);

        }

        // material properties
        for (i = 0, l = materialsToModify.length; i < l; i++) {
            material = materialsToModify[i];

            // morph targets
            if (material.hasOwnProperty('morphTargets')) {

                material.morphTargets = geometry.morphTargets && geometry.morphTargets.length > 0 ? true : false;

            }

            // shading
            // (1 = flat, 2 = smooth )
            if (parameters.hasOwnProperty('shading')) {

                material.shading = parameters.shading;

            }
        }

        // call prototype constructor
        THREE.Mesh.call(this, geometry, /* currently no multimaterials */ materials[0]);

        // force use quaternion
        this.useQuaternion = true;

        // rotation
        if (parameters.hasOwnProperty('rotation')) {

            rotation = parameters.rotation;

            // quaternion
            if (rotation instanceof THREE.Quaternion) {

                this.quaternion.copy(rotation);

            }
            // vector
            else if (rotation instanceof THREE.Vector3) {

                this.quaternion.setFromEuler(rotation);

            }
            // matrix
            else if (rotation instanceof THREE.Matrix4) {

                this.quaternion.setFromRotationMatrix(rotation);

            }

        }

        // position
        if (parameters.hasOwnProperty('position') && parameters.position instanceof THREE.Vector3) {

            position = parameters.position;

            this.position.copy(position);

        }

        // shadows
        if (parameters.hasOwnProperty('castShadow') === true) {

            this.castShadow = parameters.castShadow;

        }

        if (parameters.hasOwnProperty('receiveShadow') === true) {

            this.receiveShadow = parameters.receiveShadow;

        }

        // flip sided
        if (parameters.hasOwnProperty('flipSided') === true) {

            this.flipSided = parameters.flipSided;

        }

        // double sided
        if (parameters.hasOwnProperty('doubleSided') === true) {

            this.doubleSided = parameters.doubleSided;

        }

        // targetable, default to false
        if (parameters.hasOwnProperty('targetable')) {

            this.targetable = parameters.targetable;

        } else {

            this.targetable = false;

        }

        // interactive, default to false
        if (parameters.hasOwnProperty('interactive')) {

            this.interactive = parameters.interactive;

        } else {

            this.interactive = false;

        }

        // morphs
        this.morphs = make_morphs_handler(this);

        // adjust for offset if needed
        if (parameters.center === true) {

            _ObjectHelper.object_center(this);

        }

        if (parameters.centerRotation === true) {

            _ObjectHelper.object_center_rotation(this);

        }

        // physics
        if (parameters.hasOwnProperty('physics')) {

            this.physics = _Physics.translate(this, parameters.physics);

        }

        // id
        this.id = parameters.id || this.id;

    }

    /*===================================================
	
	tweening
	
	=====================================================*/

    function tween_properties(parameters) {

        var me = this,
            time, easing, position = this.position,
            quaternion = this.quaternion,
            scale = this.scale,
            positionTo, quaternionTo, scaleTo;

        if (main.type(parameters) === 'object' && main.is_number(parameters.time)) {

            // reusable tween
            if (this.tween instanceof TWEEN.Tween !== true) {

                this.tweenValues = {};

                this.tween = new TWEEN.Tween(this.tweenValues).onUpdate(function () {

                    if (me.tweening.position === true) {

                        me.position.set(me.tweenValues.px, me.tweenValues.py, me.tweenValues.pz);

                    }

                    if (me.tweening.quaternion === true) {

                        me.quaternion.set(me.tweenValues.qx, me.tweenValues.qy, me.tweenValues.qz, me.tweenValues.qw);

                    }

                    if (me.tweening.scale === true) {

                        me.scale.set(me.tweenValues.sx, me.tweenValues.sy, me.tweenValues.sz);

                    }

                });
                /*.onComplete( function () {
						
						console.log(' tween complete ');
					
					} );*/

            }

            // properties
            time = parameters.time;
            easing = parameters.easing || TWEEN.Easing.Quadratic.EaseInOut;
            positionTo = parameters.position;
            quaternionTo = parameters.quaternion;
            scaleTo = parameters.scale;

            this.tweening = {};
            this.tweenTo = {};

            // position
            if (positionTo instanceof THREE.Vector3) {

                // init values
                this.tweenValues.px = position.x;
                this.tweenValues.py = position.y;
                this.tweenValues.pz = position.z;

                this.tweenTo.px = positionTo.x;
                this.tweenTo.py = positionTo.y;
                this.tweenTo.pz = positionTo.z;

                this.tweening.position = true;

            }

            // rotation
            if (quaternionTo instanceof THREE.Quaternion) {

                // init values
                this.tweenValues.qx = quaternion.x;
                this.tweenValues.qy = quaternion.y;
                this.tweenValues.qz = quaternion.z;
                this.tweenValues.qw = quaternion.w;

                this.tweenTo.qx = quaternionTo.x;
                this.tweenTo.qy = quaternionTo.y;
                this.tweenTo.qz = quaternionTo.z;
                this.tweenTo.qw = quaternionTo.w;

                this.tweening.quaternion = true;

            }

            // scale
            if (scaleTo instanceof THREE.Vector3) {

                // init values
                this.tweenValues.sx = scale.x;
                this.tweenValues.sy = scale.y;
                this.tweenValues.sz = scale.z;

                this.tweenTo.sx = scaleTo.x;
                this.tweenTo.sy = scaleTo.y;
                this.tweenTo.sz = scaleTo.z;

                this.tweening.scale = true;

            }

            this.tween.to(this.tweenTo, time).easing(easing).start();

        }

    }

    /*===================================================
	
	morphs
	
	=====================================================*/

    // creates handler for a model's morphs (animations and colors)
    // records indices of morphs (targets or colors) in geometry object
    // groups morphs into each single animation cycle by name
    // naming scheme is 'name' + 'number'
    function make_morphs_handler(mesh) {
        var i, l, morphColors, morphs = {},
            shapes, colors;

        // morph types
        morphs.shapes = shapes = parse_morph_list(mesh);

        morphs.colors = colors = {}; // not supported yet // parse_morph_list( morphColors );
        // functions
        morphs.play = function (name, parameters) {

            var shapesList = shapes.list,
                updates = shapes.updates,
                uNames = updates.names,
                uList = updates.list,
                updaterIndex, updater, morphsMap;

            // if morph name exists
            if (typeof shapesList[name] !== 'undefined' && shapesList[name].map.length !== 0) {

                // get morphs map
                morphsMap = shapesList[name].map;

                // get if updater for animation exists
                updaterIndex = uNames.indexOf(name);

                // new updater
                if (updaterIndex === -1) {

                    updater = make_morph_updater(name);

                    // add to lists
                    uNames.push(name);

                    uList[name] = updater;

                }
                // get existing
                else {

                    updater = uList[name];

                }

                // start updating
                updater.start(mesh, morphsMap, parameters);

            }

            return this;

        };

        morphs.stop = function (name) {

            var updates = shapes.updates,
                uList = updates.list,
                updater;

            updater = uList[name];

            if (typeof updater !== 'undefined') {

                updater.stop();

            }

            return this;

        };

        morphs.stopAll = function () {

            var i, l, updates = shapes.updates,
                uNames = updates.names,
                uName, uList = updates.list;

            // search through all morphs for name
            // if name not passed or is wildcard, stop all
            for (i = 0, l = uNames.length; i < l; i++) {

                uName = uNames[i];

                this.stop(uName);

            }

            return this;

        };

        morphs.clear = function (name, duration) {

            var updates = shapes.updates,
                uList = updates.list,
                updater;

            updater = uList[name];

            if (typeof updater !== 'undefined') {

                updater.clear(duration);

            }

            return this;

        };

        morphs.clearAll = function (duration) {

            var i, l, updates = shapes.updates,
                uNames = updates.names,
                uName, uList = updates.list;

            // search through all morphs for name
            // if name not passed or is wildcard, clear all
            for (i = 0, l = uNames.length; i < l; i++) {

                uName = uNames[i];

                this.clear(uName, duration);

            }

            return this;

        };

        return morphs;
    }

    function parse_morph_list(mesh) {

        var i, l, geometry = mesh.geometry,
            morphs = geometry.morphTargets || [],
            data = {},
            list = {},
            names = [],
            updates = [],
            morph, name, nameParsed, morphData, map;

        // parses all morphs
        for (i = 0, l = morphs.length; i < l; i++) {

            morph = morphs[i];

            name = morph.name;

            // extract base name and number
            nameParsed = parse_morph_name(name);

            // if morph map does not exist
            // create new data
            if (typeof list[nameParsed.name] === 'undefined') {

                names.push(nameParsed.name);

                list[nameParsed.name] = {

                    map: []

                };

            }

            // get correct data
            morphData = list[nameParsed.name];

            // get map
            map = morphData.map;

            // add morph to data map
            map.push({
                index: i,
                number: nameParsed.number
            });

        }

        // sort maps
        for (i = 0, l = names.length; i < l; i++) {

            morphData = list[names[i]];

            map = morphData.map;

            // sort map by number
            map.sort(sort_morph_map);

        }

        // if geometry has morphs
        // check stability
        if (morphs.length > 0) {

            // adds stability morph to end of morphs list, identical to base geometry
            // as required to make model + morphtargets work
            add_stability_morph(mesh);

            // ensure minimum number of morphs
            for (i = morphs.length, l = morphsNumMin; i < l; i++) {

                add_stability_morph(mesh);

            }

        }

        // init updates
        updates.names = [];
        updates.list = {};

        // public properties
        data.list = list;
        data.names = names;
        data.updates = updates;

        return data;
    }

    function sort_morph_map(a, b) {

        return a.number - b.number;

    }

    function parse_morph_name(name) {
        var nameParsed = {
            name: name,
            number: 0
        },
            splitIndex, numberTest;

        // get split of base name and number by last _
        splitIndex = name.lastIndexOf('_');

        if (splitIndex !== -1) {

            numberTest = parseFloat(name.substr(splitIndex + 1));

            // test if is number
            if (main.is_number(numberTest)) {

                nameParsed.name = name.substr(0, splitIndex);

                nameParsed.number = numberTest;

            }
        }

        return nameParsed;
    }

    function add_stability_morph(mesh) {

        var i, l, geometry = mesh.geometry,
            vertices = geometry.vertices,
            vertex, vertPos, morphNumber = mesh.morphTargetInfluences.length,
            morphInfo = {
                name: 'stability_morph_' + morphNumber,
                vertices: []
            },
            morphVertices = morphInfo.vertices;

        for (i = 0, l = vertices.length; i < l; i++) {

            vertex = vertices[i];

            vertPos = vertex.position;

            morphVertices.push(new THREE.Vertex(new THREE.Vector3(vertPos.x, vertPos.y, vertPos.z)));

        }

        // add morph target to list
        geometry.morphTargets.push(morphInfo);

        // update morph target info in mesh
        mesh.morphTargetInfluences.push(0);
        mesh.morphTargetDictionary[morphInfo.name] = morphNumber;

    }

    function morph_colors_to_face_colors(geometry) {

        if (geometry.morphColors && geometry.morphColors.length) {

            var colorMap = geometry.morphColors[0];

            for (var i = 0; i < colorMap.colors.length; i++) {

                geometry.faces[i].color = colorMap.colors[i];

            }

        }

    }

    /*===================================================
	
	morph updates
	
	=====================================================*/

    function make_morph_updater(name) {
        var updater = {},
            info;

        // init updater
        info = updater.info = {
            name: name,
            updating: false
        };

        updater.start = function (mesh, morphsMap, parameters, updatingParameters) {

            var durationNew, durationPrev, durationFramePrev, durationFrameNew, timeFromStart, framePct, cyclePct;

            // if not already updating
            if (info.updating !== true) {

                parameters = parameters || {};

                info.mesh = mesh;

                info.morphsMap = morphsMap;

                info.duration = info.durationOriginal = parameters.duration || durationBase;

                if (parameters.hasOwnProperty('loop') === true) {

                    info.loop = parameters.loop;

                } else {

                    info.loop = false;

                }

                info.loopDelay = parameters.loopDelay || 0;

                info.loopChance = parameters.loopChance || 1;

                info.loopChance = _MathHelper.clamp(info.loopChance, 0, 1);

                if (parameters.hasOwnProperty('reverseOnComplete') === true) {

                    info.reverseOnComplete = parameters.reverseOnComplete;

                } else {

                    info.reverseOnComplete = false;

                }

                info.reverse = false;

                info.direction = 1;

                info.interpolationDirection = 1;

                info.durationShift = parameters.durationShift || 0;

                info.callback = parameters.callback;

                // reset
                if (parameters.reset !== false) {
                    updater.reset();
                }

                // change remaining parameters
                this.changeParameters(parameters);

                // resume
                updater.resume();

            }
            // if new parameters passed
            else {

                this.changeParameters(parameters);

            }

            return this;

        };

        updater.changeParameters = function (parameters) {

            parameters = parameters || {};

            // stop clearing
            if (info.clearing === true) {

                info.clearing = false;

            }

            // duration
            if (main.is_number(parameters.duration) && (parameters.duration / info.morphsMap.length) > durationPerFrameMinimum && info.durationOriginal !== parameters.duration) {

                durationNew = parameters.duration;

                durationPrev = info.duration;

                timeFromStart = info.time - info.timeStart;

                cyclePct = timeFromStart / durationPrev;

                // fix time start to account for difference in durations
                info.timeStart += (durationPrev * cyclePct) - (durationNew * cyclePct);

                // fix frame time delta to account for new duration per frame
                durationFramePrev = durationPrev / info.morphsMap.length;

                durationFrameNew = durationNew / info.morphsMap.length;

                framePct = info.frameTimeDelta / durationFramePrev;

                info.frameTimeDelta = durationFrameNew * framePct;

                // store new duration
                info.duration = info.durationOriginal = durationNew;

            }

            // direction
            if (typeof parameters.reverse === 'boolean' && info.reverse !== parameters.reverse) {

                info.reverse = parameters.reverse;

                info.direction = (info.reverse === true) ? -1 : 1;

                // special case for single morph
                if (info.morphsMap.length === 1) {

                    // if morph is not already in zero state
                    if (info.direction === -1 && mesh.morphTargetInfluences[info.morphsMap[0]] > 0) {
                        info.interpolationDirection = -1;
                    }

                    // direction cannot be in reverse
                    info.direction = 1;

                }

            }

            return this;

        };

        updater.reset = function (isLooping) {

            var loopDelay;

            info.timeStart = new Date().getTime();

            info.numFramesUpdated = 0;

            info.duration = info.durationOriginal + (Math.random() * info.durationShift);

            if (info.reverseOnComplete === true) {

                info.direction = -info.direction;

                if (info.direction === -1) {
                    info.frame = info.morphsMap.length - 1;
                } else {
                    info.frame = 0;
                }

            }

            // if first reset, or not looping
            if (isLooping !== true) {

                info.time = info.timeLast = info.timeStart;

                info.frameTimeDelta = 0;

                if (info.direction === -1) {
                    info.frame = info.morphsMap.length - 1;
                } else {
                    info.frame = 0;
                }

                info.frameLast = info.frameLast || -1;

            }
            // handle looping
            else {

                updater.handleLooping(info.loopDelay);

            }

            return this;

        };

        updater.handleLooping = function (delay) {

            // delay
            delay = delay || 0;

            if (Math.random() > info.loopChance) {

                delay += info.durationOriginal;

            }

            // if should resume after loop delay
            if (delay > 0) {

                // stop waiting on loop delay
                if (typeof info.loopDelayID !== 'undefined') {
                    clearRequestTimeout(info.loopDelayID);
                }

                // pause updater
                updater.stop();

                info.loopDelayID = requestTimeout(updater.handleLooping, delay);

            }
            // else resume
            else {

                updater.resume();

            }

        };

        updater.reverseDirection = function () {

            info.direction = -info.direction;

        };

        updater.reverseInterpolationDirection = function () {

            info.interpolationDirection = -info.interpolationDirection;

        };

        updater.update = function (timeDelta) {

            var i, l, loop = info.loop,
                callback, morphsMap = info.morphsMap,
                influences = info.mesh.morphTargetInfluences,
                numFrames = morphsMap.length,
                time = info.time,
                timeStart = info.timeStart,
                timeLast = info.timeLast,
                timeFromStart = time - timeStart,
                duration = info.duration,
                cyclePct = timeFromStart / duration,
                frameTimeDelta, frame, frameLast, morphIndex, morphIndexLast, direction, durationFrame, interpolationDirection, interpolationDelta;

            // if clearing
            if (info.clearing === true) {

                // properties
                interpolationDelta = (timeDelta / duration);

                // decrease all morphs by the same amount at the same time
                for (i = 0, l = numFrames; i < l; i++) {

                    morphIndex = morphsMap[i].index;

                    influences[morphIndex] = Math.min(1, Math.max(0, influences[morphIndex] - interpolationDelta));

                }

            }
            // else default frame to frame interpolation
            else {

                // properties
                frame = info.frame;
                frameLast = info.frameLast;
                morphIndex = morphsMap[frame].index;
                direction = info.direction;
                durationFrame = duration / numFrames;
                interpolationDirection = info.interpolationDirection;
                interpolationDelta = (timeDelta / durationFrame) * interpolationDirection;

                // update frameTimeDelta
                frameTimeDelta = info.frameTimeDelta += timeDelta;

                // if frame should swap
                if (frameTimeDelta >= durationFrame) {

                    // reset frame time delta
                    // account for large time delta
                    info.frameTimeDelta = Math.max(0, frameTimeDelta - durationFrame);

                    // record new frames for next cycle
                    info.frameLast = info.frame;

                    info.frame = frame + 1 * direction;

                    info.numFramesUpdated++;

                    // reset frame to start?
                    if (direction === -1 && info.frame < 0) {

                        info.frame = numFrames - 1;

                    } else if (direction === 1 && info.frame > numFrames - 1) {

                        info.frame = 0;

                    }

                    // push influences to max / min
                    if (frameLast > -1) {

                        morphIndexLast = morphsMap[frameLast].index;

                        influences[morphIndexLast] = 0;

                    }

                    influences[morphIndex] = 1;

                    // special case for looping single morphs
                    if (morphsMap.length === 1) {

                        if (interpolationDirection === -1) {

                            influences[morphIndex] = 0;

                        }

                        info.frameLast = -1;

                        updater.reverseInterpolationDirection();

                    }

                }
                // change influences by interpolation delta
                else {

                    // current frame
                    influences[morphIndex] = Math.max(0, Math.min(1, influences[morphIndex] + interpolationDelta));

                    // last frame
                    if (frameLast > -1) {

                        morphIndexLast = morphsMap[frameLast].index;

                        influences[morphIndexLast] = Math.min(1, Math.max(0, influences[morphIndexLast] - interpolationDelta));

                    }

                }

            }

            // update time
            info.timeLast = info.time;
            info.time += timeDelta;

            // reset, looping and callback
            if (cyclePct >= 1 || info.numFramesUpdated >= numFrames) {

                // if clearing, finish
                if (info.clearing === true) {

                    updater.clear();

                }
                // if looping, do looping cycle reset
                else if (loop === true) {

                    updater.reset(loop);

                }
                // else stop
                else {

                    updater.stop();

                }

                callback = info.callback;

                if (typeof callback !== 'undefined') {

                    callback.call();

                }

            }

        };

        updater.resume = function () {

            if (info.updating !== true) {

                // stop waiting on loop delay
                if (typeof info.loopDelayID !== 'undefined') {
                    clearRequestTimeout(info.loopDelayID);
                }

                // start updating
                info.updating = true;

                info.cleared = false;

                shared.signals.update.add(updater.update);

            }

            return this;

        };

        updater.stop = function () {

            if (info.updating === true) {

                info.updating = false;

                shared.signals.update.remove(updater.update);

            }

            return this;

        };

        updater.clear = function (duration) {
            var i, l, influences = info.mesh.morphTargetInfluences,
                morphsMap = info.morphsMap;

            if (info.cleared !== true) {

                // clear over duration
                if (duration > 0) {

                    // if not already clearing over duration
                    if (info.clearing !== true || info.duration !== duration) {

                        this.reset(false);

                        info.duration = duration;

                        info.clearing = true;

                        this.resume();

                    }

                } else {

                    this.stop();

                    this.reset(false);

                    // reset influences
                    for (i = 0, l = morphsMap.length; i < l; i++) {

                        influences[morphsMap[i].index] = 0;

                    }

                    info.clearing = false;

                    info.cleared = true;

                }

            }

            return this;

        }

        return updater;
    }

}(KAIOPUA));

/*
 *
 * Physics.js
 * Simple raycasting based physics that works directly with rendering engine.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/core/Physics.js",
        _Physics = {},
        _ObjectHelper, _MathHelper, ready = false,
        system, worldGravitySource, worldGravityMagnitude, linkBaseName = 'visual_physical_link_',
        linkCount = 0,
        links = [],
        scaleSpeedExp = Math.log(1.5),
        utilVec31FaceSrc, utilVec31RotateToSrc, utilVec32RotateToSrc, utilQ1RotateToSrc, utilQ2RotateToSrc, utilQ3RotateToSrc, utilVec31Update, utilVec32Update, utilVec33Update, utilVec34Update, utilVec35Update, utilVec31Velocity, utilVec31Offset, utilQ4Offset, utilVec31Raycast, utilRay1Casting, utilVec31Pull, utilVec32Pull, utilVec33Pull;

    /*===================================================
    
    public properties
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Physics,
        requirements: ["assets/modules/utils/ObjectHelper.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(oh, mh) {
        console.log('internal physics');

        _ObjectHelper = oh;
        _MathHelper = mh;

        // functions
        _Physics.translate = translate;
        _Physics.add = add;
        _Physics.remove = remove;
        _Physics.start = start;
        _Physics.stop = stop;
        _Physics.update = update;

        _Physics.rotate_relative_to_source = rotate_relative_to_source;
        _Physics.pull_to_source = pull_to_source;

        // signals
        shared.signals.physicssafetynetstart = new signals.Signal();
        shared.signals.physicssafetynetend = new signals.Signal();

        // properties
        _Physics.timeWithoutIntersectionThreshold = 500;

        Object.defineProperty(_Physics, 'worldGravitySource', {
            get: function () {
                return worldGravitySource;
            },
            set: set_world_gravity_source
        });

        Object.defineProperty(_Physics, 'worldGravityMagnitude', {
            get: function () {
                return worldGravityMagnitude;
            },
            set: set_world_gravity_magnitude
        });

        Object.defineProperty(_Physics, 'system', {
            get: function () {
                return system;
            }
        });

        // init
        init_system();

    }

    function init_system() {

        // system
        system = new THREE.CollisionSystem();
        set_world_gravity_source(new THREE.Vector3(0, 0, 0));
        set_world_gravity_magnitude(new THREE.Vector3(0, -1, 0));

        // utility / conversion objects
        utilVec31RotateToSrc = new THREE.Vector3();

        utilVec31RotateToSrc = new THREE.Vector3();
        utilVec32RotateToSrc = new THREE.Vector3();
        utilQ1RotateToSrc = new THREE.Quaternion();
        utilQ2RotateToSrc = new THREE.Quaternion();
        utilQ3RotateToSrc = new THREE.Quaternion();

        utilVec31Update = new THREE.Vector3();
        utilVec32Update = new THREE.Vector3();
        utilVec33Update = new THREE.Vector3();
        utilVec34Update = new THREE.Vector3();
        utilVec35Update = new THREE.Vector3();

        utilVec31Offset = new THREE.Vector3();
        utilQ4Offset = new THREE.Quaternion();

        utilVec31Velocity = new THREE.Vector3();

        utilVec31Raycast = new THREE.Vector3();
        utilRay1Casting = new THREE.Ray();

        utilVec31Pull = new THREE.Vector3();
        utilVec32Pull = new THREE.Vector3();
        utilVec33Pull = new THREE.Vector3();

    }

    /*===================================================
    
    translate / add / remove
    
    =====================================================*/

    // translates a mesh + parameters into a new rigid body
    function translate(mesh, parameters) {

        var i, l, geometry, bbox, bboxDimensions, bodyType, link, collider, dynamic = false,
            width, height, depth, needWidth, needHeight, needDepth, radius, boxMax, boxMin, centerOffset, mass, position, rotation, velocityMovement, velocityGravity;

        // handle parameters
        parameters = parameters || {};

        bodyType = parameters.bodyType;

        // validity check
        if (typeof mesh === 'undefined' || typeof bodyType !== 'string') {

            return;

        }

        // handle mesh
        geometry = parameters.geometry || mesh.geometry;

        if (parameters.hasOwnProperty('dynamic') === true) {

            dynamic = parameters.dynamic;

        }

        position = parameters.position || mesh.position;

        rotation = parameters.rotation || (mesh.useQuaternion === true ? mesh.quaternion : mesh.rotation);

        // physics width/height/depth
        width = parameters.width;

        height = parameters.height;

        depth = parameters.depth;

        if (main.is_number(width) === false) {

            needWidth = true;

        }

        if (main.is_number(height) === false) {

            needHeight = true;

        }

        if (main.is_number(depth) === false) {

            needDepth = true;

        }

        if (needWidth === true || needHeight === true || needDepth === true) {

            // model bounding box
            bboxDimensions = _ObjectHelper.dimensions(mesh);

            if (needWidth === true) {

                width = bboxDimensions.x;

            }

            if (needHeight === true) {

                height = bboxDimensions.y;

            }

            if (needDepth === true) {

                depth = bboxDimensions.z;

            }

        }

        mass = parameters.mass || width * height * depth;

        // create collider
        if (bodyType === 'mesh') {

            collider = THREE.CollisionUtils.MeshColliderWBox(mesh);

        } else if (bodyType === 'sphere') {

            radius = Math.max(width, height, depth) * 0.5;

            collider = new THREE.SphereCollider(position, radius);

        } else if (bodyType === 'plane') {

            collider = new THREE.PlaneCollider(position, parameters.up || new THREE.Vector3(0, 0, 1));

        }
        // default box
        else {

            boxMax = new THREE.Vector3(width, height, depth).multiplyScalar(0.5);
            boxMin = boxMax.clone().multiplyScalar(-1);

            collider = new THREE.BoxCollider(boxMin, boxMax);

        }

        // dynamic or static
        if (mass <= 0) {

            dynamic = false;

        } else if (parameters.hasOwnProperty('dynamic') === true) {

            dynamic = parameters.dynamic;

        }

        // if not dynamic set mass to 0 for a static object
        if (dynamic !== true) {

            mass = 0;

        }

        // store mesh directly in collider
        // fixes some collision bugs?
        collider.mesh = mesh;

        // create link
        linkCount++;

        link = {
            name: parameters.name || linkBaseName + linkCount,
            mesh: mesh,
            rigidBody: {
                collider: collider,
                dynamic: dynamic,
                mass: mass,
                velocityMovement: generate_velocity_tracker({
                    damping: parameters.movementDamping,
                    offset: parameters.movementOffset,
                    relativeRotation: mesh
                }),
                velocityGravity: generate_velocity_tracker({
                    damping: parameters.gravityDamping,
                    offset: parameters.gravityOffset
                }),
                axes: {
                    up: shared.cardinalAxes.up.clone(),
                    forward: shared.cardinalAxes.forward.clone(),
                    right: shared.cardinalAxes.right.clone()
                }
            },
            safe: true,
            safetynet: {
                position: new THREE.Vector3(),
                quaternion: new THREE.Quaternion(),
            },
            safetynetstart: new signals.Signal(),
            safetynetend: new signals.Signal()
        };

        return link;
    }

    // adds object's physics link to physics world
    function add(object) {

        modify_links(object, true);

    }

    // removes object's physics link from physics world
    function remove(object) {

        modify_links(object);

    }

    // adds or removes physics links from physics world
    // TODO: allow passing of links directly
    function modify_links(object, adding) {

        var i, l, link, rigidBody, indexCollider, indexLink, child;

        if (typeof object !== 'undefined') {

            // own physics
            if (typeof object.physics !== 'undefined') {

                link = object.physics;

                rigidBody = link.rigidBody;

                // zero out velocities
                rigidBody.velocityMovement.force.set(0, 0, 0);

                rigidBody.velocityGravity.force.set(0, 0, 0);

                // get indices
                indexCollider = system.colliders.indexOf(rigidBody.collider);

                indexLink = links.indexOf(link);

                // if adding
                if (adding === true) {

                    // system
                    if (indexCollider === -1) {

                        system.colliders.push(rigidBody.collider);

                    }

                    // links
                    if (indexLink === -1) {

                        links.push(link);

                    }

                }
                // default to remove
                else {

                    // system
                    if (indexCollider !== -1) {

                        system.colliders.splice(indexCollider, 1);

                    }

                    // links
                    if (indexLink !== -1) {

                        links.splice(indexLink, 1);

                    }

                }

            }

            // search for physics in children
            if (typeof object.children !== 'undefined') {

                for (i = 0, l = object.children.length; i < l; i++) {

                    child = object.children[i];

                    modify_links(child, adding);

                }

            }

        }

    }

    /*===================================================
    
    utility functions
    
    =====================================================*/

    function set_world_gravity_source(source) {
        worldGravitySource = new THREE.Vector3(source.x, source.y, source.z);
    }

    function set_world_gravity_magnitude(magnitude) {
        worldGravityMagnitude = new THREE.Vector3(magnitude.x, magnitude.y, magnitude.z);
    }

    /*===================================================
    
    velocity
    
    =====================================================*/

    function generate_velocity_tracker(parameters) {
        var velocity = {};

        // handle parameters
        parameters = parameters || {};

        parameters.damping = parameters.damping || 0.99;

        // init velocity
        velocity.force = new THREE.Vector3();
        velocity.forceRotated = new THREE.Vector3();
        velocity.damping = new THREE.Vector3().addScalar(parameters.damping);
        velocity.offset = parameters.offset && parameters.offset instanceof THREE.Vector3 ? parameters.offset : new THREE.Vector3();
        velocity.relativeRotation = parameters.relativeRotation;
        velocity.moving = false;
        velocity.intersection = false;
        velocity.timeWithoutIntersection = 0;

        return velocity;
    }

    /*===================================================
    
    dimensions and bounds
    
    =====================================================*/

    function dimensions_from_collider(rigidBody) {
        var collider = rigidBody.collider,
            colliderMin, colliderMax, dimensions = new THREE.Vector3();

        // get collider type by collider properties
        if (typeof collider.min !== 'undefined') {

            colliderMin = collider.min;
            colliderMax = collider.max;

        } else if (typeof collider.box !== 'undefined') {

            colliderMin = collider.box.min;
            colliderMax = collider.box.max;

        } else if (typeof collider.radiusSq !== 'undefined') {

            colliderMin = new THREE.Vector3();
            colliderMax = new THREE.Vector3().addScalar(collider.radiusSq);

        }
        // collider type not supported
        else {
            return dimensions;
        }

        dimensions.sub(colliderMax, colliderMin);

        return dimensions;
    }

    function dimensions_from_collider_scaled(rigidBody, mesh) {

        return dimensions_from_collider(rigidBody).multiplySelf(mesh.scale);

    }

    function offset_by_length_in_local_direction(mesh, localDirection, length) {

        var offset = new THREE.Vector3(length, length, length),
            maxDim, localDirection, uV33 = utilVec31Offset,
            uQ4 = utilQ4Offset;

        // set in direction
        offset.multiplySelf(localDirection);

        // rotate to match mesh
        offset = rotate_vector3_to_mesh_rotation(mesh, offset);

        return offset;

    }

    function offset_from_dimensions_in_direction(mesh, direction, dimensions) {

        var offset, maxDim, localDirection, uV33 = utilVec31Offset,
            uQ4 = utilQ4Offset;

        // set all dimensions to max dimension
        //maxDim = Math.max( dimensions.x, dimensions.y, dimensions.z );
        //dimensions.set( maxDim, maxDim, maxDim );
        // copy half of dimensions and add 1 to avoid ray casting to self
        offset = dimensions.clone().multiplyScalar(0.5).addScalar(1);

        // add center offset
        offset.subSelf(_ObjectHelper.center_offset(mesh));

        // get local direction
        // seems like extra unnecessary work
        // not sure if there is better way
        uQ4.copy(mesh.quaternion).inverse();

        localDirection = uV33.copy(direction);
        localDirection.normalize();

        uQ4.multiplyVector3(localDirection);

        // set in direction
        offset.multiplySelf(localDirection);

        // rotate to match mesh
        offset = rotate_vector3_to_mesh_rotation(mesh, offset);

        return offset;
    }

    /*===================================================
    
	rotation
    
    =====================================================*/

    function rotate_vector3_to_mesh_rotation(mesh, vec3, rotatedVec3) {

        var rotation;

        if (mesh.useQuaternion === true) {

            rotation = mesh.quaternion;

        } else {

            rotation = mesh.matrix;

        }

        return rotate_vector3_relative_to(rotation, vec3, rotatedVec3);

    }

    function rotate_vector3_relative_to(rotation, vec3, rotatedVec3) {

        if (rotatedVec3 instanceof THREE.Vector3) {
            rotatedVec3.copy(vec3);
        } else {
            rotatedVec3 = vec3.clone();
        }

        if (rotation instanceof THREE.Quaternion || rotation instanceof THREE.Matrix4) {

            rotation.multiplyVector3(rotatedVec3);

        } else if (rotation instanceof THREE.Vector3) {

            rotatedVec3.x = rotation.x * vec3.x + rotation.x * vec3.y + rotation.x * vec3.z;
            rotatedVec3.y = rotation.y * vec3.x + rotation.y * vec3.y + rotation.y * vec3.z;
            rotatedVec3.z = rotation.z * vec3.x + rotation.z * vec3.y + rotation.z * vec3.z;

        } else if (rotation instanceof THREE.Object3D) {

            rotatedVec3 = rotate_vector3_to_mesh_rotation(rotation, vec3, rotatedVec3);

        }

        return rotatedVec3;

    }

    function rotate_relative_to_source(mesh, source, axisAway, axisForward, lerpDelta, rigidBody) {

        var uv31 = utilVec31RotateToSrc,
            uv32 = utilVec32RotateToSrc,
            uq1 = utilQ1RotateToSrc,
            uq2 = utilQ2RotateToSrc,
            uq3 = utilQ3RotateToSrc,
            position, rotation, ca = shared.cardinalAxes,
            axes, axisAwayNew, axisAwayToAwayNewDist, gravUp, gravDown, angleToNew, axisToNew, qToNew;

        // localize basics
        position = mesh.position;

        rotation = (mesh.useQuaternion === true ? mesh.quaternion : mesh.matrix);

        // if source is 3D object, cascade
        if (source instanceof THREE.Object3D) {

            source = source.position;

        }

        // default is world gravity source
        if (typeof source === 'undefined') {

            source = worldGravitySource;

        }

        axisAway = axisAway || ca.up;

        axisForward = axisForward || ca.forward;

        lerpDelta = lerpDelta || 1;

        // get normalized vector pointing from source to mesh
        axisAwayNew = uv31.sub(position, source).normalize();

        // get new rotation based on vector
        // find dist between current axis away and new axis away
        axisAwayToAwayNewDist = Math.max(-1, Math.min(1, axisAway.dot(axisAwayNew)));

        // if up axes are not same
        if (axisAwayToAwayNewDist !== 1) {

            // axis / angle
            angleToNew = Math.acos(axisAwayToAwayNewDist);
            axisToNew = uv32.cross(axisAway, axisAwayNew);
            axisToNew.normalize();

            // if new axis is exactly opposite of current
            // replace new axis with the forward axis
            if (axisToNew.length() === 0) {

                axisToNew = axisForward;

            }

            // rotation change
            qToNew = uq3.setFromAxisAngle(axisToNew, angleToNew);

            // add to rotation
            if (mesh.useQuaternion === true) {

                // quaternion rotations
                uq1.multiply(qToNew, rotation);

                // normalized lerp to new rotation
                THREE.Quaternion.nlerp(rotation, uq1, rotation, lerpDelta);

            } else {

                // matrix rotations
                uq1.setFromRotationMatrix(rotation);

                uq2.multiply(qToNew, uq1);

                rotation.setRotationFromQuaternion(uq2);

            }

            // if physics rigid body passed
            if (typeof rigidBody !== 'undefined') {

                /*
				quaternion = rigidBody.quaternion;
				
				uq1.multiply( qToNew, quaternion );
				
				THREE.Quaternion.nlerp( quaternion, uq1, quaternion, lerpDelta );
				*/
                // find new axes based on new rotation
                axes = rigidBody.axes;

                rotation.multiplyVector3(axes.up.copy(ca.up));

                rotation.multiplyVector3(axes.forward.copy(ca.forward));

                rotation.multiplyVector3(axes.right.copy(ca.right));

            }

        }

    }

    /*===================================================
    
    pull
    
    =====================================================*/

    function pull_to_source(mesh, source, objectsToIntersect, distanceFrom, velocity, rigidBody) {

        var i, l, position, difference = utilVec31Pull,
            direction = utilVec32Pull,
            shift = utilVec33Pull,
            object, rigidBody, colliders, intersection, intersectionDistance;

        // handle parameters
        position = mesh.position;

        // if source is 3D object, cascade
        if (source instanceof THREE.Object3D) {

            source = source.position;

        }

        // default is world gravity source
        if (typeof source === 'undefined') {

            source = worldGravitySource;

        }

        // get normalized vector from position to source
        difference.sub(source, position);

        direction.copy(difference).normalize();

        // if objects to intersect was passed
        if (main.is_array(objectsToIntersect)) {

            // extract colliders from objects
            colliders = [];

            for (i = 0, l = objectsToIntersect.length; i < l; i++) {

                object = objectsToIntersect[i];

                if (object instanceof THREE.Collider) {

                    colliders.push(object);

                } else if (typeof object.collider !== 'undefined') {

                    colliders.push(object.collider);

                } else if (typeof object.rigidBody !== 'undefined') {

                    colliders.push(object.rigidBody.collider);

                } else if (typeof object.physics !== 'undefined') {

                    colliders.push(object.physics.rigidBody.collider);

                }

            }

        }

        // cast ray from mesh to source
        intersection = raycast_in_direction(position, direction, undefined, undefined, colliders);

        // if intersection found
        if (typeof intersection !== 'undefined') {

            // get distance
            intersectionDistance = intersection.distance;

        } else {

            intersectionDistance = difference.length();

        }

        // if distance from needed
        if (main.is_number(distanceFrom)) {

            intersectionDistance -= distanceFrom;

        }

        // multiply direction by distance
        shift.copy(direction).multiplyScalar(intersectionDistance);

        // add shift to position
        position.addSelf(shift);

        /*
		
		var rigidBody = link.rigidBody,
			mesh = link.mesh,
			position = mesh.position,
			scale = mesh.scale,
			scaleExp = scaleSpeedExp,
			scaleModded = utilVec31Velocity.copy( scale ),
			velocityForce = velocity.force,
			velocityForceRotated = velocity.forceRotated,
			velocityForceRotatedLength,
			velocityForceScalar,
			velocityOffset = velocity.offset,
			velocityDamping = velocity.damping,
			relativeRotation = velocity.relativeRotation,
			boundingOffset,
			boundingOffsetLength,
			collision,
			collisionDist;
		
		if ( rigidBody.dynamic !== true || velocityForce.isZero() === true ) {
			
			velocity.moving = false;
			
			return;
			
		} 
		else {
			
			velocity.moving = true;
			
		}
		
		// if velocity is relative to rotation, else will just copy force into rotated
		
		velocityForceRotated = rotate_vector3_relative_to( relativeRotation, velocityForce, velocityForceRotated );
		
		//velocityForceRotated = rotate_vector3_to_mesh_rotation( mesh, velocityForce, velocityForceRotated );
		
		// scale velocity
		
		scaleModded.x = Math.pow( scaleModded.x, scaleExp );
		scaleModded.y = Math.pow( scaleModded.y, scaleExp );
		scaleModded.z = Math.pow( scaleModded.z, scaleExp );
		
		velocityForceRotated.multiplySelf( scaleModded );
		
		// get rotated length
		
		velocityForceRotatedLength = velocityForceRotated.length();
		
		// get bounding box offset
		
		boundingOffset = offset_from_dimensions_in_direction( mesh, velocityForceRotated, dimensions_from_collider_scaled( rigidBody, mesh ) );//_ObjectHelper.dimensions( mesh ) );
		
		boundingOffsetLength = boundingOffset.length();
		
		// override offset
		
		if ( typeof offset !== 'undefined' ) {
		
			velocityOffset = offset;
			
		}
		
		// rotate offset if needed
		
		if ( velocityOffset.length() > 0 ) {
			
			velocityOffset = rotate_vector3_to_mesh_rotation( mesh, velocityOffset );
			
		}
		
		var castDistance = boundingOffsetLength + velocityForceRotatedLength;
		
		// get collision
		
		collision = raycast_in_direction( link, velocityForceRotated, castDistance, velocityOffset );
		
		// modify velocity based on collision distances to avoid passing through or into objects
		
		if ( collision ) {
			
			collisionDist = collision.distance;
			
			// set the rotated velocity to be no more than collision distance
			
			if ( collisionDist - velocityForceRotatedLength <= boundingOffsetLength ) {
				
				velocityForceScalar = ( collisionDist - boundingOffsetLength ) / velocityForceRotatedLength;
				
				velocityForceRotated.multiplyScalar( velocityForceScalar );
				
				// set the base velocity to 0
				
				velocityForce.set( 0, 0, 0 );
				
				velocity.moving = false;
				
			}
			
		}
		
		// add velocity to position
		
		position.addSelf( velocityForceRotated );
		
		// damp velocity
		
		velocityForce.multiplySelf( velocityDamping );
		
		// return collision
		
		return collision;
		*/

    }

    /*===================================================
    
    start/stop/update functions
    
    =====================================================*/

    function start() {

        shared.signals.update.add(update);

    }

    function stop() {

        shared.signals.update.remove(update);

    }

    function update(timeDelta, timeDeltaMod) {

        var i, l, lerpDelta = 0.1,
            link, rigidBody, mesh, gravSrc = utilVec31Update,
            gravMag = utilVec32Update,
            gravUp = utilVec33Update,
            velocityGravity, velocityGravityForceUpDir = utilVec34Update,
            velocityGravityForceUpDirRot = utilVec35Update,
            velocityMovement, safetynet;

        // handle rotation and check velocity
        for (i = 0, l = links.length; i < l; i++) {

            link = links[i];

            mesh = link.mesh;

            rigidBody = link.rigidBody;

            safetynet = link.safetynet;

            // is dynamic
            if (rigidBody.dynamic === true) {

                // localize dynamic basics
                velocityGravity = rigidBody.velocityGravity;

                velocityMovement = rigidBody.velocityMovement;

                gravSrc.copy(rigidBody.gravSrc || worldGravitySource);

                gravMag.copy(rigidBody.gravMag || worldGravityMagnitude).multiplyScalar(timeDeltaMod);

                // rotate to stand on source
                rotate_relative_to_source(mesh, gravSrc, rigidBody.axes.up, rigidBody.axes.forward, lerpDelta, rigidBody);

                // movement velocity
                handle_velocity(link, velocityMovement);

                // find up direction
                gravUp.sub(mesh.position, gravSrc).normalize();

                // add non rotated gravity to gravity velocity
                velocityGravity.force.addSelf(gravMag);

                velocityGravity.relativeRotation = gravUp;

                velocityGravityForceUpDir.copy(velocityGravity.force).negate().normalize();

                velocityGravityForceUpDirRot = rotate_vector3_relative_to(velocityGravity.relativeRotation, velocityGravityForceUpDir, velocityGravityForceUpDirRot);

                // gravity velocity
                handle_velocity(link, velocityGravity);

                // post physics
                // if link is not safe
                if (link.safe === false) {

                    // rescue link and set back to last safe
                    mesh.position.copy(safetynet.position);

                    if (mesh.useQuaternion === true) {

                        mesh.quaternion.copy(safetynet.quaternion);

                    } else {

                        mesh.matrix.setRotationFromQuaternion(safetynet.quaternion);

                    }

                    velocityGravity.force.set(0, 0, 0);
                    velocityMovement.force.set(0, 0, 0);

                    velocityGravity.timeWithoutIntersection = 0;

                    link.safe = true;

                    // safety net end
                    link.safetynetend.dispatch();

                    shared.signals.physicssafetynetend.dispatch(link);

                }
                // if velocity gravity force is moving towards source
                else if (velocityGravityForceUpDirRot.equals(gravUp)) {

                    // if no intersection
                    if (!velocityGravity.intersection) {

                        velocityGravity.timeWithoutIntersection += timeDelta;

                        // without intersection for time above threshold
                        if (velocityGravity.timeWithoutIntersection > _Physics.timeWithoutIntersectionThreshold) {

                            // set link to unsafe, but do not reset to safe position immediately
                            // wait until next update to allow dispatched signals to be handled first
                            link.safe = false;

                            // safety net start
                            if (link.safetynetstart) {

                                link.safetynetstart.dispatch();

                            }

                            shared.signals.physicssafetynetstart.dispatch(link);

                        }

                    }
                    // link is safe
                    else {

                        velocityGravity.timeWithoutIntersection = 0;

                        link.safe = true;

                        // copy last safe position and rotation into rigidBody
                        safetynet.position.copy(mesh.position);

                        if (mesh.useQuaternion === true) {

                            safetynet.quaternion.copy(mesh.quaternion);

                        } else {

                            safetynet.quaternion.setFromRotationMatrix(mesh.matrix);

                        }

                    }

                }

            }

        }

    }

    /*===================================================
    
    velocity functions
    
    =====================================================*/

    function handle_velocity(link, velocity) {

        var rigidBody = link.rigidBody,
            mesh = link.mesh,
            position = mesh.position,
            scale = mesh.scale,
            scaleExp = scaleSpeedExp,
            scaleModded = utilVec31Velocity.copy(scale),
            velocityForce = velocity.force,
            velocityForceRotated = velocity.forceRotated,
            velocityForceRotatedLength, velocityForceScalar, velocityOffset = velocity.offset,
            velocityDamping = velocity.damping,
            relativeRotation = velocity.relativeRotation,
            boundingOffset, boundingOffsetLength, intersection, intersectionDist;

        if (rigidBody.dynamic !== true || velocityForce.isZero() === true) {

            velocity.moving = false;

            return;

        } else {

            velocity.moving = true;

        }

        // if velocity is relative to rotation, else will just copy force into rotated
        velocityForceRotated = rotate_vector3_relative_to(relativeRotation, velocityForce, velocityForceRotated);

        // scale velocity
        scaleModded.x = Math.pow(scaleModded.x, scaleExp);
        scaleModded.y = Math.pow(scaleModded.y, scaleExp);
        scaleModded.z = Math.pow(scaleModded.z, scaleExp);

        velocityForceRotated.multiplySelf(scaleModded);

        // get rotated length
        velocityForceRotatedLength = velocityForceRotated.length();

        // get bounding box offset
        boundingOffset = offset_from_dimensions_in_direction(mesh, velocityForceRotated, dimensions_from_collider_scaled(rigidBody, mesh)); //_ObjectHelper.dimensions( mesh ) );
        boundingOffsetLength = boundingOffset.length();

        // rotate offset if needed
        if (velocityOffset.length() > 0) {

            velocityOffset = rotate_vector3_to_mesh_rotation(mesh, velocityOffset);

        }

        // get intersection
        intersection = raycast_in_direction(position, velocityForceRotated, velocityOffset, mesh);

        // modify velocity based on intersection distances to avoid passing through or into objects
        if (intersection) {

            velocity.intersection = intersection;

            intersectionDist = intersection.distance;

            // set the rotated velocity to be no more than intersection distance
            if (intersectionDist - velocityForceRotatedLength <= boundingOffsetLength) {

                velocityForceScalar = (intersectionDist - boundingOffsetLength) / velocityForceRotatedLength;

                velocityForceRotated.multiplyScalar(velocityForceScalar);

                // set the base velocity to 0
                velocityForce.set(0, 0, 0);

                velocity.moving = false;

                velocity.collision = intersection;

            }

        } else {

            velocity.intersection = false;
            velocity.collision = false;

        }

        // add velocity to position
        position.addSelf(velocityForceRotated);

        // damp velocity
        velocityForce.multiplySelf(velocityDamping);

        // if velocity low enough, set zero
        if (velocityForce.length() < 0.01) {
            velocityForce.multiplyScalar(0);
        }

        // return intersection
        return intersection;
    }

    /*===================================================
    
    raycast functions
    
    =====================================================*/

    function raycast_in_direction(origin, direction, offset, mesh, colliders) {

        var i, l, ray = utilRay1Casting,
            intersections = [],
            intersectionPotential, intersectionMeshRecast, intersectionDistance = Number.MAX_VALUE,
            intersection;

        // set ray
        ray.origin.copy(origin);
        ray.direction.copy(direction).normalize();

        // add offset if passed
        if (typeof offset !== 'undefined') {

            ray.origin.addSelf(offset);

        }

        // ray cast colliders, defaults to all in system
        intersections = system.rayCastAll(ray, colliders);

        // find nearest intersection
        if (typeof intersections !== 'undefined') {

            for (i = 0, l = intersections.length; i < l; i++) {

                intersectionPotential = intersections[i];

                // if is collider for this object, skip
                if (intersectionPotential.mesh === mesh) {

                    continue;

                }

                // cast ray again if collider is mesh
                // initial ray cast was to mesh collider's dynamic box
                if (intersectionPotential instanceof THREE.MeshCollider) {

                    intersectionMeshRecast = system.rayMesh(ray, intersectionPotential);

                    if (intersectionMeshRecast.dist < Number.MAX_VALUE) {
                        intersectionPotential.distance = intersectionMeshRecast.dist;
                        intersectionPotential.faceIndex = intersectionMeshRecast.faceIndex;
                    } else {
                        intersectionPotential.distance = Number.MAX_VALUE;
                    }

                }

                // if distance is less than last ( last starts at number max value )
                // store as intersection
                if (intersectionPotential.distance < intersectionDistance) {

                    intersectionDistance = intersectionPotential.distance;
                    intersection = intersectionPotential;

                }

            }

        }

        return intersection;

    }

}(KAIOPUA));

/*
 *
 * CameraControls.js
 * Adds additional functionality to basic camera.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/core/CameraControls.js",
        _CameraControls = {},
        _ObjectHelper, _MathHelper, firstPersonDist = 50,
        rotateRecordedThreshold = 4,
        utilVec31Update, utilVec32Update, utilVec33Update, utilQ31Update, utilQ32Update;

    /*===================================================
    
    public properties
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _CameraControls,
        requirements: ["assets/modules/utils/ObjectHelper.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
	internal init
    
    =====================================================*/

    function init_internal(oh, mh) {
        console.log('internal cameracontrols');
        // assets
        _ObjectHelper = oh;
        _MathHelper = mh;

        // utility
        utilVec31Update = new THREE.Vector3();
        utilVec32Update = new THREE.Vector3();
        utilVec33Update = new THREE.Vector3();
        utilQ31Update = new THREE.Quaternion();
        utilQ32Update = new THREE.Quaternion();

        // instance
        _CameraControls.Instance = CameraControls;
        _CameraControls.Instance.prototype.rotate = rotate;
        _CameraControls.Instance.prototype.rotate_update = rotate_update;
        _CameraControls.Instance.prototype.zoom = zoom;
        _CameraControls.Instance.prototype.update = update;

        Object.defineProperty(_CameraControls.Instance.prototype, 'camera', {
            get: function () {
                return this._camera;
            },
            set: function (newCamera) {

                if (typeof newCamera !== 'undefined') {

                    this._camera = newCamera;

                    this.camera.useQuaternion = true;
                    this.camera.quaternion.setFromRotationMatrix(this.camera.matrix);

                }

            }
        });

        Object.defineProperty(_CameraControls.Instance.prototype, 'player', {
            get: function () {
                return this._player;
            },
            set: function (newPlayer) {

                if (typeof newPlayer !== 'undefined') {

                    this._player = newPlayer;

                }

            }
        });

    }

    /*===================================================
    
	external init
    
    =====================================================*/

    function CameraControls(player, camera) {

        var pRot, pPos;

        // camera
        this.camera = camera;

        // player
        this.player = player;

        // controller settings
        this.settingsRotation = pRot = new PropertySettings();
        this.settingsPosition = pPos = new PropertySettings();

        pRot.base.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
        pRot.offsetBase.set(25, 0, 0);
        pRot.offset.copy(pRot.offsetBase);
        pRot.offsetMin.set(-75, -360, 0);
        pRot.offsetMax.set(75, 360, 0);
        pRot.deltaMin.set(-40, -40, -40);
        pRot.deltaMax.set(40, 40, 40);
        pRot.deltaSpeedMax = pRot.deltaSpeedMin = 0.1;
        pRot.baseRevertSpeed = 0.05;

        pPos.offsetBase.set(0, 50, 300);
        pPos.offset.copy(pPos.offsetBase);
        pPos.offsetMin.set(0, 0, -25);
        pPos.offsetMax.set(0, 50, 1200);
        pPos.offsetSnap.copy(pPos.offset);
        pPos.offsetSnapToMinDist.set(0, 0, firstPersonDist);
        pPos.deltaMin.set(-80, -80, -80);
        pPos.deltaMax.set(80, 80, 80);
        pPos.deltaSpeedMin = 0.1;
        pPos.deltaSpeedMax = 0.3;
        pPos.deltaDecay = 0.7;

        // misc
        this.firstPerson = false;
        this.rotatedRecently = false;

    }

    /*===================================================
    
    property settings
    
    =====================================================*/

    function PropertySettings() {

        this.base = new THREE.Quaternion();
        this.baseRevertSpeed = 1;
        this.offsetBase = new THREE.Vector3();
        this.offsetSnap = new THREE.Vector3();
        this.offset = new THREE.Vector3();
        this.offsetMin = new THREE.Vector3();
        this.offsetMax = new THREE.Vector3();
        this.offsetSnapToMinDist = new THREE.Vector3();
        this.offsetSnapToMaxDist = new THREE.Vector3();
        this.delta = new THREE.Vector3();
        this.deltaMin = new THREE.Vector3();
        this.deltaMax = new THREE.Vector3();
        this.deltaTotal = new THREE.Vector3();
        this.deltaSpeedMin = 0;
        this.deltaSpeedMax = 0;
        this.deltaDecay = 0.8;

    }

    /*===================================================
	
	rotate
	
	=====================================================*/

    function rotate(e, end) {

        var rotated = false,
            mouse;

        // end rotation
        if (end === true) {

            // if rotated
            rotated = this.rotatedRecently;

            // reset
            shared.signals.mousemoved.remove(rotate_update, this);

            this.settingsRotation.mouse = undefined;

            this.rotatedRecently = false;

        }
        // start rotation
        else {

            // store mouse
            this.settingsRotation.mouse = main.get_mouse((e ? e.identifier : 0));

            // reset properties
            this.settingsRotation.deltaTotal.set(0, 0, 0);
            this.settingsRotation.delta.set(0, 0, 0);
            this.rotatedRecently = false;

            // update
            shared.signals.mousemoved.add(rotate_update, this);

        }

        return rotated;

    }

    function rotate_update() {

        var pRot = this.settingsRotation,
            rotDelta = pRot.delta,
            rotDeltaMin = pRot.deltaMin,
            rotDeltaMax = pRot.deltaMax,
            rotDeltaSpeed = pRot.deltaSpeedMin,
            rotDeltaTotal = pRot.deltaTotal,
            rotDeltaX, rotDeltaY, mouse = pRot.mouse;

        // pitch
        rotDelta.x = _MathHelper.clamp(rotDelta.x + mouse.dy * rotDeltaSpeed, rotDeltaMin.x, rotDeltaMax.x);

        // yaw
        rotDelta.y = _MathHelper.clamp(rotDelta.y - mouse.dx * rotDeltaSpeed, rotDeltaMin.y, rotDeltaMax.y);

        // if totals above start threshold
        if (this.rotatedRecently !== true) {

            rotDeltaTotal.addSelf(rotDelta);

            if (rotDeltaTotal.length() > rotateRecordedThreshold) {

                this.rotatedRecently = true;

            }

        }

    }

    /*===================================================
	
	zoom
	
	=====================================================*/

    function zoom(e) {

        var eo = e.originalEvent || e,
            wheelDelta = eo.wheelDelta,
            pPos = this.settingsPosition,
            posOffset = pPos.offset,
            posOffsetMin = pPos.offsetMin,
            posOffsetMax = pPos.offsetMax,
            posDelta = pPos.delta,
            posDeltaMin = pPos.deltaMin,
            posDeltaMax = pPos.deltaMax,
            posDeltaSpeed, posOffsetZMinMaxDist = posOffsetMax.z - posOffsetMin.z,
            posOffsetPctToMin = (posOffset.z - posOffsetMin.z) / posOffsetZMinMaxDist;

        posDeltaSpeed = pPos.deltaSpeedMin * (1 - posOffsetPctToMin) + pPos.deltaSpeedMax * posOffsetPctToMin;

        posDelta.z = _MathHelper.clamp(posDelta.z - wheelDelta * posDeltaSpeed, posDeltaMin.z, posDeltaMax.z);

    }

    /*===================================================
	
	update
	
	=====================================================*/

    function update(timeDelta) {

        var pRot = this.settingsRotation,
            pPos = this.settingsPosition,
            posOffset = pPos.offset,
            posOffsetMin = pPos.offsetMin,
            posOffsetMax = pPos.offsetMax,
            posOffsetSnap = pPos.offsetSnap,
            posOffsetSnapToMinDist = pPos.offsetSnapToMinDist,
            posDelta = pPos.delta,
            posDeltaDecay = pRot.deltaDecay,
            rotBase = pRot.base,
            rotBaseRevertSpeed = pRot.baseRevertSpeed,
            rotOffsetBase = pRot.offsetBase,
            rotOffset = pRot.offset,
            rotOffsetMin = pRot.offsetMin,
            rotOffsetMax = pRot.offsetMax,
            rotDelta = pRot.delta,
            rotDeltaDecay = pRot.deltaDecay,
            player = this.player,
            pc = player.character,
            cardinalAxes = shared.cardinalAxes,
            caForward = cardinalAxes.forward,
            caUp = cardinalAxes.up,
            rotOffsetQ, rotOffsetAxis, pcRotToRotOffsetDist, pcRotToRotOffsetAngle, pcRotToRotOffsetAxis, pcRotToRotOffsetQ;

        // add delta to offset
        // snap to min when within snapping dist
        if (posDelta.z > 0 && posOffset.z === posOffsetMin.z) {

            posOffsetSnap.z = posOffsetMin.z + posOffsetSnapToMinDist.z;

        }

        posOffset.z = posOffsetSnap.z = _MathHelper.clamp(posOffsetSnap.z + posDelta.z, posOffsetMin.z, posOffsetMax.z);

        if (posOffsetSnap.z - posOffsetSnapToMinDist.z <= posOffsetMin.z) {

            posOffset.z = posOffsetMin.z;

        }

        rotOffset.x = _MathHelper.clamp(rotOffset.x + rotDelta.x, rotOffsetMin.x, rotOffsetMax.x);
        rotOffset.y = _MathHelper.clamp(rotOffset.y + rotDelta.y, rotOffsetMin.y, rotOffsetMax.y);

        // normalize rotation (between 180 and -180)
        if (rotOffset.x > 180) {
            rotOffset.x -= 360;
        } else if (rotOffset.x < -180) {
            rotOffset.x += 360;
        }
        if (rotOffset.y > 180) {
            rotOffset.y -= 360;
        } else if (rotOffset.y < -180) {
            rotOffset.y += 360;
        }

        // check if should switch between third and first
        if (posOffset.z - firstPersonDist <= posOffsetMin.z) {

            if (this.firstPerson !== true && rotOffset.y !== 0) {

                // get axis and angle between rot offset y rotation and forward
                rotOffsetQ = utilQ31Update.setFromAxisAngle(utilVec31Update.copy(caUp), rotOffset.y * Math.PI / 180);

                rotOffsetAxis = utilVec32Update.copy(caForward);

                rotOffsetQ.multiplyVector3(rotOffsetAxis);

                pcRotToRotOffsetDist = Math.max(-1, Math.min(1, caForward.dot(rotOffsetAxis)));

                // axis / angle
                pcRotToRotOffsetAngle = Math.acos(pcRotToRotOffsetDist);
                pcRotToRotOffsetAxis = utilVec33Update.cross(caForward, rotOffsetAxis);
                pcRotToRotOffsetAxis.normalize();

                // rotation change
                pcRotToRotOffsetQ = utilQ32Update.setFromAxisAngle(pcRotToRotOffsetAxis, pcRotToRotOffsetAngle);

                // update player rotation y
                pc.rotate_by_delta(pcRotToRotOffsetQ.x, pcRotToRotOffsetQ.y, pcRotToRotOffsetQ.z, pcRotToRotOffsetQ.w);

                // reset rot offset
                rotOffset.y = 0;

            }

            this.firstPerson = true;

        } else {

            this.firstPerson = false;

        }

        // if in first person mode
        // rotate character on y axis with camera
        if (this.firstPerson === true) {

            // update player rotation y
            pc.rotate_by_delta(0, rotDelta.y / 180, 0, 1);

            // remove rot delta from offset
            // as will be copied when camera follows player
            rotOffset.y -= rotDelta.y;

        }
        // if player is not in first person and moving but not rotating camera
        // move rotation offset back towards original
        else if (typeof pRot.mouse === 'undefined' && player.moving === true) {

            if (rotOffset.x !== rotOffsetBase.x) rotOffset.x += (rotOffsetBase.x - rotOffset.x) * rotBaseRevertSpeed;
            if (rotOffset.y !== rotOffsetBase.y) rotOffset.y += (rotOffsetBase.y - rotOffset.y) * rotBaseRevertSpeed;

        }

        // follow player
        _ObjectHelper.object_follow_object(this.camera, pc, rotBase, rotOffset, posOffset);

        // decay deltas
        posDelta.multiplyScalar(posDeltaDecay);

        rotDelta.multiplyScalar(rotDeltaDecay);

    }

}(KAIOPUA));

/*
 *
 * Player.js
 * Centralizes all player related functionality.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/core/Player.js",
        _Player = {},
        _Game, _CameraControls, _Hero, _Physics, _World, _Messenger, _ObjectHelper, _MathHelper, ready = false,
        enabled = false,
        showing = false,
        cameraControls, actionsMap, keybindings, keybindingsDefault, character, characterLight, following = [],
        selecting;

    /*===================================================
    
    public properties
    
    =====================================================*/

    _Player.enable = enable;
    _Player.disable = disable;
    _Player.show = show;
    _Player.hide = hide;
    _Player.allow_control = allow_control;
    _Player.remove_control = remove_control;
    _Player.select_from_mouse_position = select_from_mouse_position;
    _Player.deselect = deselect;

    // getters and setters
    Object.defineProperty(_Player, 'enabled', {
        get: function () {
            return enabled;
        },
        set: function (val) {
            if (val === true) {
                enable();
            } else {
                disable();
            }
        }
    });

    Object.defineProperty(_Player, 'camera', {
        get: function () {
            return cameraControls.camera;
        }
    });

    Object.defineProperty(_Player, 'character', {
        get: function () {
            return character;
        }
    });

    Object.defineProperty(_Player, 'scene', {
        get: function () {
            return character.scene;
        }
    });

    Object.defineProperty(_Player, 'moving', {
        get: function () {
            return character.movement.state.moving;
        }
    });

    main.asset_register(assetPath, {
        data: _Player,
        requirements: ["assets/modules/core/Game.js", "assets/modules/core/CameraControls.js", "assets/modules/characters/Hero.js", "assets/modules/core/Physics.js", "assets/modules/env/World.js", "assets/modules/ui/Messenger.js", "assets/modules/utils/ObjectHelper.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    external init
    
    =====================================================*/

    function init_internal(g, cc, h, physx, w, msg, oh, mh) {
        console.log('internal player');

        if (ready !== true) {

            // assets
            _Game = g;
            _CameraControls = cc;
            _Hero = h;
            _Physics = physx;
            _World = w;
            _Messenger = msg;
            _ObjectHelper = oh;
            _MathHelper = mh;

            // selecting
            selecting = {};

            selecting.opacityMin = 0.2;
            selecting.opacityMax = 0.6;
            selecting.opacityStart = selecting.opacityMin;
            selecting.opacityTarget = selecting.opacityMax;
            selecting.opacityCycleTime = 0;
            selecting.opacityCycleTimeMax = 500;

            selecting.material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: selecting.opacityStart,
                blending: THREE.AdditiveAlphaBlending
            });

            // initialization
            init_cameracontrols();

            init_character();

            init_keybindings();

            init_controls();

            // signals
            shared.signals.paused.add(pause);

            ready = true;

        }

    }

    /*===================================================
    
    camera
    
    =====================================================*/

    function init_cameracontrols() {

        cameraControls = new _CameraControls.Instance(_Player, _Game.camera);

    }

    /*===================================================
    
    character
    
    =====================================================*/

    function init_character() {

        // create character
        character = new _Hero.Instance();

        // init light to follow character
        characterLight = new THREE.PointLight(0xfeb41c, 0.8, 400);

        characterLight.position.set(-20, 25, 60);

        character.add(characterLight);

        // add handler for physics safety net
        if (character.physics) {

            character.physics.safetynetstart.add(character_on_safety_net, this);

        }

    }

    function character_on_safety_net() {

        _Messenger.show_message({
            image: shared.pathToIcons + 'alertcircle_64.png',
            title: "Well, this is embarrassing!",
            body: "Our physics broke, but we'll do our best to drop you off at your last safe location.",
            active: true,
            transitionerOpacity: 1
        });

    }

    function character_move(movementTypeName, stop) {

        character.move_state_change(movementTypeName, stop);

    }

    /*===================================================
    
    keybindings
    
    =====================================================*/

    function init_keybindings() {

        var map = keybindingsDefault = {};

        // default keybindings
        // mouse buttons
        map['mouseleft'] = {
            keydown: function (e) {

                // modify character action if started
                character.action('001', {
                    event: e,
                    stop: !enabled
                });

                // start rotating camera if character is not acting
                if (character.get_is_performing_action('001') !== true) {

                    cameraControls.rotate(e);

                }

            },
            keyup: function (e) {

                // stop camera rotate
                var rotated = cameraControls.rotate(e, true);

                // start character action if camera was not just rotated
                if (rotated !== true) {

                    character.action('002', {
                        event: e,
                        stop: !enabled
                    });

                }

            }
        };
        map['mousemiddle'] = {
            keydown: function (e) {
                console.log('key down: mousemiddle');
            },
            keyup: function (e) {
                console.log('key up: mousemiddle');
            }
        };
        map['mouseright'] = {
            keydown: function (e) {
                cameraControls.rotate(e);
            },
            keyup: function (e) {

                // stop camera rotate
                var rotated = cameraControls.rotate(e, true);

                // stop character action if camera was not just rotated
                if (rotated !== true) {

                    character.action('001', {
                        event: e,
                        stop: true
                    });
                    character.action('002', {
                        event: e,
                        stop: true
                    });

                }
            }
        };
        map['mousewheel'] = {
            keyup: function (e) {
                cameraControls.zoom(e);
            }
        };

        // wasd / uldr
        map['38' /*up*/ ] = map['87' /*w*/ ] = map['w'] = {
            keydown: function () {
                character_move('forward');
            },
            keyup: function () {
                character_move('forward', true);
            }
        };

        map['40' /*down*/ ] = map['83' /*s*/ ] = map['s'] = {
            keydown: function () {
                character_move('back');
            },
            keyup: function () {
                character_move('back', true);
            }
        };

        map['37' /*left*/ ] = map['65' /*a*/ ] = map['a'] = {
            keydown: function () {
                character_move('turnleft');
            },
            keyup: function () {
                character_move('turnleft', true);
            }
        };

        map['39' /*right*/ ] = map['68' /*d*/ ] = map['d'] = {
            keydown: function () {
                character_move('turnright');
            },
            keyup: function () {
                character_move('turnright', true);
            }
        };

        // qe
        map['81' /*q*/ ] = map['q'] = {
            keyup: function () {
                console.log('key up: q');
            }
        };

        map['69' /*e*/ ] = map['e'] = {
            keyup: function () {
                console.log('key up: e');
            }
        };

        // numbers
        map['49' /*1*/ ] = map['1'] = {
            keyup: function () {
                console.log('key up: 1');
            }
        };
        map['50' /*2*/ ] = map['2'] = {
            keyup: function () {
                console.log('key up: 2');
            }
        };
        map['51' /*3*/ ] = map['3'] = {
            keyup: function () {
                console.log('key up: 3');
            }
        };
        map['52' /*4*/ ] = map['4'] = {
            keyup: function () {
                console.log('key up: 4');
            }
        };
        map['53' /*5*/ ] = map['5'] = {
            keyup: function () {
                console.log('key up: 5');
            }
        };
        map['54' /*6*/ ] = map['6'] = {
            keyup: function () {
                console.log('key up: 6');
            }
        };

        // misc
        map['27' /*escape*/ ] = {
            keyup: function () {

                if (_Game.paused === true) {
                    _Game.resume();
                } else {
                    _Game.pause();
                }

            }
        };

        map['32' /*space*/ ] = {
            keydown: function () {
                character_move('up');
            },
            keyup: function () {
                character_move('up', true);
            }
        };

        map['82' /*r*/ ] = map['r'] = {
            keydown: function () {
                console.log('key down: r');
            },
            keyup: function () {
                console.log('key up: r');
            }
        };

        map['70' /*f*/ ] = map['f'] = {
            keyup: function () {
                console.log('key up: f');
            }
        };

        // set list of keys that are always available
        map.alwaysAvailable = ['27'];

        // set default as current
        set_keybindings(map);

    }

    function set_keybindings(map) {

        var key;

        // reset keybindings
        keybindings = {};

        // set all new keybindings in map
        for (key in map) {

            if (map.hasOwnProperty(key) === true) {

                keybindings[key] = map[key];

            }

        }

    }

    /*===================================================
    
    controls
    
    =====================================================*/

    function init_controls() {



    }

    function allow_control() {

        // signals
        shared.signals.mousedown.add(on_mouse_pressed);
        shared.signals.mouseup.add(on_mouse_pressed);
        shared.signals.mousewheel.add(on_mouse_pressed);

        shared.signals.keydown.add(on_keyboard_used);
        shared.signals.keyup.add(on_keyboard_used);

    }

    function remove_control() {

        // clear keys
        clear_keys_active();

        // signals
        shared.signals.mousedown.remove(on_mouse_pressed);
        shared.signals.mouseup.remove(on_mouse_pressed);
        shared.signals.mousewheel.remove(on_mouse_pressed);

        shared.signals.keydown.remove(on_keyboard_used);
        shared.signals.keyup.remove(on_keyboard_used);

    }

    function on_mouse_pressed(e) {

        var i, l, button, type, arguments = [];

        if (e && _Game.is_event_in_game(e) === true) {

            // handle button
            switch (e.button) {

            case 2:
                button = 'mouseright';
                break;
            case 1:
                button = 'mousemiddle';
                break;
            case 0:
                button = 'mouseleft';
                break;

            }

            // handle type
            switch (e.type) {

            case 'mousedown':
            case 'touchstart':
                type = 'keydown';
                break;
            case 'mouseup':
            case 'touchend':
                type = 'keyup';
                break;
            case 'mousewheel':
                button = 'mousewheel';
                type = 'keyup';
                break;

            }

            trigger_key(button, type, e);

        }

    }

    function on_keyboard_used(e) {

        trigger_key((e.key || e.keyCode).toString().toLowerCase(), e.type);

    }

    function trigger_key(keyName, eventType, parameters) {

        var kbMap = keybindings,
            kbInfo;

        // trigger by name
        if (kbMap.hasOwnProperty(keyName) === true && (enabled === true || kbMap.alwaysAvailable.indexOf(keyName) !== -1)) {

            kbInfo = kbMap[keyName];

            if (kbInfo.hasOwnProperty(eventType) === true) {

                if (eventType === 'keydown') {

                    kbInfo.active = true;

                } else {

                    kbInfo.active = false;

                }

                // check arguments
                parameters = main.ensure_array(parameters);

                kbInfo[eventType].apply(this, parameters);

            }

        }

    }

    function clear_keys_active() {

        var keyName, kbInfo;

        for (keyName in keybindings) {

            kbInfo = keybindings[keyName];

            if (kbInfo.active === true) {

                trigger_key(keyName, 'keyup');

            }

        }

    }

    /*===================================================
    
    selection functions
    
    =====================================================*/

    function select_from_mouse_position(parameters) {

        var selectedMesh, selectedModel, targetsNum = 0,
            targetsNumMax, character, targeting, targets, targetsToRemove, materialIndex;

        // handle parameters
        parameters = parameters || {};

        mouse = parameters.mouse = parameters.mouse || main.get_mouse(parameters);

        character = parameters.character || character;

        targetsNumMax = parameters.targetsNumMax || 1;

        targeting = character.targeting;

        targets = targeting.targets;

        targetsToRemove = targeting.targetsToRemove;

        // select
        selectedModel = object_under_mouse(mouse);

        // if a selection was made
        if (typeof selectedModel !== 'undefined' && selectedModel.targetable === true) {

            // todo
            // special selection cases
            // add selected to character targets
            // unless already selected, then add to removal list
            if (targets.indexOf(selectedModel) === -1) {

                // check current length of targets
                // if at or over max num targets, remove earliest
                if (targets.length >= targetsNumMax) {

                    targetsToRemove.push(targets[0]);

                    deselect(parameters);

                }

                targets.push(selectedModel);
                /*
				 * TODO: fix for single material case
				selectedMesh = selectedModel.mesh;
				
				materialIndex = selectedMesh.materials.indexOf( selecting.material );
				
				if ( materialIndex === -1 ) {
					
					selectedMesh.materials.push( selecting.material );
					
				}
				*/
            } else {

                targetsToRemove.push(selectedModel);

            }

            // update num targets
            targetsNum = targets.length;

            // set selected as current selection
            targeting.targetCurrent = selectedModel;

        }
        // else deselect all
        else {

            if (targets.length > 0) {

                targeting.targetsToRemove = targetsToRemove.concat(targets);

                deselect(parameters);

            }

        }

        return targetsNum;
    }

    function deselect(parameters) {

        var i, l, character, targeting, targets, targetsToRemove, targetIndex, targetModel, targetMesh, materialIndex;

        // handle parameters
        parameters = parameters || {};

        character = parameters.character || character;

        targeting = character.targeting;

        targets = targeting.targets;

        targetsToRemove = targeting.targetsToRemove;

        // for each target to remove
        for (i = targetsToRemove.length - 1, l = 0; i >= l; i -= 1) {

            targetModel = targetsToRemove[i];

            targetMesh = targetModel; //.mesh;
            // find in targets and remove
            targetIndex = targets.indexOf(targetModel);

            if (targetIndex !== -1) {

                targets.splice(targetIndex, 1);

            }

            /* TODO: fix for no multimaterials
			// remove selecting material
			
			materialIndex = targetMesh.materials.indexOf( selecting.material );
			
			if ( materialIndex !== -1 ) {
				
				targetMesh.materials.splice( materialIndex, 1 );
				
			}
			*/

            // remove from targetsToRemove
            targetsToRemove.splice(i, 1);

        }

    }

    function update_selections(timeDelta) {

        var material = selecting.material,
            opacityMax = selecting.opacityMax,
            opacityMin = selecting.opacityMin,
            opacityStart = selecting.opacityStart,
            opacityTarget = selecting.opacityTarget,
            opacityTargetLast, opacityDelta = opacityTarget - opacityStart,
            opacityCycleTime, opacityCycleTimeMax = selecting.opacityCycleTimeMax;

        // update time
        selecting.opacityCycleTime += timeDelta;

        if (selecting.opacityCycleTime >= opacityCycleTimeMax) {

            material.opacity = opacityTarget;

            selecting.opacityCycleTime = 0;

            // update start and target
            opacityTargetLast = opacityTarget;

            selecting.opacityTarget = opacityStart;

            selecting.opacityStart = opacityTargetLast;

        } else {

            opacityCycleTime = selecting.opacityCycleTime;

            // quadratic easing
            opacityCycleTime /= opacityCycleTimeMax * 0.5;

            if (opacityCycleTime < 1) {

                material.opacity = opacityDelta * 0.5 * opacityCycleTime * opacityCycleTime + opacityStart;

            } else {

                opacityCycleTime--;

                material.opacity = -opacityDelta * 0.5 * (opacityCycleTime * (opacityCycleTime - 2) - 1) + opacityStart;

            }

        }

    }

    /*===================================================
    
    custom functions
    
    =====================================================*/

    function pause() {

        disable();

        shared.signals.resumed.add(resume);

    }

    function resume() {

        shared.signals.resumed.remove(resume);

        enable();

    }

    function enable() {

        if (_Game.started === true && enabled !== true) {

            enabled = true;

            shared.signals.update.add(update);

        }

    }

    function disable() {

        enabled = false;

        // clear keys
        clear_keys_active();

        // clear character actions
        character.stop_action();

        // pause updating
        shared.signals.update.remove(update);

    }

    function show() {

        if (showing === false) {

            character.show(_Game.scene);

            cameraControls.camera = _Game.camera;

            showing = true;

            allow_control();

        }

    }

    function hide() {

        if (showing === true) {

            remove_control();

            disable();

            character.hide();

            showing = false;

        }

    }

    function update(timeDelta, timeDeltaMod) {

        // character
        character.update(timeDelta, timeDeltaMod);

        // update camera
        cameraControls.update(timeDelta);

        // selection material
        update_selections(timeDelta);

    }

}(KAIOPUA));

/*
 *
 * Character.js
 * Adds additional functionality to basic model.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/characters/Character.js",
        _Character = {},
        _Model, _MathHelper, characterIDBase = 'kaiopua_character',
        utilQ1Rotate;

    /*===================================================
    
    public properties
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Character,
        requirements: ["assets/modules/core/Game.js", "assets/modules/core/Model.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(g, m, mh) {
        console.log('internal character', _Character);
        // modules
        _Game = g;
        _Model = m;
        _MathHelper = mh;

        // utility
        utilQ1Rotate = new THREE.Quaternion();

        // character instance
        _Character.Instance = Character;
        _Character.Instance.prototype = new _Model.Instance();
        _Character.Instance.prototype.constructor = _Character.Instance;
        _Character.Instance.prototype.move_state_change = move_state_change;
        _Character.Instance.prototype.rotate_by_delta = rotate_by_delta;
        _Character.Instance.prototype.morph_cycle = morph_cycle;
        _Character.Instance.prototype.action = action;
        _Character.Instance.prototype.add_action = add_action;
        _Character.Instance.prototype.stop_action = stop_action;
        _Character.Instance.prototype.get_is_performing_action = get_is_performing_action;
        _Character.Instance.prototype.show = show;
        _Character.Instance.prototype.hide = hide;
        _Character.Instance.prototype.update = update;
        _Character.Instance.prototype.update_followers = update_followers;

        Object.defineProperty(_Character.Instance.prototype, 'scene', {
            get: function () {
                return this._scene;
            },
            set: function (newScene) {

                if (typeof newScene !== 'undefined') {

                    // remove from previous
                    this.hide();

                    // add to new
                    this.show(newScene);

                }

            }
        });

    }

    /*===================================================
    
    character
    
    =====================================================*/

    // adds functionality to and inherits from Model
    function Character(parameters) {

        var me = this,
            parametersModel, parametersMovement, movement, move, rotate, jump, state;

        // handle parameters
        parameters = parameters || {};

        // model
        parametersModel = parameters.model || {};

        // physics
        if (typeof parametersModel.physics !== 'undefined') {

            parametersModel.physics.dynamic = true;
            parametersModel.physics.movementDamping = parametersModel.physics.movementDamping || 0.5;

        }

        // prototype constructor
        _Model.Instance.call(me, parametersModel);

        // movement
        parametersMovement = parameters.movement || {};

        movement = me.movement = {};

        // move
        move = movement.move = {};
        move.speed = parametersMovement.moveSpeed || 6;
        move.speedBack = parametersMovement.moveSpeedBack || move.speed;
        move.runThreshold = parametersMovement.moveRunThreshold || 0;
        move.walkAnimationTime = parametersMovement.moveWalkAnimationTime || 750;
        move.runAnimationTime = parametersMovement.moveRunAnimationTime || 500;
        move.idleAnimationTime = parametersMovement.moveIdleAnimationTime || 3000;
        move.morphClearTime = parametersMovement.moveCycleClearTime || 125;
        move.animationChangeTimeThreshold = parametersMovement.animationChangeTimeThreshold || 0;
        move.animationChangeTimeTotal = move.animationChangeTimeThreshold;
        move.direction = new THREE.Vector3();
        move.vector = new THREE.Vector3();

        // rotate
        rotate = me.movement.rotate = {};
        rotate.speed = parametersMovement.rotateSpeed || 0.015;
        rotate.direction = new THREE.Vector3();
        rotate.delta = new THREE.Quaternion();
        rotate.vector = new THREE.Quaternion();

        // jump
        jump = me.movement.jump = {};
        jump.speedStart = parametersMovement.jumpSpeedStart || 6;
        jump.speedEnd = parametersMovement.jumpSpeedEnd || 0;
        jump.timeTotal = 0;
        jump.timeMax = parametersMovement.jumpTimeMax || 50;
        jump.timeAfterNotGrounded = 0;
        jump.timeAfterNotGroundedMax = 125;
        jump.startDelay = parametersMovement.jumpStartDelay || 125;
        jump.startDelayTime = 0;
        jump.animationTime = parametersMovement.jumpAnimationTime || 1000;
        jump.startAnimationTime = parametersMovement.jumpStartAnimationTime || jump.startDelay;
        jump.endAnimationTime = parametersMovement.jumpEndAnimationTime || move.morphClearTime;
        jump.ready = true;
        jump.active = false;

        // state
        state = me.movement.state = {};
        state.up = 0;
        state.down = 0;
        state.left = 0;
        state.right = 0;
        state.forward = 0;
        state.back = 0;
        state.turnleft = 0;
        state.turnright = 0;
        state.grounded = false;
        state.groundedLast = false;
        state.moving = false;
        state.movingBack = false;
        state.moveType = '';

        // properties
        me.id = parameters.id || characterIDBase;

        me.actions = {};
        me.actionsNames = [];

        me.showing = false;

        me.followers = [];

        me.targeting = {

            targets: [],
            targetsToRemove: [],
            targetCurrent: undefined

        };

    }

    /*===================================================
	
	actions
	
	=====================================================*/

    function action(actionName, parameters) {

        var action;

        // if action type is in actions map, do it
        if (this.actions.hasOwnProperty(actionName)) {

            action = this.actions[actionName];

            if (typeof action.callback === 'function') {

                action.callback.call(action.context, parameters);

            }

        }

    }

    function add_action() {

        var i, l, j, k, parameters, actionsNames, actionName;

        for (i = 0, l = arguments.length; i < l; i++) {

            parameters = arguments[i];

            if (main.type(parameters) === 'object') {

                actionsNames = main.ensure_array(parameters.actionsNames);

                // for each action name
                for (j = 0, k = actionsNames.length; j < k; j++) {

                    actionName = actionsNames[j];

                    // add to actions map
                    this.actions[actionName] = {
                        callback: parameters.callback,
                        context: parameters.context || this,
                        activeCheck: parameters.activeCheck,
                        activeCheckContext: parameters.activeCheckContext || this
                    };

                    // store name
                    if (this.actionsNames.indexOf(actionName) === -1) {

                        this.actionsNames.push(actionName);

                    }

                }

            }

        }

    }

    function get_is_performing_action(actionsNames) {

        var i, l, actionName, action, acting = false;

        actionsNames = typeof actionsNames !== 'undefined' ? main.ensure_array(actionsNames) : this.actionsNames;

        for (i = 0, l = actionsNames.length; i < l; i++) {

            actionName = actionsNames[i];

            action = this.actions[actionName];

            if (typeof action.activeCheck === 'function' && action.activeCheck.call(action.activeCheckContext) === true) {

                acting = true;

                break;

            }

        }

        return acting;

    }

    function stop_action(actionsNames) {

        var i, l, actionName, action;

        // trigger stop for all actions that are active
        actionsNames = typeof actionsNames !== 'undefined' ? main.ensure_array(actionsNames) : this.actionsNames;

        for (i = 0, l = actionsNames.length; i < l; i++) {

            actionName = actionsNames[i];

            action = this.actions[actionName];

            if (typeof action.activeCheck === 'function' && action.activeCheck.call(action.activeCheckContext) === true) {

                this.action(actionName, {
                    stop: true
                });

            }

        }

    }

    /*===================================================
	
	move
	
	=====================================================*/

    function move_state_change(propertyName, stop) {

        var state = this.movement.state;

        // handle state property
        if (state.hasOwnProperty(propertyName)) {

            state[propertyName] = stop === true ? 0 : 1;

        }

    }

    /*===================================================
	
	rotate
	
	=====================================================*/

    function rotate_by_delta(dx, dy, dz, dw) {

        var q = this.quaternion,
            rotate = this.movement.rotate,
            rotateDelta = rotate.delta,
            rotateVec = rotate.vector,
            rotateUtilQ1 = utilQ1Rotate;

        rotateDelta.set(dx || 0, dy || 0, dz || 0, dw || 1).normalize();

        rotateVec.multiplySelf(rotateDelta);

        rotateUtilQ1.multiply(q, rotateDelta);

        q.copy(rotateUtilQ1);

    }

    /*===================================================
	
	morph cycling
	
	=====================================================*/

    function morph_cycle(timeDelta, cycleType, duration, loop, reverse) {

        var morphs = this.morphs,
            movement = this.movement,
            move = movement.move,
            state = movement.state;

        if (state.moveType !== cycleType) {

            if (move.animationChangeTimeTotal < move.animationChangeTimeThreshold) {

                move.animationChangeTimeTotal += timeDelta;

            } else {

                move.animationChangeTimeTotal = 0;

                morphs.clear(state.moveType, move.morphClearTime);

                state.moveType = cycleType;

            }

        }

        morphs.play(state.moveType, {
            duration: duration,
            loop: loop,
            reverse: reverse
        });

    }

    /*===================================================
	
	followers
	
	=====================================================*/

    function update_followers() {

        var i, l, followSettings;

        /*
		// example follow settings
		followSettings = {
			obj: model,
			rotationBase: new THREE.Quaternion(),
			rotationOffset: new THREE.Vector3( 0, 0, 0 ),
			positionOffset: new THREE.Vector3( 0, 0, 0 )
		};
		*/

        for (i = 0, l = this.followers.length; i < l; i++) {

            followSettings = this.followers[i];

            _ObjectHelper.object_follow_object(followSettings.obj, this, followSettings.rotationBase, followSettings.rotationOffset, followSettings.positionOffset);

        }

    }

    /*===================================================
	
	update
	
	=====================================================*/

    function update(timeDelta, timeDeltaMod) {

        var physics = this.physics,
            rigidBody = physics.rigidBody,
            morphs = this.morphs,
            movement = this.movement,
            move = movement.move,
            rotate = movement.rotate,
            jump = movement.jump,
            state = movement.state,
            rotateDir = rotate.direction,
            rotateDelta = rotate.delta,
            rotateSpeed = rotate.speed * timeDeltaMod,
            moveDir = move.direction,
            moveVec = move.vector,
            moveSpeed = move.speed * timeDeltaMod,
            moveSpeedBack = move.speedBack * timeDeltaMod,
            moveSpeedRatio = Math.min(1, (moveSpeedBack / moveSpeed) * 2),
            jumpSpeedStart, jumpSpeedEnd, jumpTimeTotal, jumpTimeMax, jumpTimeRatio, jumpTimeAfterNotGroundedMax, jumpStartDelay, velocityGravity, velocityGravityForce, velocityMovement, velocityMovementForce, velocityMovementForceLength, velocityMovementDamping, dragCoefficient, terminalVelocity, playSpeedModifier;

        // update vectors with state
        moveDir.x = (state.left - state.right);
        moveDir.z = (state.forward - state.back);

        rotateDir.y = (state.turnleft - state.turnright);

        // set moving
        if (state.forward === 1 || state.back === 1 || state.turnleft === 1 || state.turnright === 1 || state.up === 1 || state.down === 1 || state.left === 1 || state.right === 1) {

            state.moving = true;

        } else {

            state.moving = false;

        }

        // rotate self
        this.rotate_by_delta(rotateDir.x * rotateSpeed, rotateDir.y * rotateSpeed, rotateDir.z * rotateSpeed, 1);

        // velocity
        if (typeof rigidBody !== 'undefined') {

            // properties
            velocityMovement = rigidBody.velocityMovement;
            velocityMovementForce = velocityMovement.force;
            velocityGravity = rigidBody.velocityGravity;
            velocityGravityForce = velocityGravity.force;

            jumpTimeTotal = jump.timeTotal;
            jumpTimeMax = jump.timeMax;
            jumpTimeAfterNotGroundedMax = jump.timeAfterNotGroundedMax;
            jumpStartDelay = jump.startDelay;
            jumpSpeedStart = jump.speedStart * timeDeltaMod;
            jumpSpeedEnd = jump.speedEnd * timeDeltaMod;

            // movement basics
            moveVec.copy(moveDir);
            moveVec.x *= moveSpeed;
            moveVec.y *= moveSpeed;

            if (moveDir.z < 0) {

                moveVec.z *= moveSpeedBack;

                jumpSpeedStart *= moveSpeedRatio;
                jumpSpeedEnd *= moveSpeedRatio;

            } else if (jump.active === true) {

                moveVec.z *= jumpSpeedStart;

            } else {

                moveVec.z *= moveSpeed;

            }

            // handle jumping
            state.groundedLast = state.grounded;

            state.grounded = Boolean(velocityGravity.collision);

            jump.timeAfterNotGrounded += timeDelta;

            // if falling but not jumping
            if (jump.active === false && jump.timeAfterNotGrounded >= jumpTimeAfterNotGroundedMax && state.grounded === false) {

                jump.ready = false;

                this.morph_cycle(timeDelta, 'jump', jump.animationTime, true);

            }
            // do jump
            else if (state.up !== 0 && (state.grounded === true || jump.timeAfterNotGrounded < jumpTimeAfterNotGroundedMax) && jump.ready === true) {

                jump.timeTotal = 0;

                jump.startDelayTime = 0;

                jump.ready = false;

                jump.active = true;

            } else if (jump.active === true && jump.timeTotal < jumpTimeMax) {

                // count delay
                jump.startDelayTime += timeDelta;

                // do jump after delay
                if (jump.startDelayTime >= jump.startDelay) {

                    // play jump
                    this.morph_cycle(timeDelta, 'jump', jump.animationTime, true);

                    // properties
                    jumpTimeRatio = jumpTimeTotal / jumpTimeMax;

                    // update time total
                    jump.timeTotal += timeDelta;

                    // add speed to gravity velocity
                    velocityGravityForce.y += jumpSpeedStart * (1 - jumpTimeRatio) + jumpSpeedEnd * jumpTimeRatio;

                } else {

                    // play jump start
                    morphs.play('jump_start', {
                        duration: jump.startAnimationTime,
                        loop: false,
                        callback: function () {
                            morphs.clear('jump_start');
                        }
                    });

                    // hold velocity
                    velocityGravityForce.y = 0;

                }

            } else {

                if (state.grounded === true && jump.active !== false) {

                    jump.active = false;

                    if (jump.timeAfterNotGrounded >= jumpTimeAfterNotGroundedMax) {

                        morphs.clear('jump', move.morphClearTime);

                        morphs.play('jump_end', {
                            duration: jump.endAnimationTime,
                            loop: false,
                            callback: function () {
                                morphs.clear('jump_end', move.morphClearTime);
                            }
                        });

                    }

                }

                if (state.grounded === true && state.up === 0) {

                    jump.timeAfterNotGrounded = 0;

                    jump.ready = true;

                }

            }

            // add move vec to rigidBody movement
            velocityMovementForce.addSelf(moveVec);

            // moving backwards?
            if (velocityMovementForce.z < 0) {

                state.movingBack = true;

            } else if (velocityMovementForce.z > 0) {

                state.movingBack = false;

            }

            // get movement force
            velocityMovementForceLength = velocityMovementForce.length() / timeDeltaMod;

            // walk/run/idle
            if (jump.active === false && state.grounded === true) {

                // walk / run cycles
                if (velocityMovementForceLength > 0) {

                    // get approximate terminal velocity based on acceleration (moveVec) and damping
                    // helps morphs play faster if character is moving faster, or slower if moving slower
                    // TODO: move equation into physics module
                    velocityMovementDamping = velocityMovement.damping.z;
                    dragCoefficient = (0.33758 * Math.pow(velocityMovementDamping, 2)) + (-0.67116 * velocityMovementDamping) + 0.33419;
                    terminalVelocity = Math.round(Math.sqrt((2 * Math.abs(moveVec.z * 0.5)) / dragCoefficient));
                    playSpeedModifier = terminalVelocity / Math.round(velocityMovementForceLength);

                    if (velocityMovementForceLength > move.runThreshold) {

                        this.morph_cycle(timeDelta, 'run', move.runAnimationTime * playSpeedModifier, true, state.movingBack);

                    } else {

                        this.morph_cycle(timeDelta, 'walk', move.walkAnimationTime * playSpeedModifier, true, state.movingBack);

                    }

                }
                // idle cycle
                else {

                    this.morph_cycle(timeDelta, 'idle', move.idleAnimationTime, true, false);

                }

            }

        }

        // update followers
        this.update_followers();

    }

    /*===================================================
	
	show / hide
	
	=====================================================*/

    function show(scene) {

        if (this.showing === false) {

            this._scene = scene || _Game.scene;

            this.scene.add(this);

            this.showing = true;

        }

    }

    function hide() {

        if (this.showing === true) {

            this.scene.remove(this);

            this.showing = false;

        }

    }

}(KAIOPUA));

/*
 *
 * Hero.js
 * Adds additional functionality to basic character.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/characters/Hero.js",
        _Hero = {},
        _Character, _Game, _Farming;

    /*===================================================
    
    public properties
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Hero,
        requirements: ["assets/modules/characters/Character.js", "assets/modules/core/Game.js", "assets/modules/farming/Farming.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(c, g, f) {
        console.log('internal hero', _Hero);

        _Character = c;
        _Game = g;
        _Farming = f;

        _Hero.Instance = Hero;
        _Hero.Instance.prototype = new _Character.Instance();
        _Hero.Instance.prototype.constructor = _Hero.Instance;

    }

    /*===================================================
    
    hero
    
    =====================================================*/

    function Hero(parameters) {

        var me = this;

        // handle parameters
        parameters = parameters || {};

        parameters.id = 'kaiopua_hero';

        parameters.model = parameters.modelInfo || {};
        parameters.model.geometry = main.get_asset_data("assets/models/Hero.js");
        parameters.model.materials = new THREE.MeshLambertMaterial({
            color: 0xFFF7E0,
            ambient: 0xFFF7E0,
            vertexColors: THREE.VertexColors
        });
        parameters.model.shading = THREE.SmoothShading;

        parameters.model.physics = parameters.model.physics || {};
        parameters.model.physics.bodyType = 'capsule';
        parameters.model.physics.movementDamping = 0.5;

        parameters.movement = parameters.movement || {};
        parameters.movement.moveSpeed = 6;
        parameters.movement.moveSpeedBack = 2;
        parameters.movement.moveRunThreshold = parameters.movement.moveSpeed;
        parameters.movement.rotateSpeed = 0.019;
        parameters.movement.jumpSpeedStart = 8;
        parameters.movement.jumpSpeedEnd = 0;
        parameters.movement.jumpTimeMax = 100;
        parameters.movement.jumpAnimationTime = 1500;

        // prototype constructor
        _Character.Instance.call(this, parameters);

        // add to actions
        this.add_action({
            callback: rotate_plant,
            context: this,
            activeCheck: is_planting_rotating,
            activeCheckContext: this,
            actionsNames: ['001', 'rotate_plant']
        });

        this.add_action({
            callback: plant,
            context: this,
            activeCheck: is_planting,
            activeCheckContext: this,
            actionsNames: ['002', 'plant']
        });

    }

    /*===================================================
	
	farming
	
	=====================================================*/

    function plant(parameters) {

        return _Farming.plant(this, parameters);

    }

    function rotate_plant(parameters) {

        parameters = parameters || {};

        parameters.rotate = true;

        return plant.call(this, parameters);

    }

    function is_planting() {

        return _Farming.is_character_planting(this, 'planting');

    }

    function is_planting_rotating() {

        return _Farming.is_character_planting(this, 'rotating');

    }

    /*===================================================
	
	scale
	
	=====================================================*/

    /*
	// OLD SCALE ACTION
	// NOT IN USE, SAVE ANYWAY
	
	function select_and_scale_start ( parameters ) {
		
		var i, l,
			targetsNum,
			targetsNumMax = 1,
			character = parameters.character,
			targeting = character.targeting,
			targets = targeting.targets,
			target,
			actionData = character.actionData,
			adObj;
		
		// select
		
		parameters.targetsNumMax = targetsNumMax;
		
		targetsNum = main.assets.modules.core.Player.select_from_mouse_position( parameters );
		
		// start scale updating, if not already
		
		if ( targetsNum > 0 && typeof actionData.select_and_scale === 'undefined' ) {
			
			console.log('scale start');
			
			// create action data object for select and scale
			
			adObj = actionData.select_and_scale = {
				
				update: function ( e ) {
					
					var mouseOriginal = parameters.mouse;
					var mouseNew = shared.mice[ e.identifier ];
					
					// check mouse given by identifier vs mouse used originally
					
					if ( mouseNew === mouseOriginal ) {
					
						scale_update( parameters );
						
					}
					
				}
				
			};
			
			// create scale record for each target
			// use model id as reference
			
			adObj.scaleRecords = {};
			
			for ( i = 0, l = targets.length; i < l; i ++ ) {
				
				target = targets[ i ];
				
				if ( target.interactive === true ) {
				
					adObj.scaleRecords[ target.id ] = target.scale.clone();
					
				}
				
			}
			
			// signals
			
			shared.signals.mousemoved.add( adObj.update );
			
		}
	
	}
	
	function select_and_scale_end ( parameters ) {
		
		var mouse = parameters.mouse,
			character = parameters.character,
			actionData = character.actionData,
			adObj;
		
		if ( typeof actionData.select_and_scale !== 'undefined' ) {
			
			console.log('scale end');
			
			adObj = actionData.select_and_scale;
			
			// signals
				
			shared.signals.mousemoved.remove( adObj.update );
			
			// clear action data object
			
			delete actionData.select_and_scale;
		
			// trigger deselect
			
			main.assets.modules.core.Player.deselect( parameters );
			
		}
		
	}
	
	function scale_update ( parameters ) {
		
		var i, l,
			mouse = parameters.mouse,
			character = parameters.character,
			actionData = character.actionData,
			adObj,
			targeting = character.targeting,
			targets = targeting.targets,
			targetsToRemove = targeting.targetsToRemove,
			target,
			removeIndex,
			scaleRecords,
			scaleRecord,
			scaleDelta,
			mouseDelta,
			mouseDeltaDivisorY = shared.screenHeight * 0.1;
		
		if ( typeof actionData.select_and_scale !== 'undefined' ) {
			
			console.log('  scale update, num targets: ' + targets.length);
			
			adObj = actionData.select_and_scale;
			
			scaleRecords = adObj.scaleRecords;
			
			// mouse change
			
			mouseDelta = ( mouse.dx - mouse.dy ) * 0.5;
			
			// scale change
			
			scaleDelta = mouseDelta / mouseDeltaDivisorY;
			
			// for all interactive targets
			for ( i = 0, l = targets.length; i < l; i ++ ) {
				
				target = targets[ i ];
				
				if ( target.interactive === true ) {
					
					scaleRecord = scaleRecords[ target.id ];
					
					// if on objects to remove list
					// take out of list
					
					if ( targetsToRemove.length > 0 ) {
						
						removeIndex = targetsToRemove.indexOf( target );
						
						if ( removeIndex !== -1 ) {
							
							targetsToRemove.splice( removeIndex, 1 );
							
						}
						
					}
					
					// scale target
					
					scale_target( target, scaleRecord, scaleDelta );
					
				}
				
			}
			
		}
		
	}
	
	function scale_target ( target, scaleRecord, scaleDelta ) {
		
		var scaleX, scaleY, scaleZ,
			scaleOrigin = 1,
			scaleMax = 10,
			scaleMin = 0.5,
			scaleSnapOriginPct = 0.1,
			scaleSnapOriginAboveDist = (scaleMax - scaleOrigin) * scaleSnapOriginPct,
			scaleSnapOriginBelowDist = (scaleOrigin - scaleMin) * scaleSnapOriginPct;
		
		// scale based on mouse position change
		
		scaleX = scaleRecord.x = Math.max( scaleMin, Math.min( scaleMax, scaleRecord.x + scaleDelta ) );
		scaleY = scaleRecord.y = Math.max( scaleMin, Math.min( scaleMax, scaleRecord.y + scaleDelta ) );
		scaleZ = scaleRecord.z = Math.max( scaleMin, Math.min( scaleMax, scaleRecord.z + scaleDelta ) );
		
		// snap to origin
		
		if ( scaleOrigin - scaleSnapOriginBelowDist < scaleX && scaleX < scaleOrigin + scaleSnapOriginAboveDist ) {
			
			scaleX = scaleOrigin;
			
		}
		
		if ( scaleOrigin - scaleSnapOriginBelowDist < scaleY && scaleY < scaleOrigin + scaleSnapOriginAboveDist ) {
			
			scaleY = scaleOrigin;
			
		}
		
		if ( scaleOrigin - scaleSnapOriginBelowDist < scaleZ && scaleZ < scaleOrigin + scaleSnapOriginAboveDist ) {
			
			scaleZ = scaleOrigin;
			
		}
		
		// set new scale
		
		target.scale.set( scaleX, scaleY, scaleZ );
		
	}
	*/

}(KAIOPUA));

/*
FocusVignette.js
Blurs render increasingly as moves away from center.

Based on ro.me's original PaintEffect implementation
*/

(function (main) {

    var assetPath = "assets/modules/effects/FocusVignette.js",
        fv = {

            uniforms: {

                "tDiffuse": {
                    type: "t",
                    value: 0,
                    texture: null
                },
                "screenWidth": {
                    type: "f",
                    value: 1024
                },
                "screenHeight": {
                    type: "f",
                    value: 1024
                },
                "vingenettingOffset": {
                    type: "f",
                    value: 1.2
                },
                "vingenettingDarkening": {
                    type: "f",
                    value: 0.64
                },
                "colorOffset": {
                    type: "f",
                    value: 0
                },
                "colorFactor": {
                    type: "f",
                    value: 0
                },
                "colorBrightness": {
                    type: "f",
                    value: 0
                },
                "sampleDistance": {
                    type: "f",
                    value: 0.4
                },
                "waveFactor": {
                    type: "f",
                    value: 0.00756
                },
                "colorA": {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                "colorB": {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                },
                "colorC": {
                    type: "v3",
                    value: new THREE.Vector3(1, 1, 1)
                }

            },

            vertexShader: [

                "varying vec2 vUv;",

                "void main() {",

                "vUv = vec2( uv.x, 1.0 - uv.y );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

                "}"

                ].join("\n"),

            fragmentShader: [

                "uniform float screenWidth;", "uniform float screenHeight;", "uniform float vingenettingOffset;", "uniform float vingenettingDarkening;", "uniform float colorOffset;", "uniform float colorFactor;", "uniform float sampleDistance;", "uniform float colorBrightness;", "uniform float waveFactor;", "uniform vec3 colorA;",


                "uniform sampler2D tDiffuse;", "varying vec2 vUv;",

                "void main() {",

                "vec4 color, org, tmp, add;", "float sample_dist, f;", "vec2 vin;", "vec2 uv = vUv;",

                "add += color = org = texture2D( tDiffuse, uv );",

                "vin = (uv - vec2(0.5)) * vec2(4.0);", "sample_dist =(dot( vin, vin ) * 2.0);",

                "f = ( waveFactor + sample_dist ) * sampleDistance * 4.0;",

                "vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2(f);",

                "add += tmp = texture2D( tDiffuse, uv + vec2(0.111964, 0.993712) * sampleSize);", "if( tmp.b < color.b ) color = tmp;",

                "add += tmp = texture2D( tDiffuse, uv + vec2(0.846724, 0.532032) * sampleSize);", "if( tmp.b < color.b ) color = tmp;",

                "add += tmp = texture2D( tDiffuse, uv + vec2(0.943883, -0.330279) * sampleSize);", "if( tmp.b < color.b ) color = tmp;",

                "add += tmp = texture2D( tDiffuse, uv + vec2(0.330279, -0.943883) * sampleSize);", "if( tmp.b < color.b ) color = tmp;",

                "add += tmp = texture2D( tDiffuse, uv + vec2(-0.532032, -0.846724) * sampleSize);", "if( tmp.b < color.b ) color = tmp;",

                "add += tmp = texture2D( tDiffuse, uv + vec2(-0.993712, -0.111964) * sampleSize);", "if( tmp.b < color.b ) color = tmp;",

                "add += tmp = texture2D( tDiffuse, uv + vec2(-0.707107, 0.707107) * sampleSize);", "if( tmp.b < color.b ) color = tmp;",


                "uv = (uv - vec2(0.5)) * vec2( vingenettingOffset );",
                //      "color = color + (add / vec4(8.0) - color) * (vec4(1.0) - vec4(sample_dist * 0.1));",
                            "color = (add / vec4(8.0));", "gl_FragColor = vec4( mix(color.rgb, color.ggg * colorFactor - vec3( vingenettingDarkening ), vec3( dot( uv, uv ))), 1.0 );", "gl_FragColor = vec4(1.0) - (vec4(1.0) - gl_FragColor) * (vec4(1.0) - gl_FragColor);", "}"

                ].join("\n")

        };

    main.asset_register(assetPath, {
        data: fv
    });

}(KAIOPUA));

/*
EffectLinearGradient.js
Draws a linear gradient into background.
*/

(function (main) {

    var assetPath = "assets/modules/effects/LinearGradient.js",
        lg = {};

    /*===================================================
    
    public properties
    
    =====================================================*/

    lg.generate = generate;

    main.asset_register(assetPath, {
        data: lg
    });

    /*===================================================
    
    custom functions
    
    =====================================================*/

    function generate(parameters) {

        var camera, scene, renderer, geometry, materials, quad, width, height, colors, stops, startBottom, threeColors, i, numColors, faceVertexIndices = ['a', 'b', 'c', 'd'],
            colorIndex, face, vertices, vertA, vertD, stopA, colorA, colorB;

        // handle parameters
        parameters = parameters || {};

        width = 1;
        height = 1;
        colors = parameters.colors || [0xFFFFFF, 0x000000];
        stops = parameters.stops || [];
        startBottom = parameters.startBottom || false;
        threeColors = [];

        numColors = colors.length;
        numFaces = numColors - 1;

        // camera and scene
        camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, -10000, 10000);
        camera.position.z = 100;

        scene = new THREE.Scene();

        // gradient material depth test disabled so that it stays in bg
        materials = [
            new THREE.MeshLambertMaterial({
            color: parameters.baseColor || 0xffffff,
            shading: THREE.FlatShading,
            vertexColors: THREE.VertexColors,
            depthTest: false
        })];

        if (parameters.showWireframe === true) {
            materials[materials.length] = new THREE.MeshBasicMaterial({
                color: parameters.wireColor || 0x000000,
                shading: THREE.FlatShading,
                wireframe: true
            });
        }

        // if gradient stops was not passed or passed incorrectly
        if (stops.length !== colors.length) {
            for (i = 0; i < numColors; i += 1) {
                stops[i] = i / (numColors - 1);
            }
        }

        // init three colors
        for (i = 0; i < numColors; i += 1) {
            if (startBottom) {
                colorIndex = numColors - 1 - i;
            } else {
                colorIndex = i;
            }
            threeColors[colorIndex] = new THREE.Color(colors[i]);
        }

        // init geometry
        geometry = new THREE.PlaneGeometry(width, height, 1, numFaces);

        // scale faces based on stops and assign vertex colors
        for (i = 0; i < numFaces; i += 1) {
            face = geometry.faces[i];
            vertices = geometry.vertices;

            vertA = vertices[face[faceVertexIndices[0]]];
            vertD = vertices[face[faceVertexIndices[3]]];

            stopA = stops[i];

            // adjust height of vertices to stops
            vertA.position.y = height * 0.5 - height * stopA;
            vertD.position.y = height * 0.5 - height * stopA;

            colorA = threeColors[i];
            colorB = threeColors[i + 1];

            // set vertex colors
            face.vertexColors[0] = colorA;
            face.vertexColors[3] = colorA;
            face.vertexColors[1] = colorB;
            face.vertexColors[2] = colorB;
        }

        quad = new THREE.Mesh(geometry, materials);
        quad.position.z = -100;

        scene.add(quad);

        return {
            scene: scene,
            camera: camera,
            resize: function (W, H) {

                camera.left = W / -2;
                camera.right = W / 2;
                camera.top = H / 2;
                camera.bottom = H / -2;

                camera.updateProjectionMatrix();

                quad.scale.set(W, H, 1);
            }
        };
    }

}(KAIOPUA));

/*
 *
 * Sky.js
 * World Sky.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/env/Sky.js",
        _Sky = {},
        _Model, _Physics, _ObjectHelper;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Sky,
        requirements: ["assets/modules/core/Model.js", "assets/modules/core/Physics.js", "assets/modules/utils/ObjectHelper.js", "assets/models/Cloud_001.js", "assets/models/Cloud_002.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(m, phy, oh) {
        console.log('internal sky', _Sky);

        _Model = m;
        _Physics = phy;
        _ObjectHelper = oh;

        // properties
        _Sky.numClouds = 10;
        _Sky.cloudInitAxis = new THREE.Vector3(0, 1, 0);
        _Sky.cloudInitAngle = 0;
        _Sky.cloudRotateTowardWorld = true;
        _Sky.cloudScaleMax = 6;
        _Sky.cloudScaleMin = 1;
        _Sky.cloudDistanceFromSurfaceMin = 1000;
        _Sky.cloudDistanceFromSurfaceMax = 3000;
        _Sky.cloudsGeometry = [main.get_asset_data("assets/models/Cloud_001.js"), main.get_asset_data("assets/models/Cloud_002.js")];
        _Sky.bounds = {
            min: new THREE.Vector3(),
            max: new THREE.Vector3()
        };
        _Sky.xThetaMin = 0;
        _Sky.xThetaMax = Math.PI * 2;
        _Sky.yThetaMin = 0;
        _Sky.yThetaMax = Math.PI * 2;

        // instance
        _Sky.Instance = Sky;
        _Sky.Instance.prototype = new _Model.Instance();
        _Sky.Instance.prototype.constructor = _Sky.Instance;
        _Sky.Instance.prototype.supr = _Model.Instance.prototype;

        _Sky.Instance.prototype.set_world = set_world;

        Object.defineProperty(_Sky.Instance.prototype, 'world', {
            get: function () {
                return this._world;
            },
            set: function (world) {
                this.set_world(world);
            }
        });


    }

    /*===================================================
    
    sky
    
    =====================================================*/

    function Sky(parameters) {

        var i, l, cloud;

        // handle parameters
        parameters = parameters || {};

        // prototype constructor
        _Model.Instance.call(this, parameters);

        // properties
        this.numClouds = main.is_number(parameters.numClouds) ? parameters.numClouds : _Sky.numClouds;
        this.cloudInitAxis = main.is_number(parameters.cloudInitAxis) ? parameters.cloudInitAxis : _Sky.cloudInitAxis;
        this.cloudInitAngle = main.is_number(parameters.cloudInitAngle) ? parameters.cloudInitAngle : _Sky.cloudInitAngle;
        this.cloudRotateTowardWorld = typeof parameters.cloudRotateTowardWorld === 'boolean' ? parameters.cloudRotateTowardWorld : _Sky.cloudRotateTowardWorld;
        this.cloudRotateUtilVec31 = new THREE.Vector3();
        this.cloudRotateUtilVec32 = new THREE.Vector3();
        this.cloudScaleMax = main.is_number(parameters.cloudScaleMax) ? parameters.cloudScaleMax : _Sky.cloudScaleMax;
        this.cloudScaleMin = main.is_number(parameters.cloudScaleMin) ? parameters.cloudScaleMin : _Sky.cloudScaleMin;
        this.cloudDistanceFromSurfaceMin = main.is_number(parameters.cloudDistanceFromSurfaceMin) ? parameters.cloudDistanceFromSurfaceMin : _Sky.cloudDistanceFromSurfaceMin;
        this.cloudDistanceFromSurfaceMax = main.is_number(parameters.cloudDistanceFromSurfaceMax) ? parameters.cloudDistanceFromSurfaceMax : _Sky.cloudDistanceFromSurfaceMax;
        this.cloudsGeometry = parameters.cloudsGeometry || _Sky.cloudsGeometry;
        this.bounds = parameters.bounds || _Sky.bounds;
        this.xThetaMin = parameters.xThetaMin || _Sky.xThetaMin;
        this.xThetaMax = parameters.xThetaMax || _Sky.xThetaMax;
        this.yThetaMin = parameters.yThetaMin || _Sky.yThetaMin;
        this.yThetaMax = parameters.yThetaMax || _Sky.yThetaMax;

        // generate clouds
        this.clouds = [];

        for (i = 0, l = this.numClouds; i < l; i++) {

            cloud = new _Model.Instance({
                geometry: this.cloudsGeometry[Math.round(Math.random() * (this.cloudsGeometry.length - 1))],
                materials: new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    ambient: 0xffffff,
                    vertexColors: THREE.VertexColors
                }),
                shading: THREE.SmoothShading
            });

            // store
            this.clouds.push(cloud);

            // add
            this.add(cloud);

        }

        // world
        this.world = parameters.world;

    }

    /*===================================================
    
    world
    
    =====================================================*/

    function set_world(world) {

        var i, l, cloud, children, child, radius, scale, distance, cloudForward = this.cloudRotateUtilVec31,
            cloudUp = this.cloudRotateUtilVec32,
            rt, tx, ty, w, x, y, z;

        // if new world
        if (this._world !== world) {

            // store new world
            this._world = world;

            if (this._world instanceof _Model.Instance) {

                // get world children
                children = _ObjectHelper.extract_children_from_objects(this._world, this._world);

                // get new bounds based on world and children
                this.bounds.min.set(0, 0, 0);
                this.bounds.max.set(0, 0, 0);

                for (i = 0, l = children.length; i < l; i++) {

                    child = children[i];

                    this.bounds = _ObjectHelper.object_push_bounds(child, this.bounds);

                }

                radius = Math.max(this.bounds.min.length(), this.bounds.max.length());

                // update clouds
                for (i = 0, l = this.clouds.length; i < l; i++) {

                    cloud = this.clouds[i];

                    // position
                    z = (radius * 2) * Math.random() - radius;
                    rt = Math.random();
                    tx = rt * (this.xThetaMax - this.xThetaMin) + this.xThetaMin;
                    ty = rt * (this.yThetaMax - this.yThetaMin) + this.yThetaMin;
                    w = Math.asin(z / radius);
                    x = radius * Math.cos(w) * Math.cos(tx);
                    y = radius * Math.cos(w) * Math.sin(ty);

                    cloud.position.set(x, y, z);

                    // rotate
                    cloud.quaternion.setFromAxisAngle(this.cloudInitAxis, this.cloudInitAngle + Math.atan2(x, z));

                    if (this.cloudRotateTowardWorld) {

                        cloudForward.copy(shared.cardinalAxes.forward);
                        cloudUp.copy(shared.cardinalAxes.up);

                        cloud.quaternion.multiplyVector3(cloudForward);
                        cloud.quaternion.multiplyVector3(cloudUp);

                        _Physics.rotate_relative_to_source(cloud, this._world, cloudForward, cloudUp);

                    }

                    // distance
                    distance = Math.random() * (this.cloudDistanceFromSurfaceMax - this.cloudDistanceFromSurfaceMin) + this.cloudDistanceFromSurfaceMin;

                    _Physics.pull_to_source(cloud, this._world, children, distance);

                    // scale
                    scale = Math.random() * (this.cloudScaleMax - this.cloudScaleMin) + this.cloudScaleMin;

                    cloud.scale.set(scale, scale, scale);

                }

            }

        }

    }

}(KAIOPUA));

/*
 *
 * SkyLauncher.js
 * Handles sky environment for launcher.
 *
 * @author Collin Hover / http://collinhover.com/
 * cloud texture (c) ro.me
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/env/SkyLauncher.js",
        _Sky = {},
        skyWidth = 30000,
        skyHeight = 2000,
        skyDepth = 10000,
        numClouds = 80,
        lightAngle = (-Math.PI * 0.25),
        lightAngleVariation = (Math.PI * 0.25),
        timePrev = 0,
        time = 0,
        windDirection = -1,
        windSpeedMax = 2,
        windSpeedMin = 1,
        cloudWidth = 1000,
        cloudDepth = 500,
        cloudHeightStart = {
            min: 400,
            max: 600
        },
        cloudHeightEnd = {
            min: 0,
            max: 1000
        },
        cloudScaleVariation = {
            w: 1,
            h: 0.5,
            d: 0
        },
        numPlanesPerCloud = 100,
        cloudPlaneScaleStart = 6,
        cloudPlaneScaleEnd = 4,
        cloudPlaneTextureLoading = false,
        cloudPlaneTexturePath = "assets/textures/cloud_256.png",
        cloudPlaneTexture, cloudFadeOutTime = 1000,
        cloudFadeInTime = 1000,
        clouds = [],
        environment;

    /*===================================================
    
    public properties
    
    =====================================================*/

    _Sky.init = init;
    _Sky.wind_blow = wind_blow;

    Object.defineProperty(_Sky, 'environment', {
        get: function () {
            return environment;
        }
    });

    main.asset_register(assetPath, {
        data: _Sky
    });

    /*===================================================
    
    external init
    
    =====================================================*/

    function init(parameters) {
        var i, cloud, pct;

        // handle parameters
        parameters = parameters || {};

        skyWidth = parameters.skyWidth || skyWidth;

        skyHeight = parameters.skyHeight || skyHeight;

        skyDepth = parameters.skyDepth || skyDepth;

        numClouds = parameters.numClouds || numClouds;

        lightAngle = parameters.lightAngle || lightAngle;

        lightAngleVariation = parameters.lightAngleVariation || lightAngleVariation;

        windDirection = parameters.windDirection || windDirection;

        windSpeedMax = parameters.windSpeedMax || windSpeedMax;

        windSpeedMin = parameters.windSpeedMin || windSpeedMin;

        cloudWidth = parameters.cloudWidth || cloudWidth;

        cloudDepth = parameters.cloudDepth || cloudDepth;

        cloudHeightStart = parameters.cloudHeightStart || cloudHeightStart;

        cloudHeightEnd = parameters.cloudHeightEnd || cloudHeightEnd;

        cloudScaleVariation = parameters.cloudScaleVariation || cloudScaleVariation;

        numPlanesPerCloud = parameters.numPlanesPerCloud || numPlanesPerCloud;

        cloudPlaneScaleStart = parameters.cloudPlaneScaleStart || cloudPlaneScaleStart;

        cloudPlaneScaleEnd = parameters.cloudPlaneScaleEnd || cloudPlaneScaleEnd;

        // environment
        environment = new THREE.Object3D();

        // generate clouds
        // cloud texture
        cloudPlaneTexture = new THREE.Texture();

        main.asset_require(cloudPlaneTexturePath, function (img) {

            cloudPlaneTexture.image = img;
            cloudPlaneTexture.needsUpdate = true;

        });

        // cloud meshes
        for (i = 0; i < numClouds; i++) {

            pct = ((numClouds - i) / numClouds);

            cloud = generate_cloud();

            cloud.position.x = Math.random() * (skyWidth) - skyWidth * 0.5;
            cloud.position.y = Math.random() * (skyHeight) - skyHeight * 0.5;
            cloud.position.z = (skyDepth * pct) - skyDepth * 0.5;

            clouds[clouds.length] = cloud;

            // add to environment
            environment.add(cloud);
        }

    }

    /*===================================================
    
    custom functions
    
    =====================================================*/

    function generate_cloud(parameters) {
        var cloudMesh, cloudGeometry, cloudMaterial, cloudPlane, numPlanes, width, depth, heightStart, heightEnd, planeScaleStart, planeScaleEnd, scaleVariation, pct, currScale, currPlaneHeightMax, currPlaneHeightMin, kp, i;

        // handle parameters
        parameters = parameters || {};

        numPlanes = parameters.numPlanes || numPlanesPerCloud;

        planeScaleStart = parameters.planeScaleStart || cloudPlaneScaleStart;

        planeScaleEnd = parameters.planeScaleEnd || cloudPlaneScaleEnd;

        scaleVariation = parameters.scaleVariation || cloudScaleVariation;

        width = parameters.width || cloudWidth;

        heightStart = parameters.heightStart || cloudHeightStart;

        heightEnd = parameters.heightEnd || cloudHeightEnd;

        depth = parameters.depth || cloudDepth;

        // scale variation
        width = width + (Math.random() * width * scaleVariation.w - width * scaleVariation.w * 0.5);
        heightStart.max = heightStart.max + (Math.random() * heightStart.max * scaleVariation.h - heightStart.max * scaleVariation.h * 0.5);
        heightStart.min = heightStart.min + (Math.random() * heightStart.min * scaleVariation.h - heightStart.min * scaleVariation.h * 0.5);
        heightEnd.max = heightEnd.max + (Math.random() * heightEnd.max * scaleVariation.h - heightEnd.max * scaleVariation.h * 0.5);
        heightEnd.min = heightEnd.min + (Math.random() * heightEnd.min * scaleVariation.h - heightEnd.min * scaleVariation.h * 0.5);
        depth = depth + (Math.random() * depth * scaleVariation.d - depth * scaleVariation.d * 0.5);

        // material
        cloudMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            depthTest: false,
            map: cloudPlaneTexture
        });

        // geometry
        cloudGeometry = new THREE.Geometry();

        // planes
        cloudPlane = new THREE.Mesh(new THREE.PlaneGeometry(256, 256));

        // position each cloud plane and merge into cloud geometry
        for (i = 0; i < numPlanes; i++) {

            pct = ((numPlanes - i) / numPlanes);

            currScale = planeScaleStart * (1 - pct) + (planeScaleEnd * pct);

            currPlaneHeightMax = heightStart.max + (heightEnd.max - heightStart.max) * pct;

            currPlaneHeightMin = heightStart.min + (heightEnd.min - heightStart.min) * pct;

            cloudPlane.position.x = Math.random() * Math.random() * (width * 2) - width;
            cloudPlane.position.y = Math.random() * Math.random() * (currPlaneHeightMax - currPlaneHeightMin) + currPlaneHeightMin;
            cloudPlane.position.z = i * (depth / numPlanes) - depth * 0.5;
            cloudPlane.rotation.z = lightAngle + (Math.random() * (lightAngleVariation * 2) - lightAngleVariation);
            cloudPlane.scale.x = cloudPlane.scale.y = Math.random() * Math.random() * currScale + (currScale * 0.3);

            THREE.GeometryUtils.merge(cloudGeometry, cloudPlane);

        }

        // mesh
        cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);

        return cloudMesh;
    }

    function wind_blow(timeDelta, direction, speedMax, speedMin) {
        var i, timeDiff, pct, boundXNeg, boundXPos;

        // handle time change
        time += timeDelta;

        timeDiff = 1 - (time - timePrev) / 60;

        timePrev = time;

        // set wind direction and speed
        windDirection = direction || windDirection;

        windSpeedMax = speedMax || windSpeedMax;

        windSpeedMin = speedMin || windSpeedMin;

        boundXPos = skyWidth * 0.5;
        boundXNeg = -boundXPos;

        // push each cloud
        for (i = 0; i < numClouds; i++) {
            cloud = clouds[i];

            pct = ((numClouds - i) / numClouds);

            cloud.position.x += timeDiff * windDirection * (windSpeedMax * pct + windSpeedMin * (1 - pct));

            // cloud bounds
            if (cloud.position.x > boundXPos) {

                cloud.position.x = boundXNeg;

            } else if (cloud.position.x < boundXNeg) {

                cloud.position.x = boundXPos;

            }

        }
    }

}(KAIOPUA));

/*
 *
 * Puzzles.js
 * Generates water plane for world
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/env/Water.js",
        _Water = {},
        _Model, wavesTexturePath = "assets/textures/waves_512.png";

    /*===================================================
    
    public properties
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Water,
        requirements: ["assets/modules/core/Model.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(m) {
        console.log('internal water');
        // assets
        _Model = m;

        _Water.Instance = Water;
        _Water.Instance.prototype = new _Model.Instance();
        _Water.Instance.prototype.constructor = _Water.Instance;

    }

    /*===================================================
    
    water
    
    =====================================================*/

    function Water(parameters) {

        parameters = parameters || {};

        var i, l, wavesInfo, vvInfo, wavesGeometry, wavesMaterial, wavesTexture, wavesVertsW, wavesVertsH, wavesNumHorizontal, wavesNumVertical, wavesSpeed, wavesAmplitude, wavesFrequency, wavesColor, wavesAmbient, wavesSize, wavesMaterialsOpacityBase, wavesMaterialsOpacitySteps, wavesMaterialsDarknessSteps, wavesDarknessColor, materialStep, waves, wavesGeomMaterials, wavesVertsNum, wavesFaces, face, faceCentroid, faceDist, darknessDistMin, darknessDistMax, opacityDistMin, opacityDistMax, centerPoint, vvAmpMax, vvAmpMin, vvAmpDelta, vvFreqMax, vvFreqMin, vvFreqDelta, vvFreqLast, vvDirSwitchDelta;

        // waves info
        wavesInfo = this.waves = {};
        wavesInfo.time = 0;
        wavesColor = parameters.wavesColor || 0x0bdafa;
        wavesAmbient = parameters.wavesAmbient || 0x3492D4;
        wavesSize = parameters.wavesSize || 10000;
        wavesMaterialsOpacityBase = parameters.wavesOpacityBase || 0.95;
        wavesMaterialsOpacitySteps = parameters.wavesOpacitySteps || 40;
        wavesMaterialsDarknessSteps = parameters.wavesDarknessSteps || 30;
        wavesDarknessColor = parameters.wavesDarknessColor || 0x341479;
        wavesInfo.vertsW = wavesVertsW = parameters.wavesVertsW || 100;
        wavesInfo.vertsH = wavesVertsH = parameters.wavesVertsH || 100;
        wavesInfo.numHorizontal = wavesNumHorizontal = parameters.wavesNumHorizontal || 80;
        wavesInfo.numVertical = wavesNumVertical = parameters.wavesNumVertical || 80;
        wavesInfo.speed = wavesSpeed = parameters.wavesSpeed || 0.001;
        wavesInfo.amplitude = wavesAmplitude = parameters.wavesAmplitude || 50;
        wavesInfo.frequency = wavesFrequency = parameters.wavesFrequency || 0.5;
        wavesInfo.timePerCycle = 1000 * (Math.PI * 2) * (1000 * wavesSpeed);

        // vertex variations information
        vvInfo = wavesInfo.vv = {};
        vvInfo.list = [];
        vvInfo.ampAbs = parameters.vvAmpAbs || 35;
        vvInfo.ampMin = vvAmpMin = -Math.min(wavesInfo.amplitude * 0.5, vvInfo.ampAbs);
        vvInfo.ampMax = vvAmpMax = Math.min(wavesInfo.amplitude * 0.5, vvInfo.ampAbs);
        vvInfo.ampDelta = vvAmpDelta = (vvAmpMax - vvAmpMin) * 0.01;
        vvInfo.freqAbs = wavesFrequency;
        vvInfo.freqMin = vvFreqMin = -vvInfo.freqAbs * 0.05;
        vvInfo.freqMax = vvFreqMax = vvInfo.freqAbs * 0.05;
        vvInfo.freqDelta = vvFreqDelta = (vvFreqMax - vvFreqMin) * 0.001;
        vvInfo.dirSwitchPause = wavesInfo.timePerCycle * 0.5;
        vvInfo.dirSwitchDelta = vvDirSwitchDelta = vvInfo.dirSwitchPause / 60;

        // create water geometry
        wavesGeometry = new THREE.PlaneGeometry(wavesSize, wavesSize, wavesVertsW - 1, wavesVertsH - 1);
        wavesGeometry.dynamic = true;

        // per vert variation
        wavesVertsNum = wavesGeometry.vertices.length;

        vvFreqLast = (vvFreqMax - vvFreqMin) * 0.5;

        for (i = 0; i < wavesVertsNum; i++) {

            vvInfo.list[i] = {
                amplitude: Math.random() * (vvAmpMax - vvAmpMin) + vvAmpMin,
                frequency: vvFreqLast * 0.75 + (Math.random() * (vvFreqMax - vvFreqMin) + vvFreqMin) * 0.25,
                dir: 1,
                dirSwitch: Math.round(Math.random() * (vvInfo.dirSwitchPause * 0.5) + (vvInfo.dirSwitchPause * 0.5)),
                dirSwitchCount: Math.round(Math.random() * (vvInfo.dirSwitchPause * 0.5) + (vvInfo.dirSwitchPause * 0.5))
            };

            vvFreqLast = vvInfo.list[i].frequency;

        }

        // waves material
        wavesMaterial = new THREE.MeshLambertMaterial({
            ambient: wavesAmbient,
            color: wavesColor,
            map: wavesTexture,
            //specular: 0x00daff, 
            //shininess: 10, 
            shading: THREE.SmoothShading,
            transparent: true,
            opacity: parameters.wavesOpacity || 0.9
        });

        // waves texture
        if (typeof parameters.wavesTexturePath !== 'undefined') {

            wavesTexture = new THREE.Texture();

            main.asset_require(wavesTexturePath, function (img) {

                wavesTexture.image = img;
                wavesTexture.needsUpdate = true;

            });

            wavesMaterial.map = wavesTexture;

        }

        // create wave morph targets
        var numWavesMorphs = 10,
            morphTimeDelta = wavesInfo.timePerCycle / numWavesMorphs,
            waveVertices, morphTarget, morphTargetVertices, morphTargetVertexIndex, morphTargetVertex, v;

        function zeroPad(num, count) {
            var numZeropad = num + '';
            while (numZeropad.length < count) {
                numZeropad = "0" + numZeropad;
            }
            return numZeropad;
        }

        for (i = 0, l = numWavesMorphs; i < l; i++) {

            // init next morph target
            morphTarget = wavesGeometry.morphTargets[i] = {};
            morphTarget.name = 'waves_' + zeroPad(i, 4);
            morphTarget.vertices = [];

            // get next morph target
            waveVertices = make_waves(morphTimeDelta);

            // add vertices
            morphTargetVertices = morphTarget.vertices;

            for (v = 0; v < wavesVertsW * wavesVertsH; v++) {

                morphTargetVertexIndex = v;

                morphTargetVertex = wavesGeometry.vertices[morphTargetVertexIndex];

                morphTargetVertices.push(new THREE.Vertex(new THREE.Vector3(morphTargetVertex.position.x, morphTargetVertex.position.y, waveVertices[morphTargetVertexIndex])));

            }

        }

        // functions
        function make_waves(time) {

            var wavesVerts = wavesGeometry.vertices,
                wavesTime, wavesVertsNew = new Array(wavesVertsW * wavesVertsH * 3),
                vertVariations = vvInfo.list,
                vertIndex, vert, variation, vvAmp, vvFreq, vvw = wavesVertsW - 1,
                vvh = wavesVertsH - 1,
                vvpw, vvph, i, l;

            // update wave time
            wavesTime = wavesInfo.time += time * wavesSpeed;

            for (i = 0; i < wavesVertsW; i++) {
                for (l = 0; l < wavesVertsH; l++) {

                    vertIndex = i + l * wavesVertsH;

                    vert = wavesVerts[vertIndex];

                    vvpw = wavesNumHorizontal * (i / wavesVertsW);
                    vvph = wavesNumVertical * (l / wavesVertsH);

                    // reset variation amp
                    vvAmp = 0;

                    // set water vert variation
                    if (i !== 0 && i !== vvw && l !== 0 && l !== vvh) {
                        variation = vertVariations[i + l * wavesVertsH];

                        // update variation wavesAmplitude
                        variation.amplitude = Math.min(vvAmpMax, Math.max(vvAmpMin, variation.amplitude + vvAmpDelta * variation.dir));

                        // update variation wavesFrequency
                        vvFreq = wavesFrequency + Math.min(vvFreqMax, Math.max(vvFreqMin, variation.frequency + vvFreqDelta * variation.dir));

                        // check for switch direction of variation
                        if (variation.dirSwitch > variation.dirSwitchCount) {
                            variation.dir = -variation.dir;
                            variation.dirSwitch = 0;
                        }
                        variation.dirSwitch += vvInfo.dirSwitchDelta * variation.dir;

                        // set variation amp
                        vvAmp = variation.amplitude;
                    } else {
                        vvAmp = 0;
                        vvFreq = wavesFrequency;
                    }

                    // set water vert, x/y/z
                    vertIndex = i + l * wavesVertsH;

                    //wavesVertsNew[ vertIndex ] = vert.position.x;
                    //wavesVertsNew[ vertIndex + 1 ] = vert.position.y;
                    wavesVertsNew[vertIndex] = vvAmp + wavesAmplitude * (Math.cos(vvpw * vvFreq + wavesTime) + Math.sin(vvph * vvFreq + wavesTime));

                    //vert.position.z = vvAmp + wavesAmplitude * ( Math.cos( vvpw / vvFreq + wavesTime ) + Math.sin( vvph / vvFreq + wavesTime ) );
                }
            }
            /*
			// recompute normals for correct lighting
			// very heavy on processing
			wavesGeometry.computeFaceNormals();
			wavesGeometry.computeVertexNormals();
			
			// tell three to update vertices
			wavesGeometry.__dirtyVertices = true;
			wavesGeometry.__dirtyNormals = true;
			*/

            return wavesVertsNew;

        }

        // water mesh
        //wavesInfo.model = new _Model.Instance();
        // prototype constructor
        _Model.Instance.call(this, {
            geometry: wavesGeometry,
            materials: wavesMaterial,
            doubleSided: true,
            targetable: false,
            interactive: false,
            rotation: new THREE.Vector3(-90, 0, 0)
        });

    }

}(KAIOPUA));

/*
 *
 * Puzzles.js
 * Generates water plane for world
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/env/WaterLauncher.js",
        _WaterLauncher = {},
        rayTexturePath = "assets/textures/light_ray.png";

    /*===================================================
    
    public
    
    =====================================================*/

    _WaterLauncher.Instance = WaterLauncher;
    _WaterLauncher.Instance.prototype.generate_waves = generate_waves;

    main.asset_register(assetPath, {
        data: _WaterLauncher
    });

    /*===================================================
    
    water
    
    =====================================================*/

    function WaterLauncher(parameters) {

        parameters = parameters || {};

        var i, l, wavesInfo, vvInfo, wavesGeometry, wavesMaterial, wavesMesh, wavesVertsW, wavesVertsH, wavesNumHorizontal, wavesNumVertical, wavesSpeed, wavesAmplitude, wavesFrequency, wavesColor, wavesAmbient, wavesSize, wavesVertsNum, vvAmpMax, vvAmpMin, vvAmpDelta, vvFreqMax, vvFreqMin, vvFreqDelta, vvFreqLast, vvDirSwitchDelta, rays, rayGeometry, rayTexture, rayMaterial, rayMesh, numRays;

        // environment
        this.environment = new THREE.Object3D();

        this.environment.rotation.x = -90 * Math.PI / 180;
        this.environment.rotation.z = -Math.PI * 0.5;

        // waves
        this.waves = {};

        // waves info
        wavesInfo = this.waves.info = {};
        wavesInfo.time = 0;
        wavesColor = parameters.wavesColor || 0x0bdafa;
        wavesAmbient = parameters.wavesAmbient || 0x3492D4;
        wavesSize = parameters.wavesSize || 10000;
        wavesInfo.vertsW = wavesVertsW = parameters.wavesVertsW || 50;
        wavesInfo.vertsH = wavesVertsH = parameters.wavesVertsH || 50;
        wavesInfo.numHorizontal = wavesNumHorizontal = parameters.wavesNumHorizontal || 30;
        wavesInfo.numVertical = wavesNumVertical = parameters.wavesNumVertical || 30;
        wavesInfo.speed = wavesSpeed = parameters.wavesSpeed || 0.001;
        wavesInfo.amplitude = wavesAmplitude = parameters.wavesAmplitude || 100;
        wavesInfo.frequency = wavesFrequency = parameters.wavesFrequency || 0.5;
        wavesInfo.timePerCycle = 1000 * (Math.PI * 2) * (1000 * wavesSpeed);

        // vertex variations information
        vvInfo = this.waves.vertVariations = {};
        vvInfo.list = [];
        vvInfo.ampAbs = parameters.vvAmpAbs || 35;
        vvInfo.ampMin = vvAmpMin = -Math.min(wavesInfo.amplitude * 0.5, vvInfo.ampAbs);
        vvInfo.ampMax = vvAmpMax = Math.min(wavesInfo.amplitude * 0.5, vvInfo.ampAbs);
        vvInfo.ampDelta = vvAmpDelta = (vvAmpMax - vvAmpMin) * 0.01;
        vvInfo.freqAbs = wavesFrequency;
        vvInfo.freqMin = vvFreqMin = -vvInfo.freqAbs * 0.05;
        vvInfo.freqMax = vvFreqMax = vvInfo.freqAbs * 0.05;
        vvInfo.freqDelta = vvFreqDelta = (vvFreqMax - vvFreqMin) * 0.001;
        vvInfo.dirSwitchPause = wavesInfo.timePerCycle * 0.5;
        vvInfo.dirSwitchDelta = vvDirSwitchDelta = vvInfo.dirSwitchPause / 60;

        // create water geometry
        wavesGeometry = new THREE.PlaneGeometry(wavesSize, wavesSize, wavesVertsW - 1, wavesVertsH - 1);
        wavesGeometry.dynamic = true;

        // per vert variation
        wavesVertsNum = wavesGeometry.vertices.length;

        vvFreqLast = (vvFreqMax - vvFreqMin) * 0.5;

        for (i = 0; i < wavesVertsNum; i++) {

            vvInfo.list[i] = {
                amplitude: Math.random() * (vvAmpMax - vvAmpMin) + vvAmpMin,
                frequency: vvFreqLast * 0.75 + (Math.random() * (vvFreqMax - vvFreqMin) + vvFreqMin) * 0.25,
                dir: 1,
                dirSwitch: Math.round(Math.random() * (vvInfo.dirSwitchPause * 0.5) + (vvInfo.dirSwitchPause * 0.5)),
                dirSwitchCount: Math.round(Math.random() * (vvInfo.dirSwitchPause * 0.5) + (vvInfo.dirSwitchPause * 0.5))
            };

            vvFreqLast = vvInfo.list[i].frequency;

        }

        // waves material
        wavesMaterial = new THREE.MeshLambertMaterial({
            ambient: wavesAmbient,
            color: wavesColor,
            //specular: 0x00daff, 
            //shininess: 10, 
            shading: THREE.SmoothShading,
            transparent: true,
            opacity: 0.8
        });

        // water mesh
        wavesMesh = this.waves.mesh = new THREE.Mesh(wavesGeometry, wavesMaterial);
        wavesMesh.doubleSided = true;
        wavesMesh.dynamic = true;

        this.environment.add(wavesMesh);

        // water rays
        rays = this.waves.rays = {};

        numRays = parameters.numRays || 20;

        rays.width = parameters.rayWidth || 700;
        rays.height = parameters.rayHeight || 2000;
        rays.heightVariation = rays.height * 0.5;
        rays.inactive = [];
        rays.active = [];
        rays.lightAngle = (-Math.PI * 0.1);
        rays.showChance = 0.0001;
        rays.opacityOn = 0.6;
        rays.opacityDelta = 0.01;

        // ray geometry
        rayGeometry = new THREE.PlaneGeometry(rays.width, rays.height + (Math.random() * (rays.heightVariation) - (rays.heightVariation * 0.5)));

        // ray texture
        rayTexture = new THREE.Texture();

        main.asset_require(rayTexturePath, function (img) {

            rayTexture.image = img;
            rayTexture.needsUpdate = true;

        });

        // generate all rays
        for (i = 0; i < numRays; i++) {

            // material
            rayMaterial = new THREE.MeshBasicMaterial({
                color: wavesColor,
                map: rayTexture,
                opacity: 0,
                depthTest: false
            });

            // ray
            rayMesh = new THREE.Mesh(rayGeometry, rayMaterial);

            rayMesh.rotation.set(Math.PI * 0.5 - rays.lightAngle, 0, 0);

            // add to inactive water rays list
            rays.inactive[rays.inactive.length] = {
                ray: rayMesh,
                material: rayMaterial,
                targetOpacity: rays.opacityOn,
                targetOpacityDir: 1
            };

            // add to environment
            this.environment.add(rayMesh);

        }

        // ray function
        rays.show_ray = function (rayInfo) {

            var material = rayInfo.material,
                halfDelta = rays.opacityDelta * 0.5;

            // increase material opacity towards target
            material.opacity += (halfDelta + Math.random() * halfDelta) * rayInfo.targetOpacityDir;

            // if at or below 0, stop showing
            if (rayInfo.targetOpacity === 0 && material.opacity <= rayInfo.targetOpacity) {

                rayInfo.targetOpacityDir = 1;
                rayInfo.targetOpacity = rays.opacityOn;

                rays.active.splice(rayInfo.activeIndex, 1);

                rays.inactive[rays.inactive.length] = rayInfo;

            }
            // else keep ray showing
            else {

                if (rayInfo.targetOpacity === rays.opacityOn && material.opacity >= rayInfo.targetOpacity) {

                    rayInfo.targetOpacityDir = -1;
                    rayInfo.targetOpacity = 0;

                }

                // recursive call until done
                window.requestAnimationFrame(function () {
                    rays.show_ray(rayInfo);
                });
            }

        }

    }

    // functions
    function generate_waves(time) {

        var i, l, waves = this.waves,
            wavesInfo = waves.info,
            wavesMesh = waves.mesh,
            wavesGeometry = wavesMesh.geometry,
            wavesVerts = wavesGeometry.vertices,
            wavesTime, wavesVertsW = wavesInfo.vertsW,
            wavesVertsH = wavesInfo.vertsH,
            wavesNumHorizontal = wavesInfo.numHorizontal,
            wavesNumVertical = wavesInfo.numVertical,
            wavesAmplitude = wavesInfo.amplitude,
            wavesFrequency = wavesInfo.frequency,
            vvInfo = waves.vertVariations,
            vertVariations = vvInfo.list,
            vertIndex, vert, variation, vvAmp, vvAmpMax = vvInfo.ampMax,
            vvAmpMin = vvInfo.ampMin,
            vvAmpDelta = vvInfo.ampDelta,
            vvFreq, vvFreqMax = vvInfo.freqMax,
            vvFreqMin = vvInfo.freqMin,
            vvFreqDelta = vvInfo.freqDelta,
            vvDirSwitchDelta = vvInfo.dirSwitchDelta,
            vvw = wavesVertsW - 1,
            vvh = wavesVertsH - 1,
            vvpw, vvph, rays = waves.rays,
            rayInfo, ray;

        // update wave time
        wavesTime = wavesInfo.time += time * wavesInfo.speed;

        for (i = 0; i < wavesVertsW; i++) {
            for (l = 0; l < wavesVertsH; l++) {

                vertIndex = i + l * wavesVertsH;

                vert = wavesVerts[vertIndex];

                vvpw = wavesNumHorizontal * (i / wavesVertsW);
                vvph = wavesNumVertical * (l / wavesVertsH);

                // reset variation amp
                vvAmp = 0;

                // set water vert variation
                if (i !== 0 && i !== vvw && l !== 0 && l !== vvh) {

                    variation = vertVariations[i + l * wavesVertsH];

                    // update variation amplitude
                    variation.amplitude = Math.min(vvAmpMax, Math.max(vvAmpMin, variation.amplitude + vvAmpDelta * variation.dir));

                    // update variation wavesFrequency
                    vvFreq = wavesFrequency + Math.min(vvFreqMax, Math.max(vvFreqMin, variation.frequency + vvFreqDelta * variation.dir));

                    // check for switch direction of variation
                    if (variation.dirSwitch > variation.dirSwitchCount) {
                        variation.dir = -variation.dir;
                        variation.dirSwitch = 0;
                    }
                    variation.dirSwitch += vvDirSwitchDelta * variation.dir;

                    // set variation amp
                    vvAmp = variation.amplitude;

                } else {

                    vvAmp = 0;
                    vvFreq = wavesFrequency;

                }

                // set water vert z
                vert.position.z = vvAmp + wavesAmplitude * (Math.cos(vvpw * vvFreq + wavesTime) + Math.sin(vvph * vvFreq + wavesTime));

                // check vert z, if low enough 
                // and there are inactive water rays, show water ray
                if (vert.position.z < -wavesAmplitude && rays.inactive.length > 0 && Math.random() <= rays.showChance) {

                    // get next ray by removing last from inactive
                    rayInfo = rays.inactive.pop();
                    ray = rayInfo.ray;

                    // set ray position to position of triggering water vertex
                    ray.position.set(vert.position.x, vert.position.y, -(vert.position.z + rays.height * 0.5 + wavesAmplitude));

                    // record active index for later so we dont have to search
                    rayInfo.activeIndex = rays.active.length;

                    // add to list of active rays
                    rays.active[rays.active.length] = rayInfo;

                    // show ray
                    rays.show_ray(rayInfo);

                }

            }
        }

        // recompute normals for correct lighting
        // very heavy on processing
        wavesGeometry.computeFaceNormals();
        wavesGeometry.computeVertexNormals();

        // tell three to update vertices
        wavesGeometry.__dirtyVertices = true;
        wavesGeometry.__dirtyNormals = true;

    }

}(KAIOPUA));

/*
 *
 * World.js
 * Generates worlds.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/env/World.js",
        _World = {},
        _Game, _Model, gravityMagnitude = 9.8;

    /*===================================================
    
    public properties
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _World,
        requirements: ["assets/modules/core/Game.js", "assets/modules/core/Model.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(g, m) {
        console.log('internal world');

        // assets
        _Game = g;
        _Model = m;

        _World.Instance = World;
        _World.Instance.prototype = new _Model.Instance();
        _World.Instance.prototype.constructor = _World.Instance;
        _World.Instance.prototype.show = show;
        _World.Instance.prototype.hide = hide;
        _World.Instance.prototype.update = update;

        Object.defineProperty(_World.Instance.prototype, 'scene', {
            get: function () {
                return this._scene;
            },
            set: function (newScene) {

                if (typeof newScene !== 'undefined') {

                    // remove from previous
                    this.hide();

                    // add to new
                    this.show(newScene);

                }

            }
        });

    }

    /*===================================================
    
    world
    
    =====================================================*/

    function World(parameters) {

        var me = this;

        // handle parameters
        parameters = parameters || {};

        // prototype constructor
        _Model.Instance.call(me, parameters);

        // properties
        me.gravityMagnitude = parameters.gravityMagnitude || gravityMagnitude;

        me.parts = {};

        me.addOnShow = [];

    }

    /*===================================================
	
	show / hide / update
	
	=====================================================*/

    function show(scene) {

        this._scene = scene || _Game.scene;

        // fog
        this.scene.fog = this.fog;

        // add self
        this.scene.add(this);

        // TODO, remove following
        _Game.add_to_scene(this.addOnShow, this.scene);

    }

    function hide() {

        this.scene.remove(this);

        // TODO, remove following
        _Game.remove_from_scene(this.addOnShow, this.scene);

    }

    function update(timeDelta) {



    }

}(KAIOPUA));

/*
 *
 * WorldIsland.js
 * Generates island world.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/env/WorldIsland.js",
        _WorldIsland = {},
        _World, _Game, _Model, _Physics, _Field, _ObjectMaker, _Water, _Sky;

    /*===================================================
    
    public properties
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _WorldIsland,
        requirements: ["assets/modules/core/Game.js", "assets/modules/env/World.js", "assets/modules/core/Model.js", "assets/modules/core/Physics.js", "assets/modules/farming/Field.js", "assets/modules/utils/ObjectMaker.js", "assets/modules/env/Water.js", "assets/modules/env/Sky.js", ],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(g, world, m, physics, f, om, w, sky) {
        console.log('internal world island');

        // assets
        _Game = g;
        _World = world;
        _Model = m;
        _Physics = physics;
        _Field = f;
        _ObjectMaker = om;
        _Water = w;
        _Sky = sky;

        _WorldIsland.Instance = WorldIsland;
        _WorldIsland.Instance.prototype = new _World.Instance();
        _WorldIsland.Instance.prototype.constructor = _WorldIsland.Instance;

    }

    /*===================================================
    
    world
    
    =====================================================*/

    function WorldIsland(parameters) {

        var me = this;

        // prototype constructor
        _World.Instance.call(me, parameters);

        // public
        me.show = show;
        me.hide = hide;

        /*===================================================
		
		environment
		
		=====================================================*/

        // skybox
        me.parts.skybox = _ObjectMaker.make_skybox("assets/textures/skybox_world");

        // world base
        me.parts.body = new _Model.Instance();

        me.parts.body.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI * 0.4);

        me.add(me.parts.body);

        // ambient
        me.parts.ambientLight = new THREE.AmbientLight(0x999999);

        me.add(me.parts.ambientLight);

        // fog
        me.parts.fog = null; //new THREE.Fog( 0x226fb3, 1, 10000 );
        // body parts
        me.parts.head = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Whale_Head.js"),
            physics: {
                bodyType: 'mesh'
            },
            materials: new THREE.MeshLambertMaterial({
                color: 0xFFF7E0,
                ambient: 0xFFF7E0,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading
        });

        me.parts.body.add(me.parts.head);

        me.parts.tail = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Whale_Tail.js"),
            physics: {
                bodyType: 'mesh'
            },
            materials: new THREE.MeshLambertMaterial({
                color: 0xFFF7E0,
                ambient: 0xFFF7E0,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading
        });

        me.parts.body.add(me.parts.tail);

        // water
        me.parts.waterRing = new _Water.Instance({
            wavesTexturePath: "assets/textures/waves_512.png"
        });

        me.add(me.parts.waterRing);

        /*===================================================
		
		sky
		
		=====================================================*/

        // sun/moon
        me.parts.sunmoon = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Sun_Moon.js"),
            physics: {
                bodyType: 'mesh'
            },
            materials: new THREE.MeshBasicMaterial({
                color: 0xffffff,
                shading: THREE.NoShading,
                vertexColors: THREE.VertexColors
            })
        });

        me.parts.sunmoon.position.set(0, 4000, 0);
        me.parts.sunmoon.quaternion.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI);

        _Physics.rotate_relative_to_source(me.parts.sunmoon, me.parts.body, shared.cardinalAxes.forward.clone().negate(), shared.cardinalAxes.up);

        me.add(me.parts.sunmoon);

        // sun light
        me.parts.sunmoonLight = new THREE.PointLight(0xffffff, 1, 10000);

        me.parts.sunmoon.add(me.parts.sunmoonLight);

        // sky
        me.parts.sky = new _Sky.Instance({
            world: me.parts.body,
            numClouds: 20,
            cloudDistanceFromSurfaceMin: me.parts.sunmoon.position.length() - 2000,
            cloudDistanceFromSurfaceMax: me.parts.sunmoon.position.length() + 500,
            yThetaMin: Math.PI * 0.2,
            yThetaMax: Math.PI * 0.8
        });

        me.add(me.parts.sky);

        /*===================================================
		
		home
		
		=====================================================*/

        me.parts.home = new _Model.Instance();

        me.parts.body.add(me.parts.home);

        // hill for home
        me.parts.hill = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Hut_Hill.js"),
            physics: {
                bodyType: 'mesh'
            },
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            center: true
        });

        me.parts.home.add(me.parts.hill);

        // steps
        me.parts.steps = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Hut_Steps.js"),
            physics: {
                bodyType: 'mesh'
            },
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            center: true
        });

        me.parts.home.add(me.parts.steps);

        // hut
        me.parts.hut = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Hut.js"),
            physics: {
                bodyType: 'mesh'
            },
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            center: true
        });

        me.parts.home.add(me.parts.hut);

        // banana leaf door
        me.parts.bananaLeafDoor = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Banana_Leaf_Door.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            center: true,
            doubleSided: true
        });

        me.parts.home.add(me.parts.bananaLeafDoor);

        // surfboard
        me.parts.surfboard = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Surfboard.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            center: true
        });

        me.parts.home.add(me.parts.surfboard);

        /*===================================================
		
		volcano
		
		=====================================================*/

        me.parts.volcano = new _Model.Instance();

        me.parts.body.add(me.parts.volcano);

        // volcano large
        me.parts.volcanoLarge = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Volcano_Large.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            physics: {
                bodyType: 'mesh'
            },
            center: true
        });

        me.parts.volcano.add(me.parts.volcanoLarge);

        // volcano small
        me.parts.volcanoSmall = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Volcano_Small.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            physics: {
                bodyType: 'mesh'
            },
            center: true
        });

        me.parts.volcano.add(me.parts.volcanoSmall);

        // volcano rocks
        me.parts.volcanoRocks001 = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Volcano_Rocks_001.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            physics: {
                bodyType: 'mesh'
            },
            center: true
        });

        me.parts.volcano.add(me.parts.volcanoRocks001);

        me.parts.volcanoRocks002 = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Volcano_Rocks_002.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            physics: {
                bodyType: 'mesh'
            },
            center: true
        });

        me.parts.volcano.add(me.parts.volcanoRocks002);

        me.parts.volcanoRocks003 = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Volcano_Rocks_003.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            physics: {
                bodyType: 'mesh'
            },
            center: true
        });

        me.parts.volcano.add(me.parts.volcanoRocks003);

        me.parts.volcanoRocks004 = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Volcano_Rocks_004.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            physics: {
                bodyType: 'mesh'
            },
            center: true
        });

        me.parts.volcano.add(me.parts.volcanoRocks004);

        me.parts.volcanoRocks005 = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Volcano_Rocks_005.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading,
            physics: {
                bodyType: 'mesh'
            },
            center: true
        });

        me.parts.volcano.add(me.parts.volcanoRocks005);

        /*===================================================
		
		trees
		
		=====================================================*/

        me.parts.trees = new _Model.Instance();

        me.parts.body.add(me.parts.trees);

        // kukui trees
        me.parts.kukuiTrees = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Kukui_Trees.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading
        });

        me.parts.trees.add(me.parts.kukuiTrees);

        // palm trees
        me.parts.palmTrees = new _Model.Instance({
            geometry: main.get_asset_data("assets/models/Palm_Trees.js"),
            materials: new THREE.MeshLambertMaterial({
                color: 0xffffff,
                ambient: 0xffffff,
                vertexColors: THREE.VertexColors
            }),
            shading: THREE.SmoothShading
        });

        me.parts.trees.add(me.parts.palmTrees);

        /*===================================================
		
		puzzles
		
		=====================================================*/

        // puzzles
        me.parts.fieldTutorial = new _Field.Instance({
            id: 'Tutorial',
            grid: {
                modulesGeometry: main.get_asset_data("assets/models/Field_Tutorial.js")
            }
        });

        me.parts.body.add(me.parts.fieldTutorial);

        // functions
        /*===================================================
		
		show / hide
		
		=====================================================*/

        function show(scene) {

            // proto
            _World.Instance.prototype.show.call(me, scene);

            // skybox
            _Game.sceneBG.add(me.parts.skybox);

            // morph animations
            me.parts.tail.morphs.play('swim', {
                duration: 5000,
                loop: true
            });

            me.parts.sunmoon.morphs.play('shine', {
                duration: 500,
                loop: true,
                reverseOnComplete: true,
                durationShift: 4000
            });

            me.parts.sunmoon.morphs.play('bounce', {
                duration: 3000,
                loop: true,
                loopDelay: 4000,
                loopChance: 0.1
            });

            me.parts.waterRing.morphs.play('waves', {
                duration: 5000,
                loop: true
            });

        }

        function hide() {

            // proto
            _World.Instance.prototype.hide.call(me);

            // skybox
            _Game.sceneBG.remove(me.parts.skybox);

            // morphs
            me.parts.tail.morphs.stopAll();

            me.parts.sunmoon.morphs.stopAll();

            me.parts.waterRing.morphs.stopAll();

        }

    }

}(KAIOPUA));

/*
 *
 * Farming.js
 * Gives a character the ability to farm.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/farming/Farming.js",
        _Farming = {},
        _Game, _Puzzle, _Planting, _Field, _Character, _Player, _GUI, _Button, _Menu, farmers = [];

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Farming,
        requirements: ["assets/modules/core/Game.js", "assets/modules/puzzles/Puzzle.js", "assets/modules/farming/Planting.js", "assets/modules/farming/Field.js", "assets/modules/characters/Character.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(g, pzl, pl, f, c) {
        console.log('internal farming', _Farming);

        _Game = g;
        _Puzzle = pzl;
        _Planting = pl;
        _Field = f;
        _Character = c;

        // properties
        _Farming.plantParameters = {};

        Object.defineProperty(_Farming.plantParameters, 'rock', {
            get: function () {

                return {
                    seed: {
                        image: shared.pathToIcons + 'rock_64.png'
                    },
                    geometry: "assets/models/Rock.js",
                    layout: [
                        [1]
                        ]
                };

            }
        });

        Object.defineProperty(_Farming.plantParameters, 'taro', {
            get: function () {

                return {
                    seed: {
                        image: shared.pathToIcons + 'taro_64.png'
                    },
                    geometry: "assets/models/Taro_Plant.js",
                    layout: [
                        [1]
                        ]
                };

            }
        });

        // functions
        _Farming.plant = plant;
        _Farming.is_character_planting = is_character_planting;

        // ui
        main.asset_require(["assets/modules/core/Player.js", "assets/modules/ui/GUI.js", "assets/modules/ui/Button.js", "assets/modules/ui/Menu.js"], init_farming_ui, true);
    }

    /*===================================================
	
	ui
	
	=====================================================*/

    function init_farming_ui(p, gui, btn, mn) {
        console.log('internal farming ui');
        var b, m;

        _Player = p;
        _GUI = gui;
        _Button = btn;
        _Menu = mn;

        b = _GUI.buttons;
        m = _GUI.menus;

        // menu
        this.menu = m.farming = new _Menu.Instance({
            id: 'farming',
            openAlone: false
        });

        m.farming.buttonOpen = new _Button.Instance({
            id: 'open',
            image: shared.pathToIcons + 'farming_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Farming',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true
        });

        m.farming.buttonClose = _GUI.generate_button_close();
        m.farming.buttonClose.alignment = 'topleft';
        m.farming.buttonClose.alignmentGuide = m.farming.buttonOpen;
        m.farming.buttonClose.spacingLeft = -m.farming.buttonClose.width;

        m.farming.add(
        new _Button.Instance({
            id: 'rock',
            image: shared.pathToIcons + 'rock_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Rock',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            theme: 'green',
            callback: plant_from_ui,
            context: _Farming,
            data: 'rock'
        }), new _Button.Instance({
            id: 'taro',
            image: shared.pathToIcons + 'taro_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Taro',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            theme: 'green',
            callback: plant_from_ui,
            context: _Farming,
            data: 'taro'
        }), new _Button.Instance({
            id: 'tarodouble',
            image: shared.pathToIcons + 'taro_double_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Two-headed Taro',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            theme: 'green'
        }), new _Button.Instance({
            id: 'tarotriple',
            image: shared.pathToIcons + 'taro_triple_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Triple Taro',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            theme: 'green'
        }));

        m.farming.arrange_line({
            childrenPerLine: 5
        });

        m.farming.alignmentOpen = 'lefttop';
        m.farming.alignmentClosed = false;
        m.farming.alignmentGuide = m.farming.buttonOpen;
        m.farming.alignmentOutside = true;

        m.navigation.add(m.farming, 0);

    }

    function plant_from_ui(plantType) {

        plant(_Player.character, {
            plant: _Farming.plantParameters[plantType]
        });

    }

    /*===================================================
	
	planting
	
	=====================================================*/

    function plant(character, parameters) {

        var i, l, farmer, planting, index = -1;

        // if character passed
        if (character instanceof _Character.Instance) {

            // if character on farmer list
            index = main.index_of_object_with_property_value(farmers, 'character', character);

            // create new farmer
            if (index === -1) {

                farmer = {
                    character: character,
                    planting: new _Planting.Instance(character)
                };

                farmers.push(farmer);

            }
            // or use existing
            else {

                farmer = farmers[index];

            }

            // get planting
            planting = farmer.planting;

            // step planting cycle
            planting.step(parameters);

        }

    }

    function is_character_planting(character, property) {

        var i, l, farmer, planting, result = false,
            index = -1;

        // if character passed
        if (character instanceof _Character.Instance) {

            // if character on farmer list
            index = main.index_of_object_with_property_value(farmers, 'character', character);

            // if character on farmer list
            if (index !== -1) {

                farmer = farmers[index];

                // get planting
                planting = farmer.planting;

                // check planting cycle
                if (planting.hasOwnProperty(property)) {

                    result = planting[property];

                } else {

                    result = planting.started || planting.rotating;

                }

            }

        }

        return result;

    }

}(KAIOPUA));

/*
 *
 * Field.js
 * Basic puzzle of farming.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/farming/Field.js",
        _Field = {},
        _Puzzle;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Field,
        requirements: ["assets/modules/puzzles/Puzzle.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(pzl) {
        console.log('internal field', _Field);

        _Puzzle = pzl;

        _Field.Instance = Field;
        _Field.Instance.prototype = new _Puzzle.Instance();
        _Field.Instance.prototype.constructor = _Field.Instance;
        _Field.Instance.prototype.supr = _Puzzle.Instance.prototype;

        Object.defineProperty(_Field.Instance.prototype, 'plants', {
            get: function () {

                // prototype call
                return this.elements;

            }
        });

    }

    /*===================================================
    
    planting
    
    =====================================================*/

    function Field(parameters) {

        // handle parameters
        parameters = parameters || {};

        // prototype constructor
        _Puzzle.Instance.call(this, parameters);

    }

}(KAIOPUA));

/*
 *
 * Plant.js
 * Basic element of farming.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/farming/Plant.js",
        _Plant = {},
        _GridElement, _GridModule, _UIElement, _Button, _GUI, _ObjectHelper, plantGeometryBase, utilVec31Grow;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Plant,
        requirements: ["assets/modules/puzzles/GridElement.js", "assets/modules/puzzles/GridModule.js", "assets/modules/ui/UIElement.js", "assets/modules/ui/Button.js", "assets/modules/ui/GUI.js", "assets/modules/utils/ObjectHelper.js",
        {
            path: "assets/models/Taro_Plant.js",
            type: 'model'
        }],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(ge, gm, uie, btn, gui, oh, plant) {
        console.log('internal plant', _Plant);

        _GridElement = ge;
        _GridModule = gm;
        _UIElement = uie;
        _Button = btn;
        _GUI = gui;
        _ObjectHelper = oh;
        plantGeometryBase = plant;

        utilVec31Grow = new THREE.Vector3();

        // properties
        _Plant.timeGrow = 500;
        _Plant.timeShow = 125;
        _Plant.timeHide = 125;
        _Plant.opacitySeed = 0.75;
        _Plant.opacityVacant = 0.5;
        _Plant.opacityVacantSeed = 0.9;
        _Plant.opacityOccupied = 0.5;
        _Plant.opacityOccupiedSeed = 0.9;
        _Plant.opacityRotator = 0.85;

        // instance
        _Plant.Instance = Plant;
        _Plant.Instance.prototype = new _GridElement.Instance();
        _Plant.Instance.prototype.constructor = _Plant.Instance;
        _Plant.Instance.prototype.supr = _GridElement.Instance.prototype;

        _Plant.Instance.prototype.reset_material = reset_material;

        _Plant.Instance.prototype.change_rotator = change_rotator;
        _Plant.Instance.prototype.change_seed = change_seed;
        _Plant.Instance.prototype.change_module = change_module;

        _Plant.Instance.prototype.test_occupy_module = test_occupy_module;

        _Plant.Instance.prototype.grow = grow;
        _Plant.Instance.prototype.uproot = uproot;

        _Plant.Instance.prototype.update = update;

    }

    /*===================================================
    
    plant
    
    =====================================================*/

    function Plant(parameters) {

        // handle parameters
        parameters = parameters || {};

        if (typeof parameters.geometry === 'undefined') {

            parameters.geometry = plantGeometryBase;

            parameters.layout = [
                [1]
                ];

        }

        parameters.materials = parameters.materials || new THREE.MeshLambertMaterial({
            color: 0xffffff,
            ambient: 0xffffff,
            vertexColors: THREE.VertexColors
        });

        // prototype constructor
        _GridElement.Instance.call(this, parameters);

        // properties
        this.timeGrow = main.is_number(parameters.timeGrow) ? parameters.timeGrow : _Plant.timeGrow;

        this.planted = false;

        this.materialBase = new THREE.MeshLambertMaterial();
        this.materialBase.color.copy(this.material.color);
        this.materialBase.ambient.copy(this.material.ambient);
        this.materialBase.vertexColors = this.material.vertexColors;

        this.change_seed(parameters.seed);

        this.change_rotator(parameters.rotator);

    }

    /*===================================================
    
    seed
    
    =====================================================*/

    function change_rotator(parameters) {

        var parentPrevious = false;

        // if exists, hide/clear
        if (this.rotator instanceof _UIElement.Instance) {

            parentPrevious = this.rotator.parent;

            this.rotator.hide({
                remove: true,
                time: 0
            });

        }

        // if is uielement
        if (parameters instanceof _UIElement.Instance) {

            this.rotator = parameters;

        }
        // else create uielement
        else {

            // handle parameters
            parameters = parameters || {};

            parameters.id = parameters.id || 'plant_rotator';
            parameters.image = parameters.image || shared.pathToIcons + 'rotate_64.png';
            parameters.imageSize = main.is_number(parameters.imageSize) ? parameters.imageSize : _GUI.sizes.iconLarge;
            parameters.width = main.is_number(parameters.width) ? parameters.width : _GUI.sizes.iconLargeContainer;
            parameters.height = main.is_number(parameters.height) ? parameters.height : _GUI.sizes.iconLargeContainer;
            parameters.timeShow = main.is_number(parameters.timeShow) ? parameters.timeShow : _Plant.timeShow;
            parameters.timeHide = main.is_number(parameters.timeHide) ? parameters.timeHide : _Plant.timeHide;
            parameters.opacityShow = main.is_number(parameters.opacityShow) ? parameters.opacityShow : _Plant.opacityRotator;
            parameters.pointerEvents = false;
            parameters.circle = true;

            this.rotator = new _Button.Instance(parameters);

            this.rotator.hide({
                time: 0
            });

            if (parentPrevious) {

                this.rotator.show({
                    parent: parentPrevious
                });

            }

        }

    }

    /*===================================================
    
    seed
    
    =====================================================*/

    function change_seed(parameters) {

        var parentPrevious = false;

        // if exists, hide/clear
        if (this.seed instanceof _UIElement.Instance) {

            parentPrevious = this.seed.parent;

            this.seed.hide({
                remove: true,
                time: 0
            });

        }

        // if is uielement
        if (parameters instanceof _UIElement.Instance) {

            this.seed = parameters;

        }
        // else create uielement
        else {

            // handle parameters
            parameters = parameters || {};

            parameters.id = parameters.id || 'plant_seed';
            parameters.image = parameters.image || shared.pathToIcons + 'plant_64.png';
            parameters.imageSize = main.is_number(parameters.imageSize) ? parameters.imageSize : _GUI.sizes.iconMedium;
            parameters.width = main.is_number(parameters.width) ? parameters.width : _GUI.sizes.iconMediumContainer;
            parameters.height = main.is_number(parameters.height) ? parameters.height : _GUI.sizes.iconMediumContainer;
            parameters.timeShow = main.is_number(parameters.timeShow) ? parameters.timeShow : _Plant.timeShow;
            parameters.timeHide = main.is_number(parameters.timeHide) ? parameters.timeHide : _Plant.timeHide;
            parameters.opacityShow = main.is_number(parameters.opacityShow) ? parameters.opacityShow : _Plant.opacitySeed;
            parameters.pointerEvents = false;
            parameters.circle = true;

            this.seed = new _Button.Instance(parameters);

            this.seed.hide({
                time: 0
            });

            if (parentPrevious) {

                this.seed.show({
                    parent: parentPrevious
                });

            }

        }

    }

    /*===================================================
    
    material
    
    =====================================================*/

    function reset_material() {

        this.material.color.copy(this.materialBase.color);
        this.material.ambient.copy(this.materialBase.ambient);
        this.material.vertexColors = this.materialBase.vertexColors;
        this.material.transparent = false;
        this.material.opacity = 1;

    }

    /*===================================================
    
    module
    
    =====================================================*/

    function change_module() {

        // prototype call
        _Plant.Instance.prototype.supr.change_module.apply(this, arguments);

        // reset material
        this.reset_material();

        // handle planted state
        if (this.module instanceof _GridModule.Instance) {

            this.planted = true;

            this.grow();

        } else {

            this.planted = false;

        }

    }

    function test_occupy_module(testModule) {

        var success;

        // proto
        success = _Plant.Instance.prototype.supr.test_occupy_module.apply(this, arguments);

        // if successful
        if (success === true) {

            this.material.color.copy(_GridModule.colors.vacant);
            this.material.ambient.copy(_GridModule.colors.vacant);
            this.material.transparent = true;
            this.material.opacity = _Plant.opacityVacant;

            this.seed.apply_css('background-color', _GridModule.colors.vacant.getContextStyle());

            this.seed.show({
                opacity: _Plant.opacityVacantSeed
            });

        }
        // unsuccessful, but tested on an actual module
        else if (testModule instanceof _GridModule.Instance) {

            this.material.color.copy(_GridModule.colors.occupied);
            this.material.ambient.copy(_GridModule.colors.occupied);
            this.material.transparent = true;
            this.material.opacity = _Plant.opacityOccupied;

            this.seed.apply_css('background-color', _GridModule.colors.occupied.getContextStyle());

            this.seed.show({
                opacity: _Plant.opacityOccupiedSeed
            });

        }
        // unsuccessful, no module
        else {

            this.reset_material();

            this.seed.apply_css(this.seed.theme.stateLast);

            this.seed.show({
                opacity: _Plant.opacitySeed
            });

        }

        return success;

    }

    /*===================================================
    
    grow
    
    =====================================================*/

    function grow() {
        console.log('plant grow!');
        // set scale to 0
        this.scale.set(0, 0, 0);

        // tween scale to 1
        this.tween_properties({
            time: this.timeGrow,
            easing: TWEEN.Easing.Back.EaseOut,
            scale: utilVec31Grow.set(1, 1, 1)
        });

    }

    /*===================================================
    
    uproot
    
    =====================================================*/

    function uproot() {

        // clear module
        this.change_module();

    }

    /*===================================================
    
    update
    
    =====================================================*/

    function update() {

        _Plant.Instance.prototype.supr.update.apply(this, arguments);

    }

}(KAIOPUA));

/*
 *
 * Planting.js
 * Basic activity of farming.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/farming/Planting.js",
        _Planting = {},
        _Game, _GUI, _Puzzle, _GridModule, _Plant, _ObjectHelper, _MathHelper, allPlants, utilVec31Rotate, utilProjector1Rotate;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Planting,
        requirements: ["assets/modules/core/Game.js", "assets/modules/ui/GUI.js", "assets/modules/puzzles/Puzzle.js", "assets/modules/puzzles/GridModule.js", "assets/modules/farming/Plant.js", "assets/modules/utils/ObjectHelper.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(g, gui, pzl, gm, pl, oh, mh) {
        console.log('internal planting', _Planting);

        _Game = g;
        _GUI = gui;
        _Puzzle = pzl;
        _GridModule = gm;
        _Plant = pl;
        _ObjectHelper = oh;
        _MathHelper = mh;

        utilVec31Rotate = new THREE.Vector3();
        utilProjector1Rotate = new THREE.Projector();

        // properties
        allPlants = [];

        Object.defineProperty(_Planting, 'allPlants', {
            get: function () {
                return allPlants;
            }
        });

        _Planting.rotationSpeed = 0.05;
        _Planting.rotationDistanceMin = 10;
        _Planting.rotationStartThreshold = Math.PI * 0.1;
        _Planting.rotationDirChangeThreshold = 5;

        // instance
        _Planting.Instance = Planting;

        _Planting.Instance.prototype.reset = reset;
        _Planting.Instance.prototype.step = step;
        _Planting.Instance.prototype.step_rotate = step_rotate;
        _Planting.Instance.prototype.step_placement = step_placement;

        _Planting.Instance.prototype.setup = setup;
        _Planting.Instance.prototype.start = start;
        _Planting.Instance.prototype.update = update;
        _Planting.Instance.prototype.complete = complete;
        _Planting.Instance.prototype.stop = stop;

        _Planting.Instance.prototype.get_planting_object_under_mouse = get_planting_object_under_mouse;

        _Planting.Instance.prototype.change_field = change_field;
        _Planting.Instance.prototype.change_module = change_module;
        _Planting.Instance.prototype.change_plant = change_plant;

        _Planting.Instance.prototype.start_rotate_plant = start_rotate_plant;
        _Planting.Instance.prototype.update_rotate_plant = update_rotate_plant;
        _Planting.Instance.prototype.stop_rotate_plant = stop_rotate_plant;

    }

    /*===================================================
    
    planting
    
    =====================================================*/

    function Planting(character) {

        // store character reference
        this.character = character;

        // properties
        this.rotationSpeed = _Planting.rotationSpeed;
        this.rotationDistanceMin = _Planting.rotationDistanceMin;
        this.rotationStartThreshold = _Planting.rotationStartThreshold;
        this.rotationDirChangeThreshold = _Planting.rotationDirChangeThreshold;

        // reset
        this.reset();

    }

    /*===================================================
	
	reset
	
	=====================================================*/

    function reset() {

        this.started = false;
        this.rotating = false;
        this.module = undefined;

    }

    /*===================================================
	
	target
	
	=====================================================*/

    function get_planting_object_under_mouse(parameters) {

        var i, l, field, grid, modules, plantingObjects = [],
            targetObject;

        // handle parameters
        parameters = parameters || {};

        // build array of objects that are involved in planting process
        if (parameters.modules !== false) {

            if (parameters.field === true && typeof this.field !== 'undefined') {

                plantingObjects = plantingObjects.concat(this.field.grid.modules);

            } else {

                plantingObjects = plantingObjects.concat(_Puzzle.allModules);

            }

        }

        if (parameters.character === true) {

            plantingObjects.push(this.character);

        }

        if (parameters.plants === true) {

            if (parameters.field === true && typeof this.field !== 'undefined') {

                plantingObjects = plantingObjects.concat(this.field.plants);

            } else {

                plantingObjects = plantingObjects.concat(_Planting.allPlants);

            }

        }

        // find if any planting objects under mouse
        targetObject = _Game.get_object_under_mouse(plantingObjects, false, this.mouse);

        return targetObject;

    }

    /*===================================================
	
	step
	
	=====================================================*/

    function step(parameters) {
        console.log(' > PLANTING: STEP');
        // handle parameters
        parameters = parameters || {};

        // store mouse
        this.mouse = main.get_mouse(parameters.event);

        // if step rotate
        if (parameters.rotate === true) {

            this.step_rotate(parameters);

        }
        // else step placement
        else {

            this.step_placement(parameters);

        }

    }

    function step_rotate(parameters) {

        // handle parameters
        parameters = parameters || {};

        console.log(' > PLANTING: rotation step');
        if (parameters.stop === true) {

            // stop
            this.stop_rotate_plant();

        } else if (this.started === true) {

            // start
            this.start_rotate_plant();

        }

    }

    function step_placement(parameters) {

        var wasRotated;

        // handle parameters
        parameters = parameters || {};

        console.log(' > PLANTING: placement step, parameters', parameters, ' + is stop? ', parameters.stop);
        if (parameters.stop === true) {

            this.stop();

        } else {

            // if is rotating
            if (this.rotating === true) {

                // record if rotated
                wasRotated = this.rotation.rotated;

                // stop rotating
                this.step_rotate({
                    stop: true
                });

            }

            // if was not just rotated
            if (wasRotated !== true) {

                // steps
                // if has plant
                if (this.plant instanceof _Plant.Instance) {

                    console.log(' > PLANTING: step has plant: ', this.plant);

                    this.complete();

                }
                // if needs plant
                else {

                    console.log(' > PLANTING: step no plant yet!');

                    this.setup(parameters);

                }

            }

        }

    }

    /*===================================================
	
	setup / start / continue / complete / stop
	
	=====================================================*/

    function setup(parameters) {

        var targetObject;

        // if passed plant to use
        if (parameters && parameters.plant) {

            if (parameters.plant instanceof _Plant.Instance) {

                targetObject = parameters.plant;

            } else {

                targetObject = new _Plant.Instance(parameters.plant);

            }

        }
        // else if any plants under mouse
        else {

            targetObject = this.get_planting_object_under_mouse({
                modules: false,
                character: false,
                plants: true
            });

        }

        // if is a plant
        if (targetObject instanceof _Plant.Instance) {

            // use plant
            this.change_plant(targetObject);

        }

    }

    function start() {

        // if has not started planting and plant is valid
        if (this.started !== true && this.plant instanceof _Plant.Instance) {
            console.log('start PLANTING!');

            // set started
            this.started = true;

            // dim ui to focus on planting
            _GUI.layers.ui.hide({
                opacity: 0.25,
                callback: function () {
                    _GUI.layers.ui.set_pointer_events(false, true);
                }
            });

            // start updating planting
            this.update();

            shared.signals.mousemoved.add(this.update, this);

        }

    }

    function update(skipRotate) {
        console.log(' > PLANTING: update planting!');
        var targetObject;

        // if has plant, update seed position
        if (this.plant instanceof _Plant.Instance) {

            this.plant.seed.x = this.mouse.x - this.plant.seed.outerWidthHalf;
            this.plant.seed.y = this.mouse.y - this.plant.seed.outerHeightHalf;

        }

        // if rotating
        if (skipRotate !== true && this.rotating === true) {

            this.update_rotate_plant();

        }
        // else regular update
        else {

            // find if any planting objects under mouse
            targetObject = this.get_planting_object_under_mouse({
                modules: true
            });

            // change to new module
            this.change_module(targetObject);

        }

    }

    function complete() {
        console.log(' > PLANTING: completing...');
        var targetObject, plantSuccessful = false;

        // find if any planting objects under mouse
        targetObject = this.get_planting_object_under_mouse({
            modules: true
        });

        // if target is valid
        if (targetObject instanceof _GridModule.Instance) {

            // if target and current module do not match
            if (this.module !== targetObject) {

                // change module
                this.change_module(targetObject);

            }

            // try adding plant
            plantSuccessful = this.plant.occupy_module(this.module);

            // stop on success, else continue
            if (plantSuccessful) {
                console.log(' > PLANTING: plant added!', this.plant);
                this.stop();

            } else {

                console.log(' > PLANTING: plant does not fit!', this.plant);

            }

        } else {

            // stop planting
            this.stop();

        }

    }

    function stop() {
        console.log('stop PLANTING!');

        // stop updating
        shared.signals.mousemoved.remove(this.update, this);

        // stop
        this.started = false;

        // stop rotating
        this.step_rotate({
            stop: true
        });

        // clear plant
        this.change_plant();

        // clear module / field
        this.change_module();

        // return ui to normal state
        _GUI.layers.ui.show();
        _GUI.layers.ui.set_pointer_events(false);

    }

    /*===================================================
	
	planting changes
	
	=====================================================*/

    function change_field(field) {

        // if new field
        if (this.field !== field) {

            // clear previous field grid
            if (this.field instanceof _Field.Instance) {

                this.field.grid.clean();

            }

            // store new field
            this.field = field;

        }

    }

    function change_module(target) {

        var module, grid, field;

        // if target is module
        if (target instanceof _GridModule.Instance) {

            module = target;

        }

        // if is new module
        if (this.module !== module) {
            console.log(' > PLANTING: change MODULE: ', module);

            // store new module
            this.module = module;

            // if valid module
            if (module instanceof _GridModule.Instance) {

                // get grid
                grid = module.grid;

                // get field
                field = module.puzzle;

                console.log(' > PLANTING: intersected module is', module, ', with ', module.connectedList.length, ' connected modules', module.connected);

            }

            // change field
            this.change_field(field);

        }

        // test module
        if (this.plant instanceof _Plant.Instance) {

            this.plant.test_occupy_module(module, true);

        }

    }

    function change_plant(plantNew) {

        var index;

        // if new plant is different from one stored in planting
        if (this.plant !== plantNew) {

            // remove last plant
            if (this.plant instanceof _Plant.Instance) {

                // clear last test
                this.plant.test_occupy_module();

                // find if in all plants list
                index = _Planting.allPlants.indexOf(this.plant);

                // if planted
                if (this.plant.planted === true) {

                    // store in all plants list
                    if (index === -1) {

                        _Planting.allPlants.push(this.plant);

                    }

                } else {

                    // ensure plant is uprooted
                    this.plant.uproot();

                    // remove from all plants list
                    if (index !== -1) {

                        _Planting.allPlants.splice(index, 1);

                    }

                }

                // hide seed
                this.plant.seed.hide({
                    remove: true,
                    time: 0
                });

                // cursor
                _GUI.container.apply_css('cursor', 'auto');

            }

            // store new plant
            this.plant = plantNew;
            console.log(' > PLANTING: plant to', this.plant);

            // if new plant
            if (this.plant instanceof _Plant.Instance) {

                // if currently planted
                if (this.plant.planted === true) {

                    // uproot
                    this.plant.uproot();

                }

                // show seed
                this.plant.seed.show({
                    parent: _GUI.layers.uiPriority
                });

                // cursor
                _GUI.container.apply_css('cursor', 'pointer');

                // start planting
                this.start();

            }

        }

    }

    /*===================================================
	
	plant rotation
	
	=====================================================*/

    function start_rotate_plant() {

        var position = utilVec31Rotate,
            projector = utilProjector1Rotate,
            r;

        if (this.rotating !== true && this.module instanceof _GridModule.Instance) {
            console.log(' > PLANTING: rotation START ');
            // rotate start
            this.rotating = true;

            // init rotation info
            r = this.rotation = {};

            position.copy(this.plant.matrixWorld.getPosition());
            position = projector.projectVector(position, _Game.camera);

            r.x0 = ((position.x + 1) * shared.screenWidth) * 0.5;
            r.y0 = ((-position.y + 1) * shared.screenHeight) * 0.5;

            r.angleTotal = 0;
            r.x1 = r.x2 = r.y1 = r.y2 = undefined;
            r.rotated = false;

        }

    }

    function update_rotate_plant() {

        var plant = this.plant,
            r = this.rotation,
            mouse = this.mouse,
            mx = mouse.x,
            my = mouse.y,
            mDist = Math.sqrt(Math.pow(mouse.x - r.x0, 2) + Math.pow(mouse.y - r.y0, 2)),
            ax, ay, bx, by, angleA, angleB, radians;

        // keep track of last 2 locations
        r.x2 = r.x1;
        r.x1 = mouse.x;

        r.y2 = r.y1;
        r.y1 = mouse.y;

        // if has 3 numbers to work with, and mouse is at least minimum distance from rotation point
        if (main.is_number(r.x2) && mDist >= this.rotationDistanceMin) {

            // handle direction
            ax = r.x0 - r.x1;
            ay = r.y0 - r.y1;
            bx = r.x0 - r.x2;
            by = r.y0 - r.y2;

            angleA = Math.atan2(ay, ax);
            angleB = Math.atan2(by, bx);

            radians = angleA - angleB;

            // totals
            r.angleTotal += radians;

            // if rotation above threshold
            if (r.rotated === true || Math.abs(r.angleTotal) >= this.rotationStartThreshold) {

                // rotate plant
                plant.rotate(radians, this.module);

                // if rotator needed
                if (r.rotated !== true) {

                    // hide seed temporarily
                    this.plant.seed.hide({
                        remove: true,
                        time: 0
                    });

                    // rotator
                    this.plant.rotator.show({
                        parent: _GUI.layers.uiPriority
                    });

                    this.plant.rotator.set_position(r.x0 - this.plant.rotator.widthHalf, r.y0 - this.plant.rotator.heightHalf);

                }

                // set rotated
                r.rotated = true;

            }

        }

    }

    function stop_rotate_plant() {


        if (this.rotating !== false) {
            console.log(' > PLANTING: rotation STOP ');
            this.plant.seed.show({
                parent: _GUI.layers.uiPriority
            });

            this.plant.rotator.hide({
                remove: true
            });

            this.rotating = false;

            this.plant.rotate_reset();

        }

    }

}(KAIOPUA));

/*
 *
 * Grid.js
 * Creates grids for use in puzzles.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/puzzles/Grid.js",
        _Grid = {},
        _Model, _GridModule, _GridElement, _ObjectHelper, _MathHelper, idStateMaterialBase = 'base',
        utilVec31Vertex, utilVec32Vertex, utilVec33Vertex, utilVec34Vertex, utilMat41Vertex, utilMat42Vertex;

    /*===================================================
	
	public
	
	=====================================================*/

    main.asset_register(assetPath, {
        data: _Grid,
        requirements: ["assets/modules/core/Model.js", "assets/modules/puzzles/GridModule.js", "assets/modules/puzzles/GridElement.js", "assets/modules/utils/ObjectHelper.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
	
	init
	
	=====================================================*/

    function init_internal(m, gm, ge, oh, mh) {
        console.log("internal grid", _Grid);

        _Model = m;
        _GridModule = gm;
        _GridElement = ge;
        _ObjectHelper = oh;
        _MathHelper = mh;

        utilVec31Vertex = new THREE.Vector3();
        utilVec32Vertex = new THREE.Vector3();
        utilVec33Vertex = new THREE.Vector3();
        utilVec34Vertex = new THREE.Vector3();
        utilMat41Vertex = new THREE.Matrix4();
        utilMat42Vertex = new THREE.Matrix4();

        // grid
        _Grid.Instance = Grid;
        _Grid.Instance.prototype = new _Model.Instance();
        _Grid.Instance.prototype.constructor = _Grid.Instance;
        _Grid.Instance.prototype.each_module = each_module;
        _Grid.Instance.prototype.modify_modules = modify_modules;
        _Grid.Instance.prototype.add_modules = add_modules;
        _Grid.Instance.prototype.add_module = add_module;
        _Grid.Instance.prototype.remove_modules = remove_modules;
        _Grid.Instance.prototype.remove_module = remove_module;
        _Grid.Instance.prototype.get_modules_with_vertices = get_modules_with_vertices;
        _Grid.Instance.prototype.module_occupation_changed = module_occupation_changed;
        _Grid.Instance.prototype.clean = clean;

        // get / set
        Object.defineProperty(_Grid.Instance.prototype, 'puzzle', {
            get: function () {
                return this._puzzle;
            },
            set: function (puzzle) {

                this._puzzle = puzzle;

            }
        });

        Object.defineProperty(_Grid.Instance.prototype, 'isFull', {
            get: function () {

                var i, l, full = true,
                    module;

                // for each module
                for (i = 0, l = this.modules.length; i < l; i++) {

                    module = this.modules[i];

                    if (!(module.occupant instanceof _GridElement.Instance)) {

                        full = false;
                        break;

                    }

                }

                return full;

            }
        });

        Object.defineProperty(_Grid.Instance.prototype, 'elements', {
            get: function () {

                var i, l, module, element, elements = [];

                // find all elements occupying grid
                for (i = 0, l = this.modules.length; i < l; i++) {

                    module = this.modules[i];

                    element = module.occupant;

                    if (element instanceof _GridElement.Instance && elements.indexOf(element) === -1) {

                        elements.push(element);

                    }

                }

                return elements;

            }
        });

    }

    /*===================================================
	
	grid
	
	=====================================================*/

    function Grid(parameters) {

        var i, l, psm, faces, face, faceCopy, vertices, verticesFromFace, moduleGeometry, module;

        // handle parameters
        parameters = parameters || {};

        parameters.center = true;

        // prototype constructor
        _Model.Instance.call(this, parameters);

        // properties
        this.vertexDistanceMergeLimit = main.is_number(parameters.vertexDistanceMergeLimit) ? parameters.vertexDistanceMergeLimit : 5;

        // store puzzle reference
        this.puzzle = parameters.puzzle;

        // signal
        this.stateChanged = new signals.Signal();

        // init modules
        this.modules = [];

        // if parameters passed modules as string
        if (typeof parameters.modulesGeometry === 'string') {

            parameters.modulesGeometry = main.get_asset_data(parameters.modulesGeometry);

        }

        // if parameters passed modules as geometry
        if (parameters.modulesGeometry instanceof THREE.Geometry) {

            // store original modules geometry
            this.modulesGeometry = parameters.modulesGeometry;

            // create new module for each face
            faces = this.modulesGeometry.faces;

            vertices = this.modulesGeometry.vertices;

            for (i = 0, l = faces.length; i < l; i++) {

                face = faces[i];

                // copy geometry references
                // keeps actual faces/vertices centralized with grid
                moduleGeometry = new THREE.Geometry();

                // vertices
                moduleGeometry.vertices.push(vertices[face.a].clone());
                moduleGeometry.vertices.push(vertices[face.b].clone());
                moduleGeometry.vertices.push(vertices[face.c].clone());

                // face
                faceCopy = face.clone();
                faceCopy.a = 0;
                faceCopy.b = 1;
                faceCopy.c = 2;

                moduleGeometry.faces.push(faceCopy);

                // extras for face4
                if (face instanceof THREE.Face4) {

                    moduleGeometry.vertices.push(vertices[face.d].clone());

                    faceCopy.d = 3;

                }

                // init
                module = new _GridModule.Instance({
                    geometry: moduleGeometry
                });

                // store
                this.add_module(module);

            }

            // set grid for all modules to calculate all connected modules
            for (i = 0, l = this.modules.length; i < l; i++) {

                module = this.modules[i];

                module.grid = this;

                // listen for signal
                module.occupiedStateChanged.add(this.module_occupation_changed, this);

            }

        }

    }

    /*===================================================
	
	modules
	
	=====================================================*/

    function each_module(methods, modulesExcluding) {

        var i, l, j, k, module, method;

        // handle parameters
        methods = main.ensure_array(methods);

        modulesExcluding = main.ensure_array(modulesExcluding);

        // for each module
        for (i = 0, l = this.modules.length; i < l; i++) {

            module = this.modules[i];

            // if not to be excluded
            if (modulesExcluding.indexOf(module) === -1) {

                // for each method
                for (j = 0, k = methods.length; j < k; j++) {

                    method = methods[j];

                    // call method in context of module
                    method.call(module);

                }

            }

        }

    }

    function modify_modules(modules, remove) {

        var i, l, module, index;

        if (typeof modules !== 'undefined') {

            modules = main.ensure_array(modules);

            // for each module
            for (i = 0, l = modules.length; i < l; i++) {

                module = modules[i];

                // if should remove
                if (remove === true) {

                    this.remove_module(module);

                }
                // base to add
                else {

                    this.add_module(module);

                }

            }

        }

    }

    function add_modules(modules) {

        this.modify_modules(modules);

    }

    function remove_modules(modules) {

        this.modify_modules(modules, true);

    }

    function add_module(module) {

        var index;

        if (module instanceof _GridModule.Instance) {

            // store module
            index = this.modules.indexOf(module);

            if (index === -1) {

                this.modules.push(module);

            }

            // add module to grid
            this.add(module);

        }

    }

    function remove_module(module) {

        var i, l, j, k, modulePotential, removing, moduleRemove, index;

        if (module instanceof _GridModule.Instance) {

            // init removing list
            removing = [];

            // search all potential modules and remove matches
            for (i = this.modules.length - 1, l = 0; i >= l; i--) {

                modulePotential = this.modules[i];

                if (modulePotential === module) {

                    // remove from this list
                    removing.push(this.modules.splice(i, 1)[0]);

                }

            }

            // for all removing
            for (i = 0, l = removing.length; i < l; i++) {

                moduleRemove = removing[i];

                // check for connections and set connected dirty flag
                for (j = 0, k = this.modules.length; j < k; j++) {

                    module = this.modules[j];

                    index = module.connected.indexOf(moduleRemove);

                    if (index !== -1) {

                        module.dirtyConnected = true;

                    }

                }

                // remove from grid
                this.remove(moduleRemove);

            }

        }

    }

    function get_modules_with_vertices(searchVertices, searchFrom, modulesExcluding, modulesMatching) {

        var i, l, j, k, n, m, searchVertex, searchVertexPosition = utilVec31Vertex,
            searchFromMatrix = utilMat41Vertex,
            searchPosition = utilVec32Vertex,
            searchScale = 1,
            searchRadius = 0,
            searchMatches, module, moduleScale, moduleRadius, moduleMatrix = utilMat42Vertex,
            modulePosition = utilVec33Vertex,
            vertices, vertex, position = utilVec34Vertex,
            distance;

        // handle arguments
        searchVertices = main.ensure_array(searchVertices);

        modulesExcluding = main.ensure_array(modulesExcluding);

        modulesMatching = main.ensure_array(modulesMatching);

        // find search matrix world
        if (searchFrom instanceof THREE.Matrix4) {

            searchFromMatrix.copy(searchFrom);

        } else if (searchFrom instanceof THREE.Object3D) {

            searchFromMatrix.copy(searchFrom.matrixWorld);

            searchRadius += searchFrom.geometry.boundingSphere.radius;

            searchScale = Math.max(searchFromMatrix.getColumnX().length(), searchFromMatrix.getColumnY().length(), searchFromMatrix.getColumnZ().length());

        } else {

            searchFromMatrix.identity();

        }

        // set search position
        searchPosition.copy(searchFromMatrix.getPosition());

        // set search radius
        searchRadius = searchRadius * searchScale + this.vertexDistanceMergeLimit;

        // search each module
        for (i = 0, l = this.modules.length; i < l; i++) {

            module = this.modules[i];

            // if module not matched or excluded
            if (modulesMatching.indexOf(module) === -1 && modulesExcluding.indexOf(module) === -1) {

                // get module matrix world
                moduleMatrix.copy(module.matrixWorld);

                // get module position
                modulePosition.copy(moduleMatrix.getPosition());

                // distance from search to module 
                distance = searchPosition.distanceTo(modulePosition);

                // module radius
                moduleRadius = module.geometry.boundingSphere.radius * Math.max(moduleMatrix.getColumnX().length(), moduleMatrix.getColumnY().length(), moduleMatrix.getColumnZ().length());

                if (searchRadius + moduleRadius >= distance) {

                    vertices = module.geometry.vertices;

                    searchMatches = [];

                    for (j = 0, k = searchVertices.length; j < k; j++) {

                        searchVertex = searchVertices[j];

                        searchVertexPosition.copy(searchVertex.position);

                        searchFromMatrix.multiplyVector3(searchVertexPosition);

                        // for each vertex in module
                        for (n = 0, m = vertices.length; n < m; n++) {

                            vertex = vertices[n];

                            position.copy(vertex.position);

                            moduleMatrix.multiplyVector3(position);

                            // find distance between search and position 
                            distance = searchVertexPosition.distanceTo(position);

                            // if distance between positions is less than or equal to merge limit
                            if (distance <= this.vertexDistanceMergeLimit) {

                                searchMatches.push(1);

                                break;

                            }

                        }

                        if (searchMatches.length === searchVertices.length) {

                            modulesMatching.push(module);

                            break;

                        }

                    }

                }

            }

        }

        return modulesMatching;

    }

    /*===================================================
	
	change
	
	=====================================================*/

    function module_occupation_changed(module) {
        console.log('grid state change');
        this.stateChanged.dispatch(this);

    }

    /*===================================================
	
	cleaning
	
	=====================================================*/

    function clean(modulesExcluding, force) {

        // if dirty
        if (this._dirtyModules !== false || force === true) {

            this.each_module(function () {

                this.show_state(false);

            }, modulesExcluding);

            this._dirtyModules = false;

        }

    }

}(KAIOPUA));

/*
 *
 * GridElement.js
 * Basic element of puzzle solving.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/puzzles/GridElement.js",
        _GridElement = {},
        _Model, _GridModule, _ObjectHelper, _MathHelper, rotationAxis, utilQ1Rotate;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _GridElement,
        requirements: ["assets/modules/core/Model.js", "assets/modules/puzzles/GridModule.js", "assets/modules/utils/ObjectHelper.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(m, gm, oh, mh) {
        console.log('internal grid element', _GridElement);

        _Model = m;
        _GridModule = gm;
        _ObjectHelper = oh;
        _MathHelper = mh;

        // utils
        utilQ1Rotate = new THREE.Quaternion();

        // properties
        rotationAxis = new THREE.Vector3(0, 1, 0);

        // instance
        _GridElement.Instance = GridElement;
        _GridElement.Instance.prototype = new _Model.Instance();
        _GridElement.Instance.prototype.constructor = _GridElement.Instance;

        _GridElement.Instance.prototype.rotate = rotate;
        _GridElement.Instance.prototype.rotate_reset = rotate_reset;
        _GridElement.Instance.prototype.rotate_layout = rotate_layout;

        _GridElement.Instance.prototype.change_module = change_module;

        _GridElement.Instance.prototype.update = update;

        _GridElement.Instance.prototype.occupy_module = occupy_module;
        _GridElement.Instance.prototype.test_occupy_module = test_occupy_module;
        _GridElement.Instance.prototype.each_layout_element = _GridElement.each_layout_element = each_layout_element;

        _GridElement.Instance.prototype.get_layout_node_total = get_layout_node_total
        _GridElement.Instance.prototype.get_layout_center_location = get_layout_center_location;
        _GridElement.Instance.prototype.get_layout_center_offset = get_layout_center_offset;

    }

    /*===================================================
    
    grid element
    
    =====================================================*/

    function GridElement(parameters) {

        // handle parameters
        parameters = parameters || {};

        parameters.geometry = parameters.geometry || new THREE.CubeGeometry(50, 100, 50);
        parameters.materials = parameters.materials || new THREE.MeshLambertMaterial({
            color: 0xffffff,
            ambient: 0xffffff,
            vertexColors: THREE.VertexColors
        });

        // prototype constructor
        _Model.Instance.call(this, parameters);

        // properties
        this.rotationAngle = this.rotationAngleLayout = 0;

        // layout
        this.layout = generate_layout(parameters.layout);

        // modules layout
        this.layoutModules = this.layout.dup();
    }

    /*===================================================
    
    layout
    
    =====================================================*/

    function generate_layout(source) {

        var layout;

        // generate layout as matrix from source
        if (source instanceof Matrix) {

            layout = source;

        } else if (main.is_array(source)) {

            layout = $M(source);

        }

        // if layout is not valid, fallback to default 1x1
        if (layout instanceof Matrix !== true) {

            layout = $M([
                [1]
                ]);
            /*
			layout = $M( [
				[ 0, 0, 0 ],
				[ 0, 1, 0 ],
				[ 0, 0, 0 ]
			] );
			*/
            /*
			layout = $M( [
				[ 0, 1, 1, 0, 0 ],
				[ 0, 0, 0, 1, 0 ],
				[ 0, 0, 1, 0, 0 ],
				[ 0, 0, 1, 0, 0 ],
				[ 0, 0, 0, 0, 0 ]
			] );
			*/
            /*layout = $M( [
				[ Math.round( Math.random() ), Math.round( Math.random() ), Math.round( Math.random() ) ],
				[ Math.round( Math.random() ), Math.round( Math.random() ), Math.round( Math.random() ) ],
				[ Math.round( Math.random() ), Math.round( Math.random() ), Math.round( Math.random() ) ]
			] );*/

        }

        // clamp layout values between 0 and 1, and force all non-zero to snap to 1
        layout = layout.map(function (x) {
            return Math.ceil(_MathHelper.clamp(x, 0, 1));
        });

        return layout;

    }

    /*===================================================
    
    rotation
    
    =====================================================*/

    function rotate(radians, testModule) {

        var q = utilQ1Rotate,
            angle;

        // add degrees
        this.rotationAngle = (this.rotationAngle + radians) % (Math.PI * 2);

        // rotate self
        // modify degrees based on cardinal right axis
        angle = shared.cardinalAxes.right.x * radians;
        q.setFromAxisAngle(rotationAxis, angle);

        this.quaternion.multiplySelf(q);

        // rotate layout
        this.rotate_layout(this.rotationAngle, testModule);

    }

    function rotate_reset() {

        var angle;

        // if is not a 1x1 layout
        // snap self back to last layout rotation angle
        if (this.get_layout_node_total() > 1) {

            this.rotationAngle = this.rotationAngleLayout;

            angle = shared.cardinalAxes.right.x * this.rotationAngle;

            this.quaternion.setFromAxisAngle(rotationAxis, angle);

        }

    }

    function rotate_layout(angle, testModule) {

        var angleDelta = angle - this.rotationAngleLayout,
            layoutRotated, safeRotation = true;

        // rotate layout by angleDelta
        layoutRotated = _MathHelper.rotate_matrix2d_90(this.layout, angleDelta);

        // if layout was rotated
        if (this.layout.eql(layoutRotated) !== true) {

            // test new layout
            testModule = testModule || this.module;

            if (testModule instanceof _GridModule.Instance) {

                safeRotation = this.test_occupy_module(testModule, true, false, layoutRotated);

            }

            // if rotation is safe or only testing
            if (safeRotation || testModule !== this.module) {

                this.rotationAngleLayout = angle;

                this.layout = layoutRotated;

            }

        }

    }

    /*===================================================
    
    module
    
    =====================================================*/

    function change_module(moduleNew, layoutModulesNew) {

        // if is change
        if (this.module !== moduleNew) {

            // remove self from previous
            if (typeof this.parent !== 'undefined') {

                this.parent.remove(this);

            }

            // for each module in previous layout modules
            if (typeof this.layoutModules !== 'undefined') {

                // unoccupy
                this.each_layout_element(function (layoutModule) {

                    if (layoutModule instanceof _GridModule.Instance) {

                        layoutModule.occupant = undefined;

                    }

                }, this.layoutModules);

            }

            // store
            this.module = moduleNew;

            this.layoutModules = layoutModulesNew;

            // if new module and layouts are valid
            if (this.module instanceof _GridModule.Instance && typeof this.layoutModules !== 'undefined') {

                // add
                this.module.add(this);

                // for each module in layout modules set this as occupant
                this.each_layout_element(function (layoutModule) {

                    if (layoutModule instanceof _GridModule.Instance) {

                        layoutModule.occupant = this;

                    }

                }, this.layoutModules);

            }

        }

    }

    function occupy_module(module) {

        var occupied = this.test_occupy_module(module, true, true);

        return occupied;

    }

    function test_occupy_module(testModule, show, occupy, testLayout) {

        var i, l, success = 0,
            dimensions, rows, cols, center, testResults, spreadRecord, testLayoutModules, moduleDimensions, modulesWidthTotal = 0,
            modulesDepthTotal = 0,
            modulesCount = 0,
            avgModuleWidth, avgModuleDepth;

        // change test modules
        if (this.testModule !== testModule) {

            // remove self from current parent
            if (typeof this.parent !== 'undefined') {

                // if has module, add this to it
                if (this.module instanceof _GridModule.Instance) {

                    this.module.add(this);

                }
                // otherwise just remove 
                else {

                    this.parent.remove(this);

                }

            }

            // store as test
            this.testModule = testModule;

        }

        // valid testModule
        if (typeof testModule !== 'undefined') {

            // add to test module
            if (this.parent !== testModule) {

                testModule.add(this);

            }

            // clean testModule's grid
            if (typeof testModule.grid !== 'undefined') {

                testModule.grid.clean();

            }

            // basics
            testLayout = testLayout || this.layout;
            dimensions = this.layout.dimensions();
            rows = dimensions.rows;
            cols = dimensions.cols;
            center = this.get_layout_center_location();
            testResults = Matrix.Zero(rows, cols);
            spreadRecord = testResults.dup();
            testLayoutModules = testResults.dup();

            // return recursive test results
            success = test_spread(testModule, testLayout, testResults, spreadRecord, center.row, center.col, rows, cols, testLayoutModules);

            // show test results of occupy on modules tested
            if (show === true) {

                this.each_layout_element(function (testLayoutModule) {

                    if (testLayoutModule instanceof _GridModule.Instance) {

                        testLayoutModule.show_state('occupied', 1 - success);
                        /*
						moduleDimensions = _ObjectHelper.dimensions( testLayoutModule );
						console.log( 'TESTED MODULE' );
						console.log( 'moduleDimensions', moduleDimensions.x.toFixed(3), moduleDimensions.y.toFixed(3), moduleDimensions.z.toFixed(3) );
						console.log( 'module Q', testLayoutModule.quaternion.x.toFixed(3), testLayoutModule.quaternion.y.toFixed(3), testLayoutModule.quaternion.z.toFixed(3), testLayoutModule.quaternion.w.toFixed(3) );
						var mqworld = new THREE.Quaternion().setFromRotationMatrix( testLayoutModule.matrixWorld );
						console.log( 'module Q world', mqworld.x.toFixed(3), mqworld.y.toFixed(3), mqworld.z.toFixed(3), mqworld.w.toFixed(3) );
						modulesWidthTotal += moduleDimensions.x;
						modulesDepthTotal += moduleDimensions.z;
						modulesCount++;
						*/
                    }

                }, testLayoutModules);
                /*
				// offset self
				// based on size of modules tested
				// and the center offset of own layout
				
				// average module size
				
				avgModuleWidth = modulesWidthTotal / modulesCount;
				avgModuleDepth = modulesDepthTotal / modulesCount;
				
				// center offset of layout
				
				var layoutCenterOffset = this.get_layout_center_offset();
				
				console.log( 'avgModuleWidth', avgModuleWidth, 'avgModuleDepth', avgModuleDepth );
				console.log(' get_layout_center_offset: ', layoutCenterOffset.row.toFixed(3), layoutCenterOffset.col.toFixed(3) );
				
				//this.position.x += avgModuleWidth * ( layoutCenterOffset.row - 1 );
				//this.position.z += avgModuleDepth * ( layoutCenterOffset.col - 1 );
				console.log( ' new pos ', this.position.x.toFixed(2), this.position.y.toFixed(2), this.position.z.toFixed(2) );
				console.log( ' new Q ', this.quaternion.x.toFixed(3), this.quaternion.y.toFixed(3), this.quaternion.z.toFixed(3), this.quaternion.w.toFixed(3) );
				*/
            }

            // if successful and should occupy
            if (success && occupy === true) {

                this.change_module(testModule, testLayoutModules);

            }

        }

        return Boolean(success);

    }

    function test_spread(testModule, testLayout, testResults, spreadRecord, rowIndex, colIndex, numRows, numCols, testLayoutModules) {

        var i, l, j, k, success = 1,
            successNext, connected, moduleNext, index, elements = testLayout.elements,
            elementsTR = testResults.elements,
            elementsSR = spreadRecord.elements,
            element, rowNext, rowArr = Math.max(0, rowIndex - 1),
            rowMin, rowIndexToMin, rowMax, rowsSq, colNext, colArr = Math.max(0, colIndex - 1),
            colMin, colIndexToMin, colMax, colsSq;

        // update spread record
        elementsSR[rowArr][colArr] = 1;

        // test element
        element = elements[rowArr][colArr];

        // if layout element present
        if (element === 1) {

            // if testModule is valid
            if (testModule instanceof _GridModule.Instance) {

                // test success
                success = 1 - testModule.occupied;

                // add testModule to layout map
                testLayoutModules.elements[rowArr][colArr] = testModule;

            }
            // no module where needed
            else {

                success = 0;

            }

            // store success
            elementsTR[rowArr][colArr] = success;

        }

        // if testModule is valid
        if (testModule instanceof _GridModule.Instance) {

            // get square around testModule in layout
            rowMin = Math.max(1, rowArr);
            rowIndexToMin = rowIndex - rowMin;
            rowMax = Math.min(numRows, rowIndex + 1);
            rowsSq = Math.min(numRows, rowMax - rowMin + 1);
            colMin = Math.max(1, colArr);
            colIndexToMin = colIndex - colMin;
            colMax = Math.min(numCols, colIndex + 1);
            colsSq = Math.min(numCols, colMax - colMin + 1);

            // spread to all connected modules
            // continue even if unsuccessful to record all modules affected by layout
            connected = testModule.connected;

            for (i = 0, l = rowsSq; i < l; i++) {

                for (j = 0, k = colsSq; j < k; j++) {

                    rowNext = rowMin + i;
                    colNext = colMin + j;

                    // get next testModule
                    moduleNext = connected[((i + (1 - rowIndexToMin)) * 3 + (j + (1 - colIndexToMin)))];

                    // if testModule location not tested yet
                    if (spreadRecord.e(rowNext, colNext) !== 1) {

                        successNext = test_spread(moduleNext, testLayout, testResults, spreadRecord, rowNext, colNext, numRows, numCols, testLayoutModules);

                        // record next success while successful
                        if (success) {
                            success = successNext;
                        }

                    }

                }

            }

        }

        return success;

    }

    /*===================================================
    
    update
    
    =====================================================*/

    function update() {

    }

    /*===================================================
    
    utility
    
    =====================================================*/

    function each_layout_element(methods, layout) {

        layout = layout || this.layout;

        var i, il, j, jl, m, ml, elements = layout.elements,
            row, node, method;

        // handle parameters
        methods = main.ensure_array(methods);

        // for each row
        for (i = 0, il = elements.length; i < il; i++) {

            row = elements[i];

            // for each column
            for (j = 0, jl = row.length; j < jl; j++) {

                node = row[j];

                // for each node
                for (m = 0, ml = methods.length; m < ml; m++) {

                    method = methods[m];

                    // call method and pass node and row and column indices
                    method.call(this, node, i, j);

                }

            }

        }

    }

    function get_layout_node_total(layout) {

        layout = layout || this.layout;

        var nodeTotal = 0;

        this.each_layout_element(function (node) {

            if (node > 0) {

                nodeTotal += node;

            }

        }, layout);

        return nodeTotal;

    }

    function get_layout_center_location(layout) {

        layout = layout || this.layout;

        var dimensions = layout.dimensions(),
            centerRow = Math.ceil(dimensions.rows * 0.5),
            centerCol = Math.ceil(dimensions.cols * 0.5);

        return {
            row: centerRow,
            col: centerCol
        };

    }

    function get_layout_center_offset(layout) {

        layout = layout || this.layout;

        var nodeTotal = 0,
            iTotal = 0,
            jTotal = 0;

        this.each_layout_element(function (node, i, j) {

            if (node > 0) {

                iTotal += i;
                jTotal += j;
                nodeTotal++;

            }

        }, layout);

        return {
            row: iTotal / nodeTotal,
            col: jTotal / nodeTotal
        };

    }

}(KAIOPUA));

/*
 *
 * GridModule.js
 * Single module of puzzle grids.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/puzzles/GridModule.js",
        _GridModule = {},
        _Model, _GridModuleState, states;

    /*===================================================
	
	public
	
	=====================================================*/

    main.asset_register(assetPath, {
        data: _GridModule,
        requirements: ["assets/modules/core/Model.js", "assets/modules/puzzles/GridModuleState.js", ],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
	
	init
	
	=====================================================*/

    function init_internal(m, gms) {
        console.log("internal grid module", _GridModule);
        _Model = m;
        _GridModuleState = gms;

        // properties
        _GridModule.colors = {};
        _GridModule.colors.base = new THREE.Color(0xe6b266);
        _GridModule.colors.vacant = new THREE.Color(0x0ccd6f);
        _GridModule.colors.occupied = new THREE.Color(0xff2830);

        // instance
        _GridModule.Instance = GridModule;
        _GridModule.Instance.prototype = new _Model.Instance();
        _GridModule.Instance.prototype.constructor = _GridModule.Instance;
        _GridModule.Instance.prototype.reset = reset;
        _GridModule.Instance.prototype.set_dirty = set_dirty;

        _GridModule.Instance.prototype.change_state = change_state;
        _GridModule.Instance.prototype.show_state = show_state;
        _GridModule.Instance.prototype.get_state = get_state;

        _GridModule.Instance.prototype.set_occupant = set_occupant;

        _GridModule.Instance.prototype.has_face_or_vertex = has_face_or_vertex;
        _GridModule.Instance.prototype.get_modules_connected = get_modules_connected;
        _GridModule.Instance.prototype.find_and_store_connected = find_and_store_connected;

        _GridModule.Instance.prototype.remove = function (object) {

            _Model.Instance.prototype.remove.call(this, object);

            // if is occupant, clear
            if (this.occupant === object) {

                this.occupant = undefined;

            }

            // clean grid
            if (typeof this.grid !== 'undefined') {

                this.grid.clean();

            }

        };

        Object.defineProperty(_GridModule.Instance.prototype, 'connected', {
            get: function () {

                if (this._dirtyConnected !== false) {

                    this.get_modules_connected();

                }

                return this._connected;

            }
        });

        Object.defineProperty(_GridModule.Instance.prototype, 'connectedList', {
            get: function () {

                if (this._dirtyConnected !== false) {

                    this.get_modules_connected();

                }

                return this._connectedList;

            }
        });

        Object.defineProperty(_GridModule.Instance.prototype, 'grid', {
            get: function () {
                return this._grid;
            },
            set: function (grid) {

                this._grid = grid;

                this._dirtyConnected = true;

            }
        });

        Object.defineProperty(_GridModule.Instance.prototype, 'occupant', {
            get: function () {
                return this._occupant;
            },
            set: function (occupant) {
                this.set_occupant(occupant);
            }
        });

        Object.defineProperty(_GridModule.Instance.prototype, 'occupied', {
            get: function () {
                return typeof this.occupant !== 'undefined';
            }
        });

    }

    /*===================================================
	
	grid modules
	
	=====================================================*/

    function GridModule(parameters) {

        // handle parameters
        parameters = parameters || {};

        parameters.materials = new THREE.MeshLambertMaterial();

        parameters.center = true;

        parameters.centerRotation = true;

        // prototype constructor
        _Model.Instance.call(this, parameters);

        // store grid reference
        this.grid = parameters.grid;

        // signals
        this.stateChanged = new signals.Signal();
        this.occupiedStateChanged = new signals.Signal();

        // states
        this.states = {};
        this.states.list = ['base', 'occupied', 'water'];

        this.states.overdraw = false;

        this.states.base = new _GridModuleState.Instance({
            active: 1,
            dynamic: false,
            color: _GridModule.colors.base,
            ambient: _GridModule.colors.base
        });
        this.states.water = new _GridModuleState.Instance({
            priority: 1,
            color: 0x17DAF8,
            ambient: 0x17DAF8
        });
        this.states.occupied = new _GridModuleState.Instance({
            constant: false,
            color0: _GridModule.colors.vacant,
            ambient0: _GridModule.colors.vacant,
            color1: _GridModule.colors.occupied,
            ambient1: _GridModule.colors.occupied
        });

        // set to base state
        this.reset();

    }

    function reset() {

        var states = this.states,
            statesList = states.list;

        // reset active for each state in states list
        this.change_state(statesList, false);

        // clear occupant
        this.occupant = undefined;

    }

    /*===================================================
	
	states
	
	=====================================================*/

    function set_dirty() {

        this._dirtyStates = true;

        if (typeof this.grid !== 'undefined') {

            this.grid._dirtyModules = true;

        }
    }

    function change_state(ids, activates) {

        var i, l, k, id, activate, state, activePrev;

        // for each id
        ids = main.ensure_array(ids);

        activates = main.ensure_array(activates);

        for (i = 0, l = ids.length, k = activates.length; i < l; i++) {

            id = ids[i];

            activate = (i < k) ? activates[i] : activates[0];

            // handle state active property, default to 0
            if (this.states.hasOwnProperty(id)) {

                state = this.states[id];

                activePrev = state.active;

                state.active = activate === true ? 1 : 0;

                // if active changed, set states dirty
                if (state.active !== activePrev) {

                    this.set_dirty();

                }

            }

        }

        // recalculate state showing
        this.show_state();

        // signal
        this.stateChanged.dispatch(this);

    }

    function show_state(overdraw, activeLevel) {

        var state, overdrawPrev = this.states.overdraw;

        // set overdraw parameter
        if (overdraw === false) {

            this.states.overdraw = false;

        } else if (typeof overdraw === 'string' && this.states.hasOwnProperty(overdraw)) {

            this.states.overdraw = this.states[overdraw];

        }

        // if overdraw changed
        if (this.states.overdraw !== overdrawPrev) {

            this.set_dirty();

        }

        // if states dirty
        if (this._dirtyStates !== false) {

            // use overdraw state if exists
            if (this.states.overdraw instanceof _GridModuleState.Instance) {

                state = this.states.overdraw;

            }
            // else get top priority constant state
            else {

                state = this.get_state();

            }

            // modify module material with state
            state.modify_material(this.material, activeLevel);

            // clear dirty states
            this._dirtyStates = false;

        }

    }

    function get_state(id) {

        var i, l, states = this.states,
            statesList = states.list,
            state, statesPotential;

        // get state by id
        if (typeof id === 'string') {

            state = states[id];

        }
        // else get top priority state based on all active constant states
        else {

            // get all potential states
            statesPotential = [];

            for (i = 0, l = statesList.length; i < l; i++) {

                id = statesList[i];

                state = states[id];

                // if is active and constant
                if (state.active && state.constant) {

                    statesPotential.push(state);

                }

            }

            // sort potential states by priority and extract top
            statesPotential.sort(sort_by_priority);

            state = statesPotential[0];

        }

        return state;

    }

    function sort_by_priority(a, b) {
        return b.priority - a.priority;
    }

    /*===================================================
	
	occupants
	
	=====================================================*/

    function set_occupant(occupant) {

        // store
        this._occupant = occupant;

        // set occupied state
        this.change_state('occupied', (typeof this.occupant !== 'undefined'));

        // signal
        console.log('module occupied state change');
        this.occupiedStateChanged.dispatch(this);

    }

    /*===================================================
	
	connected
	
	=====================================================*/

    function get_modules_connected(connected, recalculate) {

        var i, l, j, k, vertices, faces, face;

        // handle connected
        connected = main.ensure_array(connected);

        // if should recalculate
        if (this._dirtyConnected !== false || recalculate === true) {

            // reset connected
            this._connected = {};
            this._connectedList = [];

            // if grid valid
            if (typeof this.grid !== 'undefined') {

                // for each face
                vertices = this.geometry.vertices;

                faces = this.geometry.faces;

                for (i = 0, l = faces.length; i < l; i++) {

                    face = faces[i];

                    // get connected sides
                    // ab / up
                    this.find_and_store_connected(vertices[face.a], vertices[face.b], [1, 'ab', 'up']);

                    // bc / left
                    this.find_and_store_connected(vertices[face.b], vertices[face.c], [3, 'bc', 'left']);

                    // by face type
                    if (face instanceof THREE.Face4) {

                        // cd / down
                        this.find_and_store_connected(vertices[face.c], vertices[face.d], [7, 'cd', 'down']);

                        // da / right
                        this.find_and_store_connected(vertices[face.d], vertices[face.a], [5, 'da', 'right']);

                    } else {

                        // ca / right / down
                        this.find_and_store_connected(vertices[face.c], vertices[face.a], [5, 7, 'ca', 'right', 'down']);

                    }

                    // get connected corners
                    // a / upright
                    this.find_and_store_connected(vertices[face.a], undefined, [2, 'a', 'upright']);

                    // b / upleft
                    this.find_and_store_connected(vertices[face.b], undefined, [0, 'b', 'upleft']);

                    // c / downleft
                    this.find_and_store_connected(vertices[face.c], undefined, [6, 'c', 'downleft']);

                    // d / downright
                    this.find_and_store_connected(vertices[face.d], undefined, [8, 'd', 'downright']);

                }

                // remove flag
                this._dirtyConnected = false;

            }

        }

        // add all connections to connected
        connected = connected.concat(this._connectedList);

        return connected;

    }

    function find_and_store_connected(vertexA, vertexB, ids) {

        var i, l, searchFor, connectedModules, connectedModule;

        // if grid is valid
        if (typeof this.grid !== 'undefined') {

            // set search target(s)
            if (typeof vertexB !== 'undefined') {

                searchFor = [vertexA, vertexB];

            } else {

                searchFor = vertexA;

            }

            // get connected modules
            //console.log( this.id, ' searching for connected at ', ids[ 2 ]);
            connectedModules = this.grid.get_modules_with_vertices(searchFor, this, [this].concat(this._connectedList));

            if (connectedModules.length > 0) {

                // take just first found module
                connectedModule = connectedModules[0];

                // check ids
                ids = main.ensure_array(ids);

                // store for each id
                for (i = 0, l = ids.length; i < l; i++) {

                    this._connected[ids[i]] = connectedModule;

                }

                // store in list
                this._connectedList.push(connectedModule);

            }

        }

    }

    function has_face_or_vertex(searchFor) {

        var i, l, vertices, vertex, faces, has = false;

        // search
        if (searchFor instanceof THREE.Vertex) {

            vertices = this.geometry.vertices;

            // compare searchFor to each vertex
            // instead of searching via indexOf
            for (i = 0, l = vertices.length; i < l; i++) {

                vertex = vertices[i];

                if (searchFor.position.equals(vertex.position)) {

                    has = true;

                    break;

                }

            }

        } else if (searchFor instanceof THREE.Face4 || searchFor instanceof THREE.Face3) {

            faces = this.geometry.faces;

            if (faces.indexOf(searchFor) !== -1) {

                has = true;

            }

        }

        return has;

    }

}(KAIOPUA));

/*
 *
 * GridModuleState.js
 * State for modules of puzzle grids.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/puzzles/GridModuleState.js",
        _GridModuleState = {},
        stateCount = 0;

    /*===================================================
	
	public
	
	=====================================================*/

    main.asset_register(assetPath, {
        data: _GridModuleState
    });

    // instance
    _GridModuleState.Instance = GridModuleState;

    _GridModuleState.Instance.prototype.add_property = add_property;
    _GridModuleState.Instance.prototype.get_properties = get_properties;
    _GridModuleState.Instance.prototype.modify_material = modify_material;

    Object.defineProperty(_GridModuleState.Instance.prototype, 'active', {
        get: function () {
            return this._active;
        },
        set: function (active) {

            if (this.dynamic !== false) {

                this._active = active;

            }

        }
    });

    Object.defineProperty(_GridModuleState.Instance.prototype, 'properties', {
        get: get_properties
    });

    Object.defineProperty(_GridModuleState.Instance.prototype, 'color', {
        get: function () {
            return this.properties.color;
        }
    });

    Object.defineProperty(_GridModuleState.Instance.prototype, 'ambient', {
        get: function () {
            return this.properties.ambient;
        }
    });

    Object.defineProperty(_GridModuleState.Instance.prototype, 'transparent', {
        get: function () {
            return this.properties.transparent;
        }
    });

    Object.defineProperty(_GridModuleState.Instance.prototype, 'opacity', {
        get: function () {
            return this.properties.opacity;
        }
    });

    /*===================================================
	
	instance
	
	=====================================================*/

    function GridModuleState(parameters) {

        stateCount++;

        // handle parameters
        parameters = parameters || {};

        this.id = parameters.id || 'state' + stateCount;

        this.active = parameters.active || 0;

        this.dynamic = (typeof parameters.dynamic === 'boolean') ? parameters.dynamic : true;

        this.constant = (typeof parameters.constant === 'boolean') ? parameters.constant : true;

        this.priority = parameters.priority || 0;

        this._properties = [];

        this.add_property(0, parameters);
        this.add_property(1, parameters);

    }

    function add_property(activeLevel, parameters) {

        // handle parameters
        parameters = parameters || {};

        this._properties = this._properties || [];

        // add property
        if (typeof activeLevel === 'undefined') {

            activeLevel = 0;

        }

        this._properties[activeLevel] = {
            color: parameters['color' + activeLevel] || parameters.color || new THREE.Color(),
            //0xffffff,
            ambient: parameters['ambient' + activeLevel] || parameters.ambient || new THREE.Color(),
            //0xffffff,
            transparent: parameters['transparent' + activeLevel] || parameters.transparent || false,
            opacity: parameters['opacity' + activeLevel] || parameters.opacity || 1
        };

    }

    function get_properties(activeLevel) {

        var properties;

        if (this._properties.hasOwnProperty(activeLevel)) {
            properties = this._properties[activeLevel];
        } else if (this._properties.hasOwnProperty(this.active)) {
            properties = this._properties[this.active];
        } else {
            properties = this._properties[0];
        }

        return properties;

    }

    function modify_material(material, activeLevel) {

        var p = this.get_properties(activeLevel);

        // valid material
        if (material instanceof THREE.Material) {

            material.color.copy(p.color);

            material.ambient.copy(p.ambient);

            material.transparent = p.transparent;

            material.opacity = p.opacity;

        }

    }

}(KAIOPUA));

/*
 *
 * Puzzles.js
 * Creates and tracks all puzzles.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/puzzles/Puzzle.js",
        _Puzzle = {},
        _Model, _Grid, _Messenger, puzzleID = 'Puzzle',
        puzzleCount = 0,
        allPuzzles, allPuzzlesSolved, allModules;

    /*===================================================
	
	public
	
	=====================================================*/

    main.asset_register(assetPath, {
        data: _Puzzle,
        requirements: ["assets/modules/core/Model.js", "assets/modules/puzzles/Grid.js", "assets/modules/ui/Messenger.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
	
	init
	
	=====================================================*/

    function init_internal(m, g, msg) {
        console.log('internal puzzles', _Puzzle);
        _Model = m;
        _Grid = g;
        _Messenger = msg;

        // puzzles / modules list
        allPuzzles = [];
        allPuzzlesSolved = [];

        Object.defineProperty(_Puzzle, 'allPuzzles', {
            get: function () {
                return allPuzzles.slice(0);
            }
        });

        Object.defineProperty(_Puzzle, 'allPuzzlesSolved', {
            get: function () {
                return allPuzzlesSolved.slice(0);
            }
        });

        Object.defineProperty(_Puzzle, 'allModules', {
            get: function () {

                var i, l;

                // if puzzles list dirty
                if (this._dirtyPuzzles !== false) {

                    allModules = [];

                    for (i = 0, l = allPuzzles.length; i < l; i++) {

                        allModules = allModules.concat(allPuzzles[i].grid.modules);

                    }

                    this._dirtyPuzzles = false;

                }

                return allModules.slice(0);

            }
        });

        // instance
        _Puzzle.Instance = Puzzle;
        _Puzzle.Instance.prototype = new _Model.Instance();
        _Puzzle.Instance.prototype.constructor = _Puzzle.Instance;

        Object.defineProperty(_Puzzle.Instance.prototype, 'elements', {
            get: function () {

                return this.grid.elements;

            }
        });

    }

    /*===================================================
	
	puzzle
	
	=====================================================*/

    function Puzzle(parameters) {

        var solved = false,
            numElementsMin, rewards;

        puzzleCount++;

        // handle parameters
        parameters = parameters || {};

        parameters.grid = parameters.grid || {};
        parameters.grid.puzzle = this;

        // prototype constructor
        _Model.Instance.call(this, parameters);

        // properties
        this.id = typeof parameters.id === 'string' ? parameters.id : puzzleID + puzzleCount;
        rewards = parameters.rewards;
        numElementsMin = parameters.numElementsMin;

        // init grid
        this.grid = new _Grid.Instance(parameters.grid);

        // add grid
        this.add(this.grid);

        /*===================================================
		
		solved
		
		=====================================================*/

        Object.defineProperty(this, 'isSolved', {
            get: function () {

                return solved;

            }
        });

        this.solve = function () {

            var elements, numElementsBase = this.grid.modules.length,
                numElementsUsed, numElementsDiff;

            // if grid is full
            console.log('puzzle solve?');
            if (solved !== true && this.grid.isFull === true) {

                // set solved
                solved = true;

                // add to list
                if (allPuzzlesSolved.indexOf(this) === -1) {

                    allPuzzlesSolved.push(this);

                }

                // get elements filling grid
                elements = this.grid.elements;

                numElementsUsed = elements.length;

                // compare num elements used to base num required
                numElementsDiff = numElementsBase - numElementsUsed;

                numElementsMin = main.is_number(numElementsMin) && numElementsMin <= numElementsDiff ? numElementsMin : numElementsDiff;

                // send message notifying user of score
                _Messenger.show_message({
                    //image: shared.pathToIcons + 'alertcircle_64.png',
                    title: "Hurrah! You solved the " + this.id + " puzzle!",
                    body: "Looks like you only needed " + numElementsUsed + " out of " + numElementsBase + " elements! You beat the baseline score by " + numElementsDiff + " and are " + (numElementsMin - numElementsDiff) + " away from a perfect score!",
                    active: true
                });

            }

        };

        // signal
        this.grid.stateChanged.add(this.solve, this);

        // add to global list
        if (this.grid.modules.length > 0) {

            // add to puzzles list
            allPuzzles.push(this);

            _Puzzle._dirtyPuzzles = true;

        }

    }

}(KAIOPUA));

/*
 *
 * Intro.js
 * Handles introduction to story and teaching user basic game mechanics.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/sections/Intro.js",
        intro = {},
        _Game, _Model, _WorldIsland, _Player, _Physics, _ready = false,
        waitingToShow = false,
        camera, scene, sceneBG, world, addOnShow = [],
        addBGOnShow = [],
        skybox, ambient, light;

    /*===================================================
    
    public properties
    
    =====================================================*/

    intro.show = show;
    intro.hide = hide;
    intro.remove = remove;
    intro.update = update;
    intro.resize = resize;
    intro.domElement = function () {};

    main.asset_register(assetPath, {
        data: intro,
        requirements: ["assets/modules/core/Game.js", "assets/modules/core/Physics.js", "assets/modules/env/WorldIsland.js", "assets/modules/core/Player.js", "assets/modules/core/Model.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(g, physx, w, p, m) {
        console.log('internal intro');
        if (_ready !== true) {

            // assets
            _Game = g;
            _Physics = physx;
            _WorldIsland = w;
            _Player = p;
            _Model = m;

            // environment
            init_environment();

            _ready = true;

            if (waitingToShow === true) {

                waitingToShow = false;

                show();

            }

        }

    }

    function init_environment() {

        world = new _WorldIsland.Instance();

    }

    /*===================================================
    
    section functions
    
    =====================================================*/

    function show() {

        if (_ready === true) {

            // camera
            camera = _Game.camera;

            camera.position.set(0, 0, 4000);

            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // scene
            scene = _Game.scene;

            sceneBG = _Game.sceneBG;

            // add world
            world.show(scene);

            // add items
            _Game.add_to_scene(addOnShow, scene);

            _Game.add_to_scene(addBGOnShow, sceneBG);

            // start player
            _Player.show();

            _Player.enable();

            _Player.character.position.set(35, 3000, 765);
            _Player.character.quaternion.set(0, -1, -0.25, 0);

            //_Player.cameraMode = 'freelook';
            // signals
            shared.signals.windowresized.add(resize);

            shared.signals.update.add(update);

        } else {

            waitingToShow = true;

        }

    }

    function hide() {

        waitingToShow = false;

        shared.signals.windowresized.remove(resize);

        shared.signals.update.remove(update);

    }

    function remove() {

        if (_ready === true) {

            // stop player
            _Player.disable();

            _Player.hide();

            // hide world
            world.hide();

            // remove added items
            _Game.remove_from_scene(addOnShow, scene);

            _Game.remove_from_scene(addBGOnShow, sceneBG);

        } else {

            waitingToShow = false;

        }

    }

    function update() {

    }

    function resize(W, H) {

    }

}(KAIOPUA));

/*
 *
 * Launcher.js
 * Interactive environment for loading and launching game.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/sections/Launcher.js",
        launcher = {},
        ready = false,
        waitingToShow = false,
        _Game, _WaterLauncher, _Sky, camera, scene, sceneBG, addOnShow = [],
        addBGOnShow = [],
        ambientLight, lightSky, lightWater, fogColor = 0x529ad1,
        water, skybox, time, camRotationBaseQ, camRotationOffset, camRotationOffsetQ, viewShift = {
            x: 0,
            y: 0,
            rx: 0,
            ry: 0,
            rangeTransMaxX: 500,
            rangeTransMinX: -500,
            rangeTransMaxY: 0,
            rangeTransMinY: -250,
            speedTransX: 0.01,
            speedTransY: 0.01,
            rangeRotMaxX: 0,
            rangeRotMinX: -15,
            rangeRotMaxY: 10,
            rangeRotMinY: -10,
            speedRotX: 0.05,
            speedRotY: 0.05
        };

    /*===================================================
    
    public properties
    
    =====================================================*/

    launcher.show = show;
    launcher.hide = hide;
    launcher.remove = remove;
    launcher.update = update;
    launcher.resize = resize;

    main.asset_register(assetPath, {
        data: launcher,
        requirements: ["assets/modules/core/Game.js", "assets/modules/env/SkyLauncher.js", "assets/modules/env/WaterLauncher.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(g, s, w) {

        if (ready !== true) {
            console.log('internal launcher');
            _Game = g;
            _Sky = s;
            _WaterLauncher = w;

            init_environment();

            ready = true;

            if (waitingToShow === true) {

                waitingToShow = false;

                show();

            }

        }

    }

    function init_environment() {

        // camera rotation
        camRotationBaseQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI * 0.5);

        camRotationOffset = new THREE.Vector3();

        camRotationOffsetQ = new THREE.Quaternion();

        // lights
        ambientLight = new THREE.AmbientLight(0xeeeeee);

        lightSky = new THREE.DirectionalLight(0xffffff, 1);
        lightSky.position = new THREE.Vector3(-1, 0.5, 0).normalize();

        //lightSky = new THREE.PointLight( 0xffffcc, 0.75, 40000 );
        //lightSky.position.set( 0, 3000, 2000 );
        //lightWater = new THREE.PointLight( 0xffffcc, 0.25, 20000 );
        //lightWater.position.set( 0, -6000, 0 );
        // skybox
        skybox = init_skybox();

        // water
        water = new _WaterLauncher.Instance({
            wavesColor: fogColor
        });

        // sky
        _Sky.init();

        // sky environment
        _Sky.environment.position.x = 0;
        _Sky.environment.position.y = 2000;

        _Sky.environment.rotation.y = -90 * Math.PI / 180;

        // set items to add on show
        addOnShow.push(ambientLight, lightSky, water.environment, _Sky.environment);

        addBGOnShow.push(skybox);

    }

    function init_skybox() {

        var ap, images, textureCube, shader, material, mesh;

        // images
        ap = "assets/textures/skybox_launcher";

        // cube texture
        textureCube = new THREE.Texture();

        main.asset_require([ap + "_xz.jpg", ap + "_posy.jpg", ap + "_negy.jpg"], function (xz, posy, negy) {

            textureCube.image = [xz, xz, posy, negy, xz, xz];
            textureCube.needsUpdate = true;

        });

        // shader
        shader = THREE.ShaderUtils.lib["cube"];
        shader.uniforms["tCube"].texture = textureCube;

        // material
        material = new THREE.ShaderMaterial({

            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: shader.uniforms,
            depthWrite: false

        });

        // mesh
        mesh = new THREE.Mesh(new THREE.CubeGeometry(100, 100, 100), material);
        mesh.flipSided = true;

        return mesh;

    }

    /*===================================================
    
    mouse functions
    
    =====================================================*/

    function on_mouse_moved(e) {

        var mouse = main.get_mouse(e),
            pctX = (mouse.x / shared.screenWidth),
            pctY = (mouse.y / shared.screenHeight);

        viewShift.x = pctX * viewShift.rangeTransMaxX + (1 - pctX) * viewShift.rangeTransMinX;
        viewShift.y = pctY * viewShift.rangeTransMaxY + (1 - pctY) * viewShift.rangeTransMinY;

        viewShift.rx = (pctY) * viewShift.rangeRotMaxX + (1 - pctY) * viewShift.rangeRotMinX;
        viewShift.ry = (1 - pctX) * viewShift.rangeRotMaxY + (pctX) * viewShift.rangeRotMinY;

    }

    /*===================================================
    
    standard
    
    =====================================================*/

    function show() {

        if (ready === true) {

            // camera
            camera = _Game.camera;

            // starting position
            camera.position.set(-5800, 0, 0);

            // set base quaternion
            camera.quaternion.copy(camRotationBaseQ);

            // scene
            scene = _Game.scene;

            sceneBG = _Game.sceneBG;

            // fog
            scene.fog = new THREE.Fog(fogColor, -100, 10000);

            // add items
            _Game.add_to_scene(addOnShow, scene);

            _Game.add_to_scene(addBGOnShow, sceneBG);

            // shared
            shared.renderer.sortObjects = false;

            shared.signals.mousemoved.add(on_mouse_moved);

            shared.signals.update.add(update);

        } else {

            waitingToShow = true;

        }

    }

    function hide() {

        waitingToShow = false;

        shared.signals.mousemoved.remove(on_mouse_moved);

        shared.signals.update.remove(update);

    }

    function remove() {

        if (ready === true) {

            // enable renderer object sorting
            shared.renderer.sortObjects = true;

            // remove added items
            _Game.remove_from_scene(addOnShow, scene);

            _Game.remove_from_scene(addBGOnShow, sceneBG);

        } else {

            waitingToShow = false;

        }

    }

    function update(timeDelta) {

        camera.position.z += (viewShift.x - camera.position.z) * viewShift.speedTransX;
        camera.position.y += (-viewShift.y - camera.position.y) * viewShift.speedTransY;

        camRotationOffset.z += (viewShift.rx - camRotationOffset.z) * viewShift.speedRotX;
        camRotationOffset.y += (viewShift.ry - camRotationOffset.y) * viewShift.speedRotY;

        // update rotation
        camRotationOffsetQ.setFromEuler(camRotationOffset).normalize();

        camera.quaternion.set(0, 0, 0, 1).multiplySelf(camRotationOffsetQ).multiplySelf(camRotationBaseQ);

        // update environment
        _Sky.wind_blow(timeDelta);

        water.generate_waves(timeDelta);

    }

    function resize() {

    }

}(KAIOPUA));

/*
 *
 * UIElement.js
 * Generic ui item.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/ui/UIElement.js",
        _UIElement = {},
        idBase = 'ui_element',
        uiElementCount = 0;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _UIElement,
        requirements: ["js/lib/jquery.transform2d.min.js", "js/lib/jquery.tipTip.min.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal() {
        console.log('internal ui element', _UIElement);
        // public
        _UIElement.generate_dom_element = generate_dom_element;
        _UIElement.generate_tool_tip = generate_tool_tip;
        _UIElement.supported_css_property = supported_css_property;
        _UIElement.supported_css_value = supported_css_value;
        _UIElement.str_to_camel = str_to_camel;
        _UIElement.str_from_camel = str_from_camel;

        // css special cases
        _UIElement.cssSpecialCases = {};

        _UIElement.cssSpecialCases.transform = _UIElement.supported_css_property('transform');
        _UIElement.cssSpecialCases.transformOrigin = _UIElement.supported_css_property('transform-origin');
        _UIElement.cssSpecialCases.pointerEvents = _UIElement.supported_css_property('pointer-events');
        _UIElement.cssSpecialCases.lineargradient = (function () {

            // get correct linear gradient value name
            var test = document.createElement('div'),
                prefixes = ' -webkit- -moz- -o- -ms- -khtml- '.split(' '),
                strBGImg = 'background-image:',
                strLinGrad = 'linear-gradient',
                strGradVal = '(left top,#9f9, white);',
                strStyle, index, strPropertyName = strLinGrad;

            test.style.cssText = (strBGImg + prefixes.join((strLinGrad + strGradVal) + strBGImg)).slice(0, -strBGImg.length);

            strStyle = test.style.backgroundImage.toString();

            index = strStyle.indexOf(strLinGrad);

            if (index !== -1) {

                strPropertyName = strStyle.substr(0, index + strLinGrad.length);

            }

            return strPropertyName;

        }());

        // firefox <12 css3 transform bug, see https://bugzilla.mozilla.org/show_bug.cgi?id=591718, fixed as of Jan 2012
        _UIElement.transformCSSUpdateMissing = (function () {

            var domElement = $(document.createElement('div')),
                leftExpected = 100,
                topExpected = 100,
                bodyOffset, offset, leftActual, topActual, result;

            // try transform
            domElement.css({
                'width': '100px',
                'height': '100px',
                'position': 'absolute',
                'transform': 'translate(' + leftExpected + 'px, ' + topExpected + 'px)'
            });

            $(document.body).prepend(domElement);

            offset = domElement.position();
            leftActual = offset.left;
            topActual = offset.top;

            result = (leftActual === leftExpected && topActual === topExpected);

            domElement.detach();

            return result;

        }());

        // fix for firefox <12 css3 transform bug
        _UIElement.matrix_from_css_str = function (str) {

            var strArr = str.match(/matrix\(([^\)]+)\)/i)[1].split(','),
                mat = new Matrix.create([
                    [+strArr[0], +strArr[2], parseFloat(strArr[4])],
                    [+strArr[1], +strArr[3], parseFloat(strArr[5])],
                    [0, 0, 1]
                    ]);

            return mat;

        };

        _UIElement.transformIdentityMatrix = _UIElement.matrix_from_css_str('matrix(1,0,0,1,0,0)');

        _UIElement.translate_matrix_2d = function (mat, tx, ty) {

            var elements = mat.elements;

            elements[0][2] += tx;
            elements[1][2] += ty;

            return mat;
        };

        _UIElement.get_local_transformation_matrix = function (domElement) {

            var element = domElement instanceof jQuery ? domElement[0] : domElement,
                transformProp = _UIElement.cssSpecialCases.transform,
                originProp = _UIElement.cssSpecialCases.transformOrigin,
                style = window.getComputedStyle(element, null),
                transformStyle = style[transformProp],
                originStyle = style[originProp],
                transformMatrix = (transformStyle ? _UIElement.matrix_from_css_str(transformStyle) : _UIElement.transformIdentityMatrix.dup()),
                originMatrix, result;

            // finding element's local transformation matrix based on the transform style
            // Firefox gives 50% 50% when there is no transform!? and pixels (50px 30px) otherwise
            if (!originStyle || originStyle.indexOf('%') !== -1) {

                originStyle = [0, 0];

            } else {

                originStyle = originStyle.replace(/px/gi, '').split(' ');

            }

            originMatrix = _UIElement.matrix_from_css_str('matrix(1,0,0,1,' + originStyle[0] + ',' + originStyle[1] + ')');

            result = originMatrix.multiply(transformMatrix).multiply(originMatrix.inverse());

            return _UIElement.translate_matrix_2d(result, -window.pageXOffset, -window.pageYOffset);

        };

        _UIElement.transform_css_update = function (uielement) {

            var domElement, width, height, transformationMatrix, topleft, topright, bottomleft, bottomright, bbox;

            // if update needed
            if (_UIElement.transformCSSUpdateMissing !== true && uielement instanceof _UIElement.Instance) {

                domElement = uielement.domElement;
                width = uielement.width;
                height = uielement.height;

                // get correct transformation matrix
                transformationMatrix = _UIElement.get_local_transformation_matrix(domElement);

                // get bounding box
                topleft = transformationMatrix.multiply(Vector.create([0, 0, 1])).elements;
                topright = transformationMatrix.multiply(Vector.create([width, 0, 1])).elements;
                bottomleft = transformationMatrix.multiply(Vector.create([0, height, 1])).elements;
                bottomright = transformationMatrix.multiply(Vector.create([width, height, 1])).elements;

                bbox = {
                    'transform': 'none',
                    'left': Math.min(topleft[0], topright[0], bottomleft[0], bottomright[0]) + 'px',
                    'top': Math.min(topleft[1], topright[1], bottomleft[1], bottomright[1]) + 'px'
                }

                // update css
                domElement.css(bbox);

            }

        };

        // instance
        _UIElement.Instance = UIElement;

        _UIElement.Instance.prototype.add = add;
        _UIElement.Instance.prototype.remove = remove;

        _UIElement.Instance.prototype.append_to = append_to;

        _UIElement.Instance.prototype.enable = enable;
        _UIElement.Instance.prototype.disable = disable;

        _UIElement.Instance.prototype.enable_visual = enable_visual;
        _UIElement.Instance.prototype.disable_visual = disable_visual;

        _UIElement.Instance.prototype.set_position = set_position;
        _UIElement.Instance.prototype.align = align;
        _UIElement.Instance.prototype.align_once = align_once;

        _UIElement.Instance.prototype.show = show;
        _UIElement.Instance.prototype.hide = hide;

        _UIElement.Instance.prototype.pulse = pulse;
        _UIElement.Instance.prototype.pulse_stop = pulse_stop;

        _UIElement.Instance.prototype.sort_children_by_order = sort_children_by_order;
        _UIElement.Instance.prototype.get_child_order = get_child_order;
        _UIElement.Instance.prototype.show_children = show_children;
        _UIElement.Instance.prototype.hide_children = hide_children;
        _UIElement.Instance.prototype.copy_children_and_exclude = copy_children_and_exclude;
        _UIElement.Instance.prototype.get_children_showing = get_children_showing;
        _UIElement.Instance.prototype.get_children_hidden = get_children_hidden;

        _UIElement.Instance.prototype.set_pointer_events = set_pointer_events;

        _UIElement.Instance.prototype.update_form = update_form;
        _UIElement.Instance.prototype.form_circle = form_circle;
        _UIElement.Instance.prototype.form_rectangle = form_rectangle;
        _UIElement.Instance.prototype.form_fullwindow = form_fullwindow;

        _UIElement.Instance.prototype.change_dom_element = change_dom_element;
        _UIElement.Instance.prototype.generate_dom_element = generate_dom_element;
        _UIElement.Instance.prototype.generate_tool_tip = generate_tool_tip;
        _UIElement.Instance.prototype.apply_css = apply_css;

        _UIElement.Instance.prototype.generate_theme = generate_theme;

        _UIElement.Instance.prototype.themes = {};
        _UIElement.Instance.prototype.themes.core = theme_core;
        _UIElement.Instance.prototype.themes.white = theme_white;
        _UIElement.Instance.prototype.themes.green = theme_green;
        _UIElement.Instance.prototype.themes.red = theme_red;

        Object.defineProperty(_UIElement.Instance.prototype, 'domElement', {
            get: function () {
                return this._domElement;
            },
            set: function () {
                this.change_dom_element.apply(this, arguments);
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'parent', {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                this.append_to(parent);
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'html', {
            get: function () {
                return this.domElement.html();
            },
            set: function (html) {

                this.domElement.html(html);

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'width', {
            get: function () {
                return this.domElement.width();
            },
            set: function (width) {

                this.domElement.width(main.is_number(width) ? Math.round(width) : width);

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'height', {
            get: function () {
                return this.domElement.height();
            },
            set: function (height) {

                this.domElement.height(main.is_number(height) ? Math.round(height) : height);

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'widthHalf', {
            get: function () {
                return this.width * 0.5;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'heightHalf', {
            get: function () {
                return this.height * 0.5;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'outerWidth', {
            get: function () {
                return this.width + this.spacingLeft + this.spacingRight;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'outerHeight', {
            get: function () {
                return this.height + this.spacingTop + this.spacingBottom;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'outerWidthHalf', {
            get: function () {
                return this.outerWidth * 0.5;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'outerHeightHalf', {
            get: function () {
                return this.outerHeight * 0.5;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'x', {
            get: function () {
                return this._x;
            },
            set: function (x) {

                this.set_position(x, this._y);

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'y', {
            get: function () {
                return this._y;
            },
            set: function (y) {

                this.set_position(this._x, y);

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'alignment', {
            get: function () {
                return this._alignment;
            },
            set: function (location) {

                if (typeof location === 'string') {

                    this._alignment = location.toLowerCase();

                    if (this.alignmentGuide instanceof _UIElement.Instance !== true) {

                        shared.signals.windowresized.add(this.align, this);

                    }

                    this.align();

                } else {

                    this._alignment = false;

                    if (this.alignmentGuide instanceof _UIElement.Instance !== true) {

                        shared.signals.windowresized.remove(this.align, this);

                    }

                }

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'alignmentGuide', {
            get: function () {
                return this._alignmentGuide;
            },
            set: function (uielement) {

                if (uielement instanceof _UIElement.Instance && uielement !== this) {

                    this._alignmentGuide = uielement;

                } else {

                    this._alignmentGuide = false;

                }

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'pointerEvents', {
            get: function () {
                return this._pointerEvents;
            },
            set: function (state) {

                var me = this;

                if (typeof state === 'boolean' && (this.hasOwnProperty('_pointerEvents') !== true || this.pointerEvents !== state)) {

                    this._pointerEvents = state;

                    this.set_pointer_events(this._pointerEvents);

                }

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'enabledSelf', {
            get: function () {
                return this._enabled;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'enabled', {
            get: function () {
                return (this._enabledOverride === false ? this._enabledOverride : (this.enabledSelf !== false && this.parent instanceof _UIElement.Instance ? this.parent.enabled : this.enabledSelf));
            },
            set: function (state) {

                if (state === true) {

                    this.enable();

                } else {

                    this.disable();

                }

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'isVisibleSelf', {
            get: function () {
                return this._isVisible;
            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'isVisible', {
            get: function () {
                return (this._isVisible !== false && this.parent instanceof _UIElement.Instance ? this.parent.isVisible : this._isVisible);
            },
            set: function (state) {

                this._isVisible = state;

            }
        });

        Object.defineProperty(_UIElement.Instance.prototype, 'hidden', {
            get: function () {
                return this._hidden;
            },
            set: function (state) {

                this._hidden = state;

                this.set_pointer_events(state ? false : this.pointerEvents);

            }
        });

    }

    /*===================================================
    
    ui
    
    =====================================================*/

    function UIElement(parameters) {

        var themeOverrides;

        // increase element count
        uiElementCount++;

        // handle parameters
        parameters = parameters || {};

        // id
        if (typeof parameters.id !== 'string') {

            parameters.id = idBase + uiElementCount;

        }

        this.id = parameters.id;

        // init dom element
        if (typeof parameters.domElement !== 'undefined') {

            this.domElement = $(parameters.domElement);

        } else {

            this.domElement = this.generate_dom_element(parameters);

        }

        // generate and apply theme
        if (typeof parameters.themeOverrides !== 'undefined') {

            themeOverrides = parameters.themeOverrides;

        } else {

            themeOverrides = {
                cssmap: parameters.cssmap
            };

        }

        this.theme = this.generate_theme(parameters.theme, themeOverrides);

        // generate and apply css map
        //this.cssmap = this.generate_cssmap( parameters.cssmap);
        this.apply_css(this.theme.cssmap);

        // tooltip
        if (typeof parameters.tooltip !== 'undefined') {

            this.tooltip = this.generate_tool_tip(parameters.tooltip, this);

        }

        // items
        this.children = [];
        this.childrenOrder = {};
        this.childrenByID = {};
        this.childrenAlwaysVisible = [];

        // properties
        this.timeShow = main.is_number(parameters.timeShow) ? parameters.timeShow : 500;
        this.timeHide = main.is_number(parameters.timeHide) ? parameters.timeHide : 500;

        this.opacityShow = main.is_number(parameters.opacityShow) ? parameters.opacityShow : 1;

        this.spacingTop = parameters.spacingTop || parameters.spacingVertical || parameters.spacing || 0;
        this.spacingBottom = parameters.spacingBottom || parameters.spacingVertical || parameters.spacing || 0;
        this.spacingLeft = parameters.spacingLeft || parameters.spacingHorizontal || parameters.spacing || 0;
        this.spacingRight = parameters.spacingRight || parameters.spacingHorizontal || parameters.spacing || 0;

        this.pointerEvents = this.pointerEventsWhileVisible = (typeof parameters.pointerEvents === 'boolean') ? parameters.pointerEvents : true;

        // on display
        this.hidden = false;
        this.isVisible = Boolean(this.domElement.parents("body").length);
        this.signalOnVisible = shared.signals["on_display_" + this.id] = new signals.Signal();

        // position
        this.set_position(0, 0);

        // enable / disable
        this.enabled = (typeof parameters.enabled === 'boolean' ? parameters.enabled : true);

        // width / height
        if (parameters.hasOwnProperty('width')) {

            this.width = parameters.width;

        } else if (parameters.hasOwnProperty('size')) {

            this.width = parameters.size;

        }

        if (parameters.hasOwnProperty('height')) {

            this.height = parameters.height;

        } else if (parameters.hasOwnProperty('size')) {

            this.height = parameters.size;

        }

        // form, default to rectangle
        if (parameters.fullwindow === true) {

            this.form_fullwindow();

        }

        if (parameters.circle === true) {

            this.form_circle();

        }

        if (parameters.rectangle === true) {

            this.form_rectangle();

        }

        // alignment
        this.alignment = parameters.alignment || false;

        this.alignmentGuide = parameters.alignmentGuide || false;

        this.alignmentOutside = typeof parameters.alignmentOutside === 'boolean' ? parameters.alignmentOutside : false;

        // if dom element already has parent, set as parent
        if (this.isVisible) {

            this._parent = this.domElement.parent();

        }

    }

    /*===================================================
    
    children
    
    =====================================================*/

    function add() {

        var i, l, argument, child;

        // run through arguments passed
        for (i = 0, l = arguments.length; i < l; i++) {

            argument = arguments[i];

            // if is valid child
            if (argument instanceof _UIElement.Instance) {

                child = argument;

                if (this.children.indexOf(child) === -1) {

                    this.children.push(child);

                    this.childrenOrder[child.id] = -1;

                    this.childrenByID[child.id] = child;

                    if (child.parent !== this) {

                        child.parent = this;

                    }

                }

            }
            // else if is number, assume is order for previous child
            if (i > 0 && main.is_number(argument)) {

                this.childrenOrder[child.id] = argument;

            }

        }

        // sort children
        this.sort_children_by_order();

    }

    function remove() {

        var i, l, children, child, index;

        // default to removing all
        children = (arguments.length > 0 ? arguments : this.children);

        for (i = 0, l = children.length; i < l; i++) {

            child = children[i];
            //console.log(this.id, 'removing', child.id );
            index = this.children.indexOf(child);

            if (index !== -1) {

                this.children.splice(index, 1);

            }

            delete this.childrenOrder[child.id];

            delete this.childrenByID[child.id];

            // if always visible
            index = this.childrenAlwaysVisible.indexOf(child);

            if (index !== -1) {

                this.childrenAlwaysVisible.splice(index, 1);

            }

            if (child.parent === this) {

                child.parent = child.parentLast;

            }

        }

        // sort children
        this.sort_children_by_order();

    }

    /*===================================================
    
    append
    
    =====================================================*/

    function append_to(parent, visible) {

        var i, l, domElement, child;

        // if new parent
        if (this.parent !== parent) {

            // store last
            this.parentLast = this.parent;

            // store new
            this._parent = parent;

        }

        // if parent is ui element
        if (this.parent instanceof _UIElement.Instance) {

            // if not on parent child list
            if (this.parent.children.indexOf(this) === -1) {

                this.parent.add(this);

            }

            //console.log( this, this.id, ' has PARENT', this.parent.id );
            // get parent dom element
            domElement = this.parent.domElement;

        } else {

            domElement = $(this.parent);

        }

        // if valid dom element
        if (typeof domElement !== 'undefined' && domElement.length) {

            // append
            domElement.append(this.domElement);

            // set is visible
            this.isVisible = (typeof visible === 'boolean' ? visible : Boolean(domElement.parents("body").length));

            // if visible
            if (this.isVisible) {

                // set all children correct parent
                for (i = 0, l = this.children.length; i < l; i++) {

                    child = this.children[i];

                    child.append_to(this, this.isVisible);

                }

                // dispatch visible signal
                this.signalOnVisible.dispatch();

            }

        } else {

            // if last parent was ui element
            if (this.parentLast instanceof _UIElement.Instance) {

                // if was on parent child list
                if (this.parentLast.children.indexOf(this) === -1) {

                    this.parentLast.remove(this);

                }

            }

            // set is visible
            this.isVisible = false;

            // detach
            this.domElement.detach();

        }

    }

    /*===================================================
    
    enable / disable
    
    =====================================================*/

    function enable() {

        this._enabled = true;

        this.enable_visual();

    }

    function disable() {

        this._enabled = false;

        this.disable_visual();

    }

    /*===================================================
    
    visual state
    
    =====================================================*/

    function enable_visual() {

        var i, l, child;

        this.apply_css(this.theme.enabled);

        this.theme.stateLast = this.theme.enabled;

        for (i = 0, l = this.children.length; i < l; i++) {

            child = this.children[i];

            if (child.parent === this && child.enabledSelf === true) {

                child.enable_visual();

            }

        }

    }

    function disable_visual() {

        var i, l, child;

        this.apply_css(this.theme.disabled);

        this.theme.stateLast = this.theme.disabled;

        /*
		for ( i = 0, l = this.children.length; i < l; i++) {
			
			child = this.children[ i ];
			
			if ( child.parent === this ) {
				console.log(this.id, 'disable child visual', child.id );
				child.disable_visual();
				
			}
			
		}
		*/

    }

    /*===================================================
    
    position
    
    =====================================================*/

    function set_position(x, y) {

        var transformValue;

        // internal trackers for x and y
        // non-integer values of x/y cause terrible text rendering
        // around 250x faster than calling jQuery position().top/left
        this._x = Math.round(x);
        this._y = Math.round(y);

        // if css transform supported
        if (_UIElement.cssSpecialCases.transform) {
            // set transform value
            transformValue = 'translate(' + this._x + 'px, ' + this._y + 'px )';

            // use direct manipulation of dom element css due to repeated application
            // apply_css ensures correct css property/value for user's browser, but is 3x slower
            this.domElement.css('transform', transformValue);
            //this.apply_css( 'transform', transformValue );
            // ensure update css from transform
            _UIElement.transform_css_update(this);

        }
        // else use left/top
        else {

            if (this._x !== x) {
                this.domElement.css('left', this._x + 'px');
            }
            if (this._y !== y) {
                this.domElement.css('top', this._y + 'px');
            }

        }

    }

    function align() {

        var alignment, parent, x, y, w, h;

        // if has alignment
        if (typeof this.alignment === 'string') {

            // if on display
            if (this.isVisible) {

                alignment = this.alignment;

                // if has align to
                if (this.alignmentGuide instanceof _UIElement.Instance) {

                    parent = this.alignmentGuide.domElement;

                } else {

                    parent = this.domElement.parent();

                }

                // get basic width and height of parent
                if (parent.length) {

                    w = parent.width();
                    h = parent.height();

                } else {

                    w = shared.screenWidth;
                    h = shared.screenHeight;

                }

                if (alignment === 'center') {

                    x = w * 0.5 - this.widthHalf;
                    y = h * 0.5 - this.heightHalf;

                } else if (alignment === 'lefttop') {

                    x = this.spacingLeft;

                    if (this.alignmentOutside === true) {

                        y = -this.height - this.spacingTop;

                    } else {

                        y = this.spacingTop;

                    }

                } else if (alignment === 'righttop') {

                    x = w - this.width - this.spacingRight;

                    if (this.alignmentOutside === true) {

                        y = -this.height - this.spacingTop;

                    } else {

                        y = this.spacingTop;

                    }

                } else if (alignment === 'leftbottom') {

                    x = this.spacingLeft;

                    if (this.alignmentOutside === true) {

                        y = h + this.spacingBottom;

                    } else {

                        y = h - this.height - this.spacingBottom;

                    }

                } else if (alignment === 'rightbottom') {

                    x = w - this.width - this.spacingRight;

                    if (this.alignmentOutside === true) {

                        y = h + this.spacingBottom;

                    } else {

                        y = h - this.height - this.spacingBottom;

                    }

                } else if (alignment === 'bottomcenter') {

                    x = w * 0.5 - this.widthHalf;

                    if (this.alignmentOutside === true) {

                        y = h + this.spacingBottom;

                    } else {

                        y = h - this.height - this.spacingBottom;

                    }

                } else if (alignment === 'topcenter') {

                    x = w * 0.5 - this.widthHalf;

                    if (this.alignmentOutside === true) {

                        y = -this.height - this.spacingTop;

                    } else {

                        y = this.spacingTop;

                    }

                } else if (alignment === 'leftcenter') {

                    if (this.alignmentOutside === true) {

                        x = -this.width - this.spacingLeft;

                    } else {

                        x = this.spacingLeft;

                    }

                    y = h * 0.5 - this.heightHalf;

                } else if (alignment === 'rightcenter') {

                    if (this.alignmentOutside === true) {

                        x = w + this.spacingRight;

                    } else {

                        x = w - this.width - this.spacingRight;

                    }

                    y = h * 0.5 - this.heightHalf;

                } else if (alignment === 'bottomright') {

                    y = h - this.height - this.spacingBottom;

                    if (this.alignmentOutside === true) {

                        x = w + this.spacingRight;

                    } else {

                        x = w - this.width - this.spacingRight;

                    }

                } else if (alignment === 'bottomleft') {

                    y = h - this.height - this.spacingBottom;

                    if (this.alignmentOutside === true) {

                        x = -this.width - this.spacingLeft;;

                    } else {

                        x = this.spacingLeft;

                    }

                } else if (alignment === 'topright') {

                    y = this.spacingTop;

                    if (this.alignmentOutside === true) {

                        x = w + this.spacingRight;

                    } else {

                        x = w - this.width - this.spacingRight;

                    }

                } else if (alignment === 'topleft') {

                    y = this.spacingTop;

                    if (this.alignmentOutside === true) {

                        x = -this.width - this.spacingLeft;

                    } else {

                        x = this.spacingLeft;

                    }

                }

                // position
                this.set_position(x, y);

            } else {

                this.signalOnVisible.addOnce(this.align, this);

            }

        }

    }

    function align_once(alignment) {

        if (this.isVisible) {

            this.alignment = alignment;

            this.alignment = false;

        } else {

            this.signalOnVisible.addOnce(function () {

                this.alignment = alignment;

                this.alignment = false;

            }, this);

        }

    }

    /*===================================================
    
    show / hide self
    
    =====================================================*/

    function show(parameters) {

        var domElement, parent, time, opacity, callback, callbackContext, fadeCallback;
        //console.log( this.id, 'SHOW');
        // handle parameters
        parameters = parameters || {};

        domElement = parameters.domElement;

        parent = parameters.parent || this.parent || this.parentLast;

        time = main.is_number(parameters.time) ? parameters.time : (domElement ? 0 : this.timeShow);

        opacity = main.is_number(parameters.opacity) ? parameters.opacity : (domElement ? 1 : this.opacityShow);

        callback = parameters.callback;
        callbackContext = parameters.callbackContext;

        fadeCallback = function () {
            if (typeof callback !== 'undefined') {
                callback.call(callbackContext);
            }
        };

        // if dom element passed
        if (domElement) {

            domElement.stop(true).fadeTo(time, opacity, fadeCallback);

        }
        // else use own
        else {

            // set parent
            if (this.parent !== parent) {

                this.parent = parent;

                // show children
                this.show_children({
                    time: 0
                });

            }

            // set hidden
            this.hidden = this.hiding = false;

            // override enabled
            this._enabledOverride = true;

            // show
            if (this.domElement.css('opacity') !== opacity) {

                this.domElement.stop(true).fadeTo(time, opacity, fadeCallback);

            } else {

                fadeCallback();

            }

        }

    }

    function hide(parameters) {

        var me = this,
            domElement, remove, time, opacity, callback, callbackContext;
        //console.log( this.id, 'HIDE' );
        // handle parameters
        parameters = parameters || {};

        domElement = parameters.domElement;

        remove = parameters.remove;

        time = main.is_number(parameters.time) ? parameters.time : (domElement ? 0 : this.timeHide);

        opacity = main.is_number(parameters.opacity) ? parameters.opacity : 0;

        callback = parameters.callback;
        callbackContext = parameters.callbackContext;

        // if dom element passed
        if (domElement) {

            domElement.stop(true).fadeTo(time, opacity, function () {
                on_hidden(domElement, callback, callbackContext, remove);
            });

        }
        // else use own
        else {

            // override enabled
            this._enabledOverride = false;

            // hiding
            this.hiding = true;

            // hide
            if (this.domElement.css('opacity') !== opacity) {

                this.domElement.stop(true).fadeTo(time, opacity, function () {
                    on_hidden(me, callback, callbackContext, remove);
                });

            } else {

                on_hidden(this, callback, callbackContext, remove);

            }

        }

    }

    function on_hidden(hideTarget, callback, callbackContext, remove) {

        if (hideTarget instanceof _UIElement.Instance) {

            if (remove === true) {

                hideTarget.parent = undefined;

            }

            hideTarget.hidden = true;

            hideTarget.hiding = false;

        } else {

            if (remove === true) {

                hideTarget.detach();

            }

        }

        if (typeof callback !== 'undefined') {

            callback.call(callbackContext);

        }

    }

    function pulse(parameters) {

        var timeShow, timeHide, opacityShow, opacityHide, callback, callbackContext;

        // handle parameters
        parameters = parameters || {};

        parameters.iterations = main.is_number(parameters.iterations) ? parameters.iterations : -1;
        parameters.count = main.is_number(parameters.count) ? parameters.count : 0;
        parameters.count++;

        timeShow = main.is_number(parameters.timeShow) ? parameters.timeShow : (main.is_number(parameters.time) ? parameters.time : this.timeShow);
        timeHide = main.is_number(parameters.timeHide) ? parameters.timeHide : (main.is_number(parameters.time) ? parameters.time : this.timeHide);

        opacityShow = main.is_number(parameters.opacityShow) ? parameters.opacityShow : 1;
        opacityHide = main.is_number(parameters.opacityHide) ? parameters.opacityHide : 0;

        this.show({
            parent: parameters.parent,
            time: timeShow,
            opacity: opacityShow,
            callback: function () {
                this.hide({
                    remove: false,
                    time: timeHide,
                    opacity: opacityHide,
                    callback: function () {

                        if (parameters.iterations === -1 || parameters.count < parameters.iterations) {

                            this.pulse(parameters);

                        }

                    },
                    callbackContext: this
                });
            },
            callbackContext: this
        });

    }

    function pulse_stop() {

        this.domElement.stop(true);

    }

    /*===================================================
    
    show / hide children
    
    =====================================================*/

    function sort_children_by_order(children) {

        var me = this,
            childrenOrder = this.childrenOrder,
            ordera, orderb;

        children = children || this.children;

        children.sort(function (a, b) {

            ordera = childrenOrder[a.id];
            orderb = childrenOrder[b.id];

            if (ordera === -1) {
                ordera = children.length;
            }
            if (orderb === -1) {
                orderb = children.length;
            }

            return ordera - orderb;

        });

        return children;

    }

    function get_child_order(child) {

        var order = this.childrenOrder[child.id];

        return main.is_number(order) ? order : -1;

    }

    function show_children(parameters) {

        var i, l, children, child;

        if (this.children.length > 0) {

            // handle parameters
            parameters = parameters || {};

            parameters.parent = parameters.parent || this;

            // make copy of children passed
            children = this.copy_children_and_exclude(parameters.children, parameters.excluding);

            // sort children
            children = this.sort_children_by_order(children);

            //console.log(this.id, 'SHOW children', children );
            // show all
            for (i = 0, l = children.length; i < l; i++) {

                child = children[i];

                child.show(parameters);

            }

        }

    }

    function hide_children(parameters) {

        var i, l, children, child;

        if (this.children.length > 0) {

            // handle parameters
            parameters = parameters || {};

            parameters.remove = typeof parameters.remove === 'boolean' ? parameters.remove : false;

            // make copy of children passed
            children = this.copy_children_and_exclude(parameters.children, this.childrenAlwaysVisible.concat(parameters.excluding || []));

            // hide all
            //console.log(this.id, 'HIDE children', children );
            for (i = 0, l = children.length; i < l; i++) {

                child = children[i];

                if (child.hidden !== true && child.parent === this) {

                    child.hide(parameters);

                }

            }

        }

    }

    function copy_children_and_exclude(children, excluding) {

        var i, l, child, index, childrenMinusExcluded = [];

        children = main.ensure_array(children || this.children);

        excluding = main.ensure_array(excluding);

        for (i = 0, l = children.length; i < l; i++) {

            child = children[i];

            if (excluding.indexOf(child) === -1) {

                childrenMinusExcluded.push(child);

            }

        }

        return childrenMinusExcluded;

    }

    function get_children_showing(children) {

        var i, l, child, showing = [];

        children = main.ensure_array(children || this.children);

        for (i = 0, l = children.length; i < l; i++) {

            child = children[i];

            if (child.hidden === false && child.parent === this) {

                showing.push(child);

            }

        }

        return showing;

    }

    function get_children_hidden(children) {

        var i, l, child, hidden = [];

        children = main.ensure_array(children || this.children);

        for (i = 0, l = children.length; i < l; i++) {

            child = children[i];

            if (child.hidden === true && child.parent === this) {

                hidden.push(child);

            }

        }

        return hidden;

    }

    /*===================================================
    
    pointer events
    
    =====================================================*/

    function set_pointer_events(state, override) {

        var i, l, child;

        // catch state
        if (state === false || this.hiding === true || this.hidden === true || this.isVisible === false || (typeof this.parent !== 'undefined' && (this.parent.hiding === true || this.parent.hidden === true))) {

            // use native pointer-events when available
            if (_UIElement.cssSpecialCases.pointerEvents) {

                this.apply_css(_UIElement.cssSpecialCases.pointerEvents, 'none');

            } else {

                // fallback in-case browser does not support pointer-events property
                // this method is incredibly slow, as it has to hide domElement, retrigger event to find what is under, then show again
                this.domElement.on('mousedown.pe touchstart.pe mouseup.pe touchend.pe click.pe mouseenter.pe touchenter.pe mouseleave.pe touchleave.pe', function (e) {
                    on_pointer_event(me, e);
                });

            }

        } else {

            // use native pointer-events when available
            if (_UIElement.cssSpecialCases.pointerEvents) {

                this.apply_css(_UIElement.cssSpecialCases.pointerEvents, 'auto');

            } else {

                this.domElement.off('.pe');

            }

        }

        // cascade
        for (i = 0, l = this.children.length; i < l; i++) {

            child = this.children[i];

            child.set_pointer_events(state === false && override === true ? state : child.pointerEvents, override);

        }

    }

    function on_pointer_event(uiElement, e) {

        var opacity;

        if (typeof e !== 'undefined') {

            e.preventDefault();
            e.stopPropagation();

            opacity = uiElement.domElement.css('opacity');

            uiElement.domElement.stop(true).hide();

            $(document.elementFromPoint(e.clientX, e.clientY)).trigger(e);

            uiElement.domElement.stop(true).show();

        }

    }

    /*===================================================
    
    form
    
    =====================================================*/

    function update_form() {

        if (this.form === 'circle') {

            this.form_circle();

        }

    }

    function form_circle() {

        // if width set explicitly
        if (this.width !== 0) {

            this.form = 'circle';

            var width = this.width,
                height = this.height,
                max = Math.max(width, height),
                maxHalf = max * 0.5;

            // match width/height
            this.width = this.height = max;

            // set radius to half
            this.apply_css("border-radius", maxHalf + "px");

        }

    }

    function form_rectangle() {

        this.form = 'rectangle';

        // if either dimension is set when the other is not
        if (this.width !== 0 && this.height === 0) {

            this.height = this.width;

        }
        if (this.width === 0 && this.height !== 0) {

            this.width = this.height;

        }

        // set radius to base
        this.apply_css("border-radius", 0);

    }

    function form_fullwindow() {

        this.form = 'fullwindow';

        this.apply_css({
            "min-height": "100%",
            "width": "100%",
            "height": "100%",
            "top": "0px",
            "left": "0px",
            "overflow": "hidden"
        });

    }

    /*===================================================
    
    dom element
    
    =====================================================*/

    function change_dom_element(replacement, parameters) {

        var current = this.domElement;

        // handle parameters
        parameters = parameters || {};

        // if current exists, hide and remove
        if (typeof current !== 'undefined') {

            this.hide({
                domElement: current,
                remove: true,
                time: (this.hidden ? 0 : parameters.timeHide)
            });

        }

        // replace
        this._domElement = $(replacement);

        // parent
        if (typeof this.parent !== 'undefined') {

            if (this.parent instanceof _UIElement.Instance) {

                this.parent.domElement.append(this.domElement);

            } else {

                $(this.parent).append(this.domElement);

            }

        }

        // if this is showing
        if (this.hiding !== true && this.hidden === false) {

            this.hide({
                domElement: this.domElement,
                time: 0
            });

            this.show({
                domElement: this.domElement,
                time: parameters.timeShow
            });

            this.align();

        }

        return current;

    }

    function generate_dom_element(parameters) {

        var me = this,
            elementType, domElement, imgElement;

        // handle parameters
        parameters = parameters || {};

        // element type
        elementType = parameters.elementType || 'div';

        // dom element
        domElement = document.createElement(elementType);

        // special cases
        // image
        if (elementType === 'img' && typeof parameters.src === 'string') {

            /*
			main.asset_require( parameters.src, function ( img ) {
				
				main.extend( img, domElement );
				me.change_dom_element( img );
				
			} );
			*/
            domElement.onload = parameters.onload;
            domElement.crossOrigin = '';
            domElement.src = parameters.src;

        }

        // convert to jQuery
        domElement = $(domElement);

        // id
        domElement.attr('id', parameters.id);

        // html
        if (typeof parameters.html === 'string') {

            domElement.html(parameters.html);

        }

        // classes
        if (parameters.hasOwnProperty('classes')) {

            domElement.addClass(parameters.classes);

        }

        return domElement;

    }

    function generate_tool_tip(parameters, uielement) {

        var tooltip;

        if (typeof parameters === 'string') {

            tooltip = {};
            tooltip.source = tooltip.content = parameters;

        } else if (typeof parameters.content === 'string') {

            tooltip = main.extend(parameters, {}, true);
            tooltip.source = tooltip.content;

        }

        if (typeof tooltip.content !== 'undefined') {

            tooltip.defaultPosition = tooltip.defaultPosition || 'top';
            tooltip.maxWidth = tooltip.maxWidth || 'auto';
            tooltip.delay = tooltip.delay || 100;
            tooltip.contentDisabled = '<br/><p class="disabled">' + (tooltip.contentDisabled || '(disabled)') + '</p>';
            tooltip.uielement = uielement;

            // on enter function to check if ui element is enabled/disabled and notify user
            tooltip.enter = function () {

                tooltip.content = tooltip.source;

                if (tooltip.uielement instanceof _UIElement.Instance && tooltip.uielement.enabledSelf !== true) {

                    tooltip.content += tooltip.contentDisabled;

                }

            };

            // on click function to check if ui element is hiding/hidden to disable tooltip
            tooltip.click = function () {

                tooltip.disable = false;

                if (tooltip.uielement instanceof _UIElement.Instance && (tooltip.uielement.hiding === true || tooltip.uielement.hidden === true || tooltip.uielement.isVisible === false)) {

                    tooltip.disable = true;

                }

            };

            // if ui element passed
            if (uielement instanceof _UIElement.Instance) {

                uielement.domElement.tipTip(tooltip);

            }

        }

        return tooltip;

    }

    /*===================================================
    
    css
    
    =====================================================*/

    function apply_css(property, value) {

        var map;

        if (typeof property === 'string') {

            this.domElement.css(_UIElement.supported_css_property(property), _UIElement.supported_css_value(value));

        } else if (property !== null && typeof property === 'object') {

            map = property;

            for (property in map) {

                if (map.hasOwnProperty(property)) {

                    this.apply_css(property, map[property]);

                }

            }

        }

    }

    function supported_css_property(property) {

        var i, l, propertyCamel, propertyPrefixed, propertySupported;

        // format property to camel case
        propertyCamel = _UIElement.str_to_camel(property);

        // use modernizr to check for correct css
        propertyPrefixed = Modernizr.prefixed(propertyCamel);

        // convert back to original hyphenated
        if (typeof propertyPrefixed === 'string') {

            propertySupported = propertyPrefixed; //_UIElement.str_from_camel( propertyPrefixed );
        }

        return propertySupported;

    }

    function supported_css_value(value) {

        var index;

        if (typeof value === 'string') {

            // linear gradient
            index = value.indexOf('linear-gradient');

            if (index !== -1) {

                return _UIElement.cssSpecialCases.lineargradient + value.substr(index + 'linear-gradient'.length, value.length);

            }

        }

        return value;

    }

    function str_to_camel(str) {

        // code based on camelize from prototype library
        var parts = str.split('-'),
            len = parts.length,
            camelized;

        if (len == 1) {

            return parts[0];

        }

        camelized = str.charAt(0) == '-' ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0];

        for (var i = 1; i < len; i++) {

            camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);

        }

        return camelized;

    }

    function str_from_camel(str) {

        return str.replace(/([A-Z])/g, function (match, m1) {
            return '-' + m1.toLowerCase();
        }).replace(/^ms-/, '-ms-');

    }

    /*===================================================
    
    themes
    
    =====================================================*/

    function generate_theme(theme, overrides) {

        return (this.themes[theme] || this.themes.core).call(this, overrides);

    }

    function theme_core(overrides) {

        var theme, cssmap, or;

        // deep copy all overrides into theme
        theme = main.extend(overrides, {}, true);

        // cssmap
        or = overrides.cssmap || {};

        cssmap = theme.cssmap = theme.cssmap || {};

        cssmap["position"] = or["position"] || "absolute";
        cssmap["display"] = or["display"] || "block";
        cssmap["transform-origin"] = or["transform-origin"] || "50% 50%";

        // state last
        theme.stateLast = {};

        return theme;

    }

    function theme_white(overrides) {

        var theme = this.themes.core.call(this, overrides),
            cssmap, enabled, disabled, or;

        // cssmap
        or = overrides.cssmap || {};

        cssmap = theme.cssmap = theme.cssmap || {};

        cssmap["box-shadow"] = or["box-shadow"] || "-2px 2px 10px rgba(0, 0, 0, 0.15)";

        // enabled state
        or = overrides.enabled || {};

        enabled = theme.enabled = theme.enabled || {};

        enabled["color"] = or["color"] || "#333333";
        enabled["background-color"] = or["background-color"] || "#eeeeee";
        //enabled[ "background-image" ] = or[ "background-image" ] || "linear-gradient(top, #eeeeee 30%, #cccccc 100%)";
        // disabled state
        or = overrides.disabled || {};

        disabled = theme.disabled = theme.disabled || {};

        disabled["color"] = or["color"] || "#777777";
        disabled["background-color"] = or["background-color"] || "#bbbbbb";
        //disabled[ "background-image" ] = or[ "background-image" ] || "linear-gradient(top, #cccccc 30%, #aaaaaa 100%)";
        return theme;

    }

    function theme_green(overrides) {

        var theme = this.themes.white.call(this, overrides),
            enabled, disabled, or;

        // enabled state
        or = overrides.enabled || {};

        enabled = theme.enabled = theme.enabled || {};

        enabled["background-color"] = or["background-color"] || "#5FEDA6";

        // disabled state
        or = overrides.disabled || {};

        disabled = theme.disabled = theme.disabled || {};

        disabled["background-color"] = or["background-color"] || "#48B57F";

        return theme;

    }

    function theme_red(overrides) {

        var theme = this.themes.white.call(this, overrides),
            enabled, disabled, or;

        // enabled state
        or = overrides.enabled || {};

        enabled = theme.enabled = theme.enabled || {};

        enabled["background-color"] = or["background-color"] || "#ED8181";

        // disabled state
        or = overrides.disabled || {};

        disabled = theme.disabled = theme.disabled || {};

        disabled["background-color"] = or["background-color"] || "#BA6565";

        return theme;

    }

}(KAIOPUA));

/*
 *
 * Button.js
 * Generic ui button.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/ui/Button.js",
        _Button = {},
        _UIElement;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Button,
        requirements: ["assets/modules/ui/UIElement.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(uie) {
        console.log('internal button', _Button);

        _UIElement = uie;

        // instance
        _Button.Instance = Button;
        _Button.Instance.prototype = new _UIElement.Instance();
        _Button.Instance.prototype.constructor = _Button.Instance;
        _Button.Instance.prototype.supr = _UIElement.Instance.prototype;

        _Button.Instance.prototype.enter = enter;
        _Button.Instance.prototype.leave = leave;
        _Button.Instance.prototype.active = active;
        _Button.Instance.prototype.trigger = trigger;
        _Button.Instance.prototype.cooldown = cooldown;

        _Button.Instance.prototype.themes = {};
        _Button.Instance.prototype.themes.core = theme_core;
        _Button.Instance.prototype.themes.white = theme_white;
        _Button.Instance.prototype.themes.green = theme_green;
        _Button.Instance.prototype.themes.red = theme_red;

    }

    /*===================================================
    
    ui
    
    =====================================================*/

    function Button(parameters) {

        var me = this,
            imgDomElement;

        // handle parameters
        parameters = parameters || {};

        parameters.theme = parameters.theme || 'white';

        // prototype constructor
        _UIElement.Instance.call(this, parameters);

        // properties
        // add text
        if (typeof parameters.text === 'string') {

            this.text = new _UIElement.Instance({
                id: this.id + '_text',
                html: parameters.text
            });

        }

        // image
        if (parameters.image instanceof _UIElement.Instance) {

            this.image = parameters.image;

        } else if (typeof parameters.image === 'string') {

            this.image = new _UIElement.Instance({
                id: this.id + '_image',
                elementType: 'img',
                src: parameters.image,
                imgLoadCallback: function () {
                    me.image.align_once(me.image.alignment || 'center');
                },
                width: main.is_number(parameters.imageWidth) ? parameters.imageWidth : parameters.imageSize,
                height: main.is_number(parameters.imageHeight) ? parameters.imageHeight : parameters.imageSize
            });

        }

        // if image
        if (this.image instanceof _UIElement.Instance) {

            this.image.pointerEvents = false;

            this.image.align_once(parameters.imageAlignment || 'center');

            this.add(this.image);

        }

        // if no image or force text with image, fallback to text
        if (this.text instanceof _UIElement.Instance && (this.image instanceof _UIElement.Instance === false || parameters.textWithImage === true)) {

            this.text.pointerEvents = false;

            this.text.align_once(parameters.textAlignment || 'center');

            this.add(this.text);

        }

        // data
        this.data = main.ensure_array(parameters.data);

        // callback
        this.callback = parameters.callback;

        // context
        this.context = parameters.context || this;

        // bubble
        this.bubble = (typeof parameters.bubble === 'boolean' ? parameters.bubble : true);

        // cooldown
        this.timeCooldown = main.is_number(parameters.timeCooldown) ? parameters.timeCooldown : 100;

        // parent
        this.parent = undefined;

        // events
        this.domElement.on('mouseenter.btn touchenter.btn', function (e) {
            me.enter(e);
        });
        this.domElement.on('mouseleave.btn touchleave.btn', function (e) {
            me.leave(e);
        });
        this.domElement.on('mousedown touchstart', function (e) {
            me.active(e)
        });
        this.domElement.on('mouseup.btn touchend.btn', function (e) {
            me.trigger(e);
        });

    }

    /*===================================================
    
    enter / leave
    
    =====================================================*/

    function enter(e) {

        if (this.enabled) {

            this.apply_css(this.theme.enter);

        }

    }

    function leave(e) {

        this.apply_css(this.theme.stateLast);

    }

    /*===================================================
    
    trigger
    
    =====================================================*/

    function active(e) {

        if (e && this.bubble === false) {

            e.preventDefault();
            e.stopPropagation();
            return false;

        }

    }

    function trigger(e) {

        if (typeof this.callback !== 'undefined' && this.enabled === true && this.hidden !== true && this.isVisible === true) {

            this.callback.apply(this.context || window, main.ensure_array(this.data));

        }

        if (e && this.bubble === false) {

            e.preventDefault();
            e.stopPropagation();
            return false;

        }

    }

    function cooldown() {

        var me = this;

        if (this.timeCooldown > 0) {

            this.disable();

            requestTimeout(function () {
                me.enable();
            }, this.timeCooldown);

        }

    }

    /*===================================================
    
    themes
    
    =====================================================*/

    function theme_core(overrides) {

        var theme, cssmap, enabled, disabled, enter, or;

        // proto
        theme = _Button.Instance.prototype.supr.themes.core.call(this, overrides);

        // cssmap
        or = overrides.cssmap || {};

        cssmap = theme.cssmap = theme.cssmap || {};

        cssmap["font-size"] = or["font-size"] || "24px";
        cssmap["font-family"] = or["font-family"] || "'OpenSansRegular', Helmet, Freesans, sans-serif";

        // enabled state
        or = overrides.enabled || {};

        enabled = theme.enabled = theme.enabled || {};

        enabled["cursor"] = or["cursor"] || "pointer";

        // disabled state
        or = overrides.disabled || {};

        disabled = theme.disabled = theme.disabled || {};

        disabled["cursor"] = or["cursor"] || "default";

        // enter state
        or = overrides.enter || {};

        enter = theme.enter = theme.enter || {};

        enter["color"] = or["color"] || "#222222";

        return theme;

    }

    function theme_white(overrides) {

        var supr = _Button.Instance.prototype.supr,
            theme = (supr.themes['white'] || supr.themes.core).call(this, overrides),
            enter, or;

        // enter state
        or = overrides.enter || {};

        enter = theme.enter = theme.enter || {};

        enter["background-color"] = or["background-color"] || "#ffffff";

        return theme;

    }

    function theme_green(overrides) {

        var supr = _Button.Instance.prototype.supr,
            theme = (supr.themes['green'] || supr.themes.core).call(this, overrides),
            enter, or;

        // enter state
        or = overrides.enter || {};

        enter = theme.enter = theme.enter || {};

        enter["background-color"] = or["background-color"] || "#66FFB2";

        return theme;

    }

    function theme_red(overrides) {

        var supr = _Button.Instance.prototype.supr,
            theme = (supr.themes['red'] || supr.themes.core).call(this, overrides),
            enter, or;

        // enter state
        or = overrides.enter || {};

        enter = theme.enter = theme.enter || {};

        enter["background-color"] = or["background-color"] || "#FF8A8A";

        return theme;

    }

}(KAIOPUA));

/*
 *
 * Menu.js
 * Handles collections of buttons.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/ui/Menu.js",
        _Menu = {},
        _UIElement, _Button, _MathHelper, sincos45 = Math.cos(Math.PI * 0.25);

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Menu,
        requirements: ["assets/modules/ui/UIElement.js", "assets/modules/ui/Button.js", "assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(uie, btn, mh) {
        console.log('internal menu', _Menu);
        _UIElement = uie;
        _Button = btn;
        _MathHelper = mh;

        // instance
        _Menu.Instance = Menu;
        _Menu.Instance.prototype = new _Button.Instance();
        _Menu.Instance.prototype.constructor = _Menu.Instance;
        _Menu.Instance.prototype.supr = _Button.Instance.prototype;

        _Menu.Instance.prototype.show = show;
        _Menu.Instance.prototype.hide = hide;

        _Menu.Instance.prototype.show_children = show_children;
        _Menu.Instance.prototype.hide_children = hide_children;
        _Menu.Instance.prototype.child_arrange_dependent = child_arrange_dependent;
        _Menu.Instance.prototype.child_arrange_independent = child_arrange_independent;

        _Menu.Instance.prototype.open = open;
        _Menu.Instance.prototype.close = close;
        _Menu.Instance.prototype.close_self = close_self;
        _Menu.Instance.prototype.child_opening = child_opening;
        _Menu.Instance.prototype.child_closing = child_closing;

        _Menu.Instance.prototype.set_arrangement = set_arrangement;
        _Menu.Instance.prototype.update_arrangement = update_arrangement;
        _Menu.Instance.prototype.complete_arrangement = complete_arrangement;
        _Menu.Instance.prototype.get_children_for_arrangement = get_children_for_arrangement;
        _Menu.Instance.prototype.arrange_to_child = arrange_to_child;
        _Menu.Instance.prototype.arrange_line = arrange_line;
        _Menu.Instance.prototype.arrange_circle = arrange_circle;

        _Menu.Instance.prototype.themes = {};
        _Menu.Instance.prototype.themes.core = theme_core;

        Object.defineProperty(_Menu.Instance.prototype, 'buttonOpen', {
            get: function () {
                return this._buttonOpen;
            },
            set: function (button) {

                var hadButtons = this.hasOpenCloseButtons;

                if (button instanceof _Button.Instance) {

                    if (typeof button.callback !== 'function') {

                        button.callback = this.open;
                        button.context = this;

                    }

                    if (this._buttonOpen instanceof _Button.Instance) {

                        this.remove(this._buttonOpen);

                    }

                    this._buttonOpen = button;

                    this.add(this._buttonOpen);

                    if (hadButtons === false && this.hasOpenCloseButtons) {

                        this.close();

                    }

                }

            }
        });

        Object.defineProperty(_Menu.Instance.prototype, 'buttonClose', {
            get: function () {
                return this._buttonClose;
            },
            set: function (button) {

                var hadButtons = this.hasOpenCloseButtons;

                if (button instanceof _Button.Instance) {

                    if (typeof button.callback !== 'function') {

                        button.callback = this.close;
                        button.context = this;

                    }

                    if (this._buttonClose instanceof _Button.Instance) {

                        this.remove(this._buttonClose);

                    }

                    this._buttonClose = button;

                    this.add(this._buttonClose);

                    if (hadButtons === false && this.hasOpenCloseButtons) {

                        this.close();

                    }

                }

            }
        });

        Object.defineProperty(_Menu.Instance.prototype, 'hasOpenCloseButtons', {
            get: function () {
                return this.buttonOpen instanceof _Button.Instance && this.buttonClose instanceof _Button.Instance;
            }
        });

        Object.defineProperty(_Menu.Instance.prototype, 'isOpen', {
            get: function () {
                return this._isOpen;
            },
            set: function (state) {

                if (state === true) {

                    this.open();

                } else {

                    this.close();

                }

            }
        });

        Object.defineProperty(_Menu.Instance.prototype, 'arrangement', {
            get: function () {
                return this._arrangement;
            },
            set: function (type) {
                this.set_arrangement(type);
            }
        });

        Object.defineProperty(_Menu.Instance.prototype, 'alignmentOpen', {
            get: function () {
                return this._alignmentOpen;
            },
            set: function (location) {

                if (typeof location === 'string') {

                    this._alignmentOpen = location.toLowerCase();

                } else {

                    this._alignmentOpen = false;

                }

                if (this.isOpen) {

                    this.alignment = this._alignmentOpen;

                }

            }
        });

        Object.defineProperty(_Menu.Instance.prototype, 'alignmentClosed', {
            get: function () {
                return this._alignmentClosed;
            },
            set: function (location) {

                if (typeof location === 'string') {

                    this._alignmentClosed = location.toLowerCase();

                } else {

                    this._alignmentClosed = false;

                }

                if (this.isOpen !== true) {

                    this.alignment = this._alignmentClosed;

                }

            }
        });

    }

    /*===================================================
    
    ui
    
    =====================================================*/

    function Menu(parameters) {

        // handle parameters
        parameters = parameters || {};

        parameters.elementType = parameters.elementType || 'section';

        parameters.text = parameters.image = undefined;

        parameters.pointerEvents = false;

        // prototype constructor
        _Button.Instance.call(this, parameters);

        // properties
        this.independent = [];

        this.openAlone = typeof parameters.openAlone === 'boolean' ? parameters.openAlone : true;

        // remove button events from self
        this.domElement.off('.btn');

        // create new buttons for self
        // open
        if (parameters.buttonOpen instanceof _Button.Instance) {

            this.buttonOpen = parameters.buttonOpen;

        } else if (main.type(parameters.buttonOpen) === 'object') {

            this.buttonOpen = new _Button.Instance(parameters.buttonOpen);

        }

        // close
        if (parameters.buttonClose instanceof _Button.Instance) {

            this.buttonClose = parameters.buttonClose;

        } else if (main.type(parameters.buttonClose) === 'object') {

            this.buttonClose = new _Button.Instance(parameters.buttonClose);

        }

        // alignment open/close
        this.alignmentOpen = typeof parameters.alignmentOpen === 'boolean' ? parameters.alignmentOpen : false;
        this.alignmentClosed = typeof parameters.alignmentClosed === 'boolean' ? parameters.alignmentClosed : false;

        // if no close or open buttons, open automatically
        if (this.buttonOpen instanceof _Button.Instance === false || this.buttonClose instanceof _Button.Instance === false) {

            this.open();

        }
        // else set buttons properties and close
        else {

            this.close();

        }

        // set arrangement
        this.arrangement = parameters.arrangement || 'line';

    }

    /*===================================================
    
    show / hide
    
    =====================================================*/

    function show() {

        // proto
        _Menu.Instance.prototype.supr.show.apply(this, arguments);

        if (this.isOpen) {

            this.close({
                time: 0
            });

        }

    }

    function hide() {

        // proto
        _Menu.Instance.prototype.supr.hide.apply(this, arguments);

        this.close();

    }

    /*===================================================
    
    children
    
    =====================================================*/

    function show_children(parameters) {

        // if closed, modify children to only include open button
        //console.log(this.id, 'menu show children, arguments', arguments );
        if (this.hasOpenCloseButtons) {

            // handle parameters
            parameters = parameters || {};

            // if closed, only show open button
            if (this.isOpen === false) {

                parameters.children = this.buttonOpen;

            }
            // if open, exclude open button from show
            else {

                parameters.excluding = [this.buttonOpen].concat(parameters.excluding || []);

            }

        }

        // proto
        _Menu.Instance.prototype.supr.show_children.call(this, parameters);

        this.update_arrangement();

    }

    function hide_children(parameters) {

        //console.log(this.id, 'menu hide children, arguments', arguments );
        if (this.hasOpenCloseButtons) {

            // handle parameters
            parameters = parameters || {};

            // if closed, exclude open button from hide
            if (this.isOpen === false) {

                parameters.excluding = [this.buttonOpen].concat(parameters.excluding || []);

            }

        }

        // proto
        _Menu.Instance.prototype.supr.hide_children.call(this, parameters);

        this.update_arrangement();

    }

    function child_arrange_dependent(child) {

        var index = this.independent.indexOf(child);

        if (index !== -1) {

            this.independent.splice(index, 1);

        }

    }

    function child_arrange_independent(child) {

        var index = this.independent.indexOf(child);

        if (index === -1) {

            this.independent.push(child);

        }

    }

    /*===================================================
    
    open / close
    
    =====================================================*/

    function open(time, callback, callbackContext) {

        if (this.isOpen !== true) {

            this._isOpen = true;
            //console.log( this.id, 'OPENING' );
            if (this.hasOpenCloseButtons) {

                this.alignment = this.alignmentOpen;

                if (this.parent instanceof _Menu.Instance) {

                    this.parent.child_opening(this, time);

                }

                if (this.openAlone) {

                    open_alone(this, time, callback, callbackContext);

                } else {

                    open_with_others(this, time, callback, callbackContext);

                }

            } else {

                this.show_children({
                    time: time
                });

            }

        }

    }

    function open_alone(menu, time, callback, callbackContext) {

        menu.buttonOpen.hide({
            remove: true,
            time: time,
            callback: function () {

                menu.show_children({
                    time: time
                });

                menu.buttonClose.show({
                    parent: menu,
                    time: time
                });

                if (typeof callback === 'function') {

                    if (typeof callbackContext !== 'undefined') {
                        callback.call(callbackContext);
                    } else {
                        callback();
                    }

                }

            },
            callbackContext: menu
        });

    }

    function open_with_others(menu, time, callback, callbackContext) {

        menu.show_children({
            time: time,
            excluding: menu.buttonClose
        });

        menu.buttonClose.show({
            time: time
        });

        if (typeof callback === 'function') {

            if (typeof callbackContext !== 'undefined') {
                callback.call(callbackContext);
            } else {
                callback();
            }

        }

    }

    function close(parameters, child) {

        var i, l, children, subchild;

        parameters = parameters || {};

        child = child instanceof _UIElement.Instance ? child : this;

        children = this.copy_children_and_exclude(child.children, parameters.excluding);

        for (i = 0, l = children.length; i < l; i++) {

            subchild = children[i];

            this.close(parameters, subchild);

        }

        if (child instanceof _Menu.Instance) {

            child.close_self(parameters.time);

        }

    }

    function close_self(time) {

        // only close if both open and close buttons are valid
        if (this.hasOpenCloseButtons) {
            //console.log( this.id, 'CLOSING' );
            this._isOpen = false;

            this.hide_children({
                time: time
            });

            this.buttonClose.hide({
                remove: true,
                time: time,
                callback: function () {

                    this.buttonOpen.show({
                        parent: this,
                        time: time
                    });

                    this.alignment = this.alignmentClosed;

                    this.update_arrangement();

                    if (this.parent instanceof _Menu.Instance) {

                        this.parent.child_closing(this, time);

                    }

                },
                callbackContext: this
            });

        }

    }

    function child_opening(child, time) {

        this.childOpen = child;

        if (child.openAlone) {
            //console.log( this.id, ' child, ', child.id, ', OPENING solo' );
            this.hide_children({
                excluding: child,
                time: time
            });

        } else {
            //console.log( this.id, ' child, ', child.id, ', OPENING with others, order?', this.get_child_order( child ) );
            this.close({
                excluding: child,
                time: time
            });

            this.add(child.buttonOpen, this.childrenOrder[child.id], child.buttonClose, 9999);

        }

    }

    function child_closing(child, time) {

        if (this.isOpen && this.childOpen === child) {
            //console.log( this.id, ' child, ', child.id, ', CLOSING' );
            if (child.openAlone) {

                this.show_children({
                    time: time
                });

                this.childOpen = undefined;

            } else {

                this.remove(child.buttonOpen, child.buttonClose);

            }

        }

    }

    /*===================================================
    
    arrangements
    
    =====================================================*/

    function set_arrangement(type, parameters) {

        this._arrangement = type;
        this.arrangementParameters = parameters;

        // set by type, default to line
        if (this.arrangement === 'circle') {

            this.arrange_circle();

        } else if (this.arrangement === 'line') {

            this.arrange_line();

        }

    }

    function update_arrangement() {

        if (this.get_children_showing().length > 0) {

            this.set_arrangement(this.arrangement, this.arrangementParameters);

        }

    }

    function get_children_for_arrangement() {

        var i, l, child, showing = this.get_children_showing(),
            arranging = [];

        for (i = 0, l = showing.length; i < l; i++) {

            child = showing[i];

            // if child is not aligned or independent in menu
            if (typeof child.alignment !== 'string' && this.independent.indexOf(child) === -1) {

                arranging.push(child);

            }

        }

        return arranging;
    }

    function complete_arrangement() {

        var i, l, child;

        if (this.parent instanceof _Menu.Instance) {

            this.parent.update_arrangement();

        }

        this.align();

        children = this.get_children_showing();

        for (i = 0, l = children.length; i < l; i++) {

            child = children[i];

            child.align();

        }

    }

    function arrange_to_child(child) {

        this.width = this.spacingLeft + this.spacingRight;
        this.height = this.spacingTop + this.spacingBottom;

        if (child instanceof _UIElement.Instance) {

            this.width += child.outerWidth;
            this.height += child.outerHeight;

            child.set_position(child.spacingLeft, child.spacingTop);

        }

        this.complete_arrangement();

    }

    function arrange_line(parameters) {

        var i, l, ib, children, degrees, circular, childrenPerLine, indexStart, widthTotal, heightTotal, bounds, theta, indexEnd, child, cw, ch, rw, rh, thetaCos, thetaSin, thetaCosAbs, thetaSinAbs, thetaCosRnd, thetaSinRnd, x, y, xmax = 0,
            xmin = 0,
            ymax = 0,
            ymin = 0,
            multiline = false;

        // init persistant info
        // can only copy certain parameters due to recursion
        if (this._arrangement !== 'line' || main.type(this.arrangementParameters) !== 'object') {

            this._arrangement = 'line';
            this.arrangementParameters = {};

        }

        // handle parameters
        parameters = parameters || {};

        degrees = this.arrangementParameters.degrees = parameters.degrees = _MathHelper.degree_between_180(parameters.degrees || this.arrangementParameters.degrees || 0);
        circular = this.arrangementParameters.circular = parameters.circular = (typeof parameters.circular === 'boolean' ? parameters.circular : (typeof this.arrangementParameters.circular === 'boolean' ? this.arrangementParameters.circular : false));
        childrenPerLine = this.arrangementParameters.childrenPerLine = parameters.childrenPerLine = (main.is_number(parameters.childrenPerLine) ? parameters.childrenPerLine : this.arrangementParameters.childrenPerLine);
        children = parameters.children = parameters.children || this.get_children_for_arrangement();

        // if only 1 child, skip arrange and fit to child
        if (children.length <= 1) {

            this.arrange_to_child(children[0]);

        } else {

            // theta passed in degrees
            theta = _MathHelper.degree_to_rad(degrees);
            thetaCos = Math.cos(theta);
            thetaSin = Math.sin(theta);

            // if children per line passed as a string suggesting vertical or horizontal preference
            if (childrenPerLine === 'v') {

                childrenPerLine = Math.floor(Math.sqrt(children.length));

            } else if (childrenPerLine === 'h') {

                childrenPerLine = Math.ceil(Math.sqrt(children.length));

            }

            // if splitting into multiple lines
            if (main.is_number(childrenPerLine) && childrenPerLine > 0 && childrenPerLine < children.length) {

                multiline = true;

            }
            // else all children on one line
            else {

                childrenPerLine = children.length;

            }

            indexStart = parameters.indexStart = _MathHelper.clamp((main.is_number(parameters.indexStart) ? parameters.indexStart : 0), 0, children.length);

            widthTotal = main.is_number(parameters.widthTotal) ? parameters.widthTotal : 0;
            heightTotal = main.is_number(parameters.heightTotal) ? parameters.heightTotal : 0;

            if (main.type(parameters.bounds) !== 'object') {

                bounds = parameters.bounds = {
                    x: [],
                    rx: [],
                    y: [],
                    ry: []
                };

                for (i = 0, l = childrenPerLine; i < l; i++) {

                    bounds.x[i] = bounds.rx[i] = bounds.y[i] = bounds.ry[i] = 0;

                }

            } else {

                bounds = parameters.bounds;

            }

            indexEnd = Math.min(children.length, indexStart + childrenPerLine);

            // if arranging for rectangular children
            if (circular !== true) {

                thetaCosAbs = Math.abs(thetaCos);
                thetaSinAbs = Math.abs(thetaSin);

                thetaCosRnd = thetaCosAbs > thetaSinAbs ? Math.round(thetaCos) : (thetaCos / sincos45);
                thetaSinRnd = thetaSinAbs > thetaCosAbs ? Math.round(thetaSin) : (thetaSin / sincos45);

            }

            // arrange all children in line
            for (i = indexStart, l = indexEnd; i < l; i++) {

                child = children[i];

                cw = child.outerWidth;
                ch = child.outerHeight;

                ib = i - indexStart;

                if (circular === true) {

                    rw = cw * thetaCos;
                    rh = ch * thetaSin;

                } else {

                    rw = _MathHelper.max_magnitude(cw * thetaCos, cw * thetaCosRnd);
                    rh = _MathHelper.max_magnitude(ch * thetaSin, ch * thetaSinRnd);

                }

                child._x = bounds.rx[ib - 1] || bounds.rx[ib];
                child._y = bounds.ry[ib - 1] || bounds.ry[ib];

                bounds.x[ib] = child.x + cw;
                bounds.y[ib] = child.y + ch;
                bounds.rx[ib] = child.x + rw;
                bounds.ry[ib] = child.y + rh;

                // max/min
                if (bounds.x[ib] > xmax) {
                    xmax = bounds.x[ib];
                }
                if (child.x < xmin) {
                    xmin = child.x;
                }
                if (bounds.y[ib] > ymax) {
                    ymax = bounds.y[ib];
                }
                if (child.y < ymin) {
                    ymin = child.y;
                }

            }
            // set this dimensions
            widthTotal = parameters.widthTotal = xmax - xmin;
            heightTotal = parameters.heightTotal = ymax - ymin;

            this.width = widthTotal + this.spacingLeft + this.spacingRight;
            this.height = heightTotal + this.spacingTop + this.spacingBottom;

            // set positions of children
            for (i = indexStart, l = indexEnd; i < l; i++) {

                child = children[i];

                child.set_position(child.x + child.spacingLeft + this.spacingLeft - xmin, child.y + child.spacingTop + this.spacingTop - ymin);

            }

            // if is continuing multiline
            if (multiline === true && indexEnd < children.length) {

                parameters.indexStart = indexEnd;

                if ((degrees < 45 && degrees > -45) || degrees > 135 || degrees < -135) {

                    for (i = 0, l = childrenPerLine; i < l; i++) {
                        bounds.x[i] = 0;
                        bounds.y[i] = bounds.y[0];
                        bounds.rx[i] = 0;
                        bounds.ry[i] = bounds.y[0];
                    }

                } else {

                    for (i = 0, l = childrenPerLine; i < l; i++) {
                        bounds.x[i] = bounds.x[0];
                        bounds.y[i] = 0;
                        bounds.rx[i] = bounds.x[0];
                        bounds.ry[i] = 0;
                    }

                }

                this.arrange_line(parameters);

            }
            // finished
            else {

                this.complete_arrangement();

            }

        }

    }

    function arrange_circle(parameters) {

        var i, l, degreeStart, degrees, degreesAutoFit = false,
            direction, radius, spaceBySize, forceShape, children, radians, thetaStart, radiansPer, radiansActual, theta, thetaSin, thetaCos, circumference = 0,
            child, cw, ch, cwh, chh, size, xmax = 0,
            xmin = 0,
            ymax = 0,
            ymin = 0,
            widthTotal, heightTotal;

        // init persistant info
        // can only copy certain parameters due to recursion
        if (this._arrangement !== 'circle' || main.type(this.arrangementParameters) !== 'object') {

            this._arrangement = 'circle';
            this.arrangementParameters = {};

        }

        // handle parameters
        parameters = parameters || {};

        degreeStart = this.arrangementParameters.degreeStart = parameters.degreeStart = main.is_number(parameters.degreeStart) ? parameters.degreeStart : (main.is_number(this.arrangementParameters.degreeStart) ? this.arrangementParameters.degreeStart : 180);
        degrees = this.arrangementParameters.degrees = parameters.degrees = main.is_number(parameters.degrees) ? parameters.degrees : this.arrangementParameters.degrees;
        degreesAutoFit = this.arrangementParameters.degreesAutoFit = parameters.degreesAutoFit = typeof parameters.degreesAutoFit === 'boolean' ? parameters.degreesAutoFit : (typeof this.arrangementParameters.degreesAutoFit === 'boolean' ? this.arrangementParameters.degreesAutoFit : false);
        direction = this.arrangementParameters.direction = parameters.direction = main.is_number(parameters.direction) ? parameters.direction : (main.is_number(this.arrangementParameters.direction) ? this.arrangementParameters.direction : 1);
        radius = this.arrangementParameters.radius = parameters.radius = main.is_number(parameters.radius) ? parameters.radius : this.arrangementParameters.radius;
        spaceBySize = this.arrangementParameters.spaceBySize = parameters.spaceBySize = typeof parameters.spaceBySize === 'boolean' ? parameters.spaceBySize : this.arrangementParameters.spaceBySize;
        forceShapeOnOpen = this.arrangementParameters.forceShapeOnOpen = parameters.forceShapeOnOpen = typeof parameters.forceShapeOnOpen === 'boolean' ? parameters.forceShapeOnOpen : this.arrangementParameters.forceShapeOnOpen;
        children = parameters.children = parameters.children || this.get_children_for_arrangement();

        if (children.length <= 1 && (forceShapeOnOpen !== true || (this.isOpen !== true && this.buttonClose.hidden === true))) {

            this.arrange_to_child(children[0]);

        } else {

            // default theta start to 180 degrees ( left side )
            thetaStart = _MathHelper.degree_to_rad(degreeStart % 360);

            // if degrees not passed
            if (main.is_number(degrees) !== true || degrees === 0) {

                // if radius passed, determine exact degrees to fit all children
                if (degreesAutoFit && radius >= 0) {

                    radians = 0;

                    for (i = 0, l = children.length; i < l; i++) {

                        child = children[i];

                        radians += 2 * Math.asin(Math.max(child.outerWidth, child.outerHeight) / (2 * radius));

                    }

                    degrees = _MathHelper.rad_to_degree(radians);

                    // if children would go around more than once
                    // clamp to once and zero radius to auto-fit of radius
                    if (Math.abs(degrees) > 360) {

                        degrees = 360;
                        radius = 0;

                    }

                }
                // else default to 360
                else {

                    degrees = 360;

                }

            }

            // add an additional subtending angle to degrees, up to +/- 360, to ensure children end at expected degrees
            degrees = _MathHelper.clamp(degrees + (degreesAutoFit ? 0 : (degrees / Math.max(children.length - 1, 1))), -360, 360);

            radians = _MathHelper.degree_to_rad(degrees) * direction;

            // if radius not passed, determine exact to fit all children
            if (main.is_number(radius) !== true || radius <= 0) {

                radiansPer = radians / children.length;

                // find circumference from children
                // each addition to circumference is ( radius based on current child size ) * ( radians per child )
                // ( this assumes each child is roughly equal size, I think )
                for (i = 0, l = children.length; i < l; i++) {

                    child = children[i];

                    circumference += (Math.max(child.outerWidth, child.outerHeight) / (2 * Math.sin(radiansPer / 2))) * radiansPer;

                }

                radius = circumference / radians;

            } else {

                circumference = 2 * Math.PI * radius;

            }

            // ensure circumference is positive
            if (circumference < 0) {

                circumference = Math.abs(circumference);

            }

            // ensure radius is positive
            if (radius < 0) {

                radius = Math.abs(radius);

            }

            // arrange all children in circle from theta start to theta end
            for (i = 0, l = children.length; i < l; i++) {

                child = children[i];

                cw = child.outerWidth;
                ch = child.outerHeight;

                // get theta based on size
                // size is based on biggest dimension (because we dont have theta yet)
                if (spaceBySize === true) {

                    size = Math.max(cw, ch);

                    theta = thetaStart + (size / radius);

                }
                // else space evenly
                else {

                    theta = thetaStart + radians * (i / l); //( l - 1 ) );
                }

                thetaSin = Math.sin(theta);
                thetaCos = Math.cos(theta);

                // temporarily directly modify child x/y
                child._x = radius + radius * thetaCos;
                child._y = radius + radius * thetaSin;

                // max/min
                if (child.x + cw > xmax) {
                    xmax = child.x + cw;
                }
                if (child.x < xmin) {
                    xmin = child.x;
                }
                if (child.y + ch > ymax) {
                    ymax = child.y + ch;
                }
                if (child.y < ymin) {
                    ymin = child.y;
                }

            }

            // set this dimensions and positions of all children
            this.width = radius * 2 + this.spacingLeft + this.spacingRight;
            this.height = radius * 2 + this.spacingTop + this.spacingBottom;

            for (i = 0, l = children.length; i < l; i++) {

                child = children[i];

                child.set_position(child.x + child.spacingLeft + this.spacingLeft - child.outerWidthHalf, child.y + child.spacingTop + this.spacingTop - child.outerHeightHalf);

            }

            // finished
            this.complete_arrangement();

        }

    }

    /*===================================================
    
    themes
    
    =====================================================*/

    function theme_core(overrides) {

        var theme, cssmap, or;

        // proto
        theme = _Menu.Instance.prototype.supr.themes.core.call(this, overrides);

        // cssmap
        or = overrides.cssmap || {};

        cssmap = theme.cssmap = theme.cssmap || {};

        cssmap["cursor"] = or["cursor"] || "default";
        cssmap["background-color"] = or["background-color"] || "transparent";
        cssmap["background-image"] = or["background-image"] || "none";
        cssmap["box-shadow"] = or["box-shadow"] || "none";
        cssmap["border-radius"] = or["border-radius"] || "0";

        theme.enabled = or.enabled || {};
        theme.disabled = or.enabled || {};
        theme.enter = or.enter || {};
        theme.leave = or.leave || {};

        return theme;

    }

}(KAIOPUA));

/*
 *
 * GUI.js
 * Game user interface.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/ui/GUI.js",
        _GUI = {},
        _UIElement, _Button, _Menu;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _GUI,
        requirements: ["assets/modules/ui/UIElement.js", "assets/modules/ui/Button.js", "assets/modules/ui/Menu.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(uie, btn, mn) {
        console.log('internal gui', _GUI);

        _UIElement = uie;
        _Button = btn;
        _Menu = mn;

        // properties
        _GUI.sizes = {};
        _GUI.sizes.buttonLarge = 300;
        _GUI.sizes.buttonMedium = 160;
        _GUI.sizes.buttonSmall = 100;
        _GUI.sizes.iconLargeContainer = 100;
        _GUI.sizes.iconMediumContainer = 60;
        _GUI.sizes.iconSmallContainer = 40;
        _GUI.sizes.iconLarge = 64;
        _GUI.sizes.iconMedium = 32;
        _GUI.sizes.iconSmall = 16;
        _GUI.sizes.buttonSpacing = 10;

        _GUI.active = [];
        _GUI.groups = {};
        _GUI.groupsNames = [];

        // functions
        _GUI.generate_button_back = generate_button_back;
        _GUI.generate_button_close = generate_button_close;

        _GUI.show_group = show_group;
        _GUI.hide_group = hide_group;

        _GUI.add_to_group = add_to_group;
        _GUI.remove_from_group = remove_from_group;
        _GUI.clean_groups = clean_groups;

        _GUI.fullscreen_api = (function () {

            var fullScreenApi = {
                supportsFullScreen: false,
                isFullScreen: function () {
                    return false;
                },
                requestFullScreen: function () {},
                cancelFullScreen: function () {},
                fullScreenEventName: '',
                prefix: ''
            },
                browserPrefixes = 'webkit moz o ms khtml'.split(' ');

            // check for native support
            if (typeof document.cancelFullScreen != 'undefined') {
                fullScreenApi.supportsFullScreen = true;

            } else {
                // check for fullscreen support by vendor prefix
                for (var i = 0, il = browserPrefixes.length; i < il; i++) {
                    fullScreenApi.prefix = browserPrefixes[i];

                    if (typeof document[fullScreenApi.prefix + 'CancelFullScreen'] != 'undefined') {
                        fullScreenApi.supportsFullScreen = true;

                        break;
                    }
                }
            }

            // update methods to do something useful
            if (fullScreenApi.supportsFullScreen) {
                fullScreenApi.fullScreenEventName = fullScreenApi.prefix + 'fullscreenchange';

                fullScreenApi.isFullScreen = function () {
                    switch (this.prefix) {
                    case '':
                        return document.fullScreen;
                    case 'webkit':
                        return document.webkitIsFullScreen;
                    default:
                        return document[this.prefix + 'FullScreen'];
                    }
                }
                fullScreenApi.requestFullScreen = function (el) {
                    return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
                }
                fullScreenApi.cancelFullScreen = function (el) {
                    return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
                }
            }

            return fullScreenApi;

        }());

        // init
        init_core();

        init_layers();

        init_buttons();

        init_menus();

        // build
        build_gui();

    }

    /*===================================================
    
    close / back
    
    =====================================================*/

    function generate_button_back() {

        var button = new _Button.Instance({
            id: 'close',
            image: shared.pathToIcons + 'undo_64.png',
            imageSize: _GUI.sizes.iconSmall,
            width: _GUI.sizes.iconSmallContainer,
            tooltip: 'Go Back',
            spacingRight: _GUI.sizes.iconMediumContainer * 0.5 + _GUI.sizes.buttonSpacing,
            alignment: 'rightcenter',
            alignmentOutside: true,
            circle: true,
            theme: 'red'
        });

        return button;

    }

    function generate_button_close() {

        var button = new _Button.Instance({
            id: 'close',
            image: shared.pathToIcons + 'close_64.png',
            imageSize: _GUI.sizes.iconSmall,
            width: _GUI.sizes.iconSmallContainer,
            spacing: 0,
            alignment: 'righttop',
            alignmentOutside: true,
            circle: true,
            theme: 'red'
        });

        return button;

    }

    /*===================================================
    
    core
    
    =====================================================*/

    function init_core() {

        // container
        _GUI.container = new _UIElement.Instance({
            domElement: shared.html.gameContainer,
            fullwindow: true
        });

        // transitioner
        _GUI.transitioner = new _UIElement.Instance({
            id: 'transitioner',
            cssmap: {
                "background-color": "#333333"
            },
            fullwindow: true,
            timeShow: 500,
            timeHide: 500,
            opacityShow: 0.75
        });

    }

    /*===================================================
    
    layers
    
    =====================================================*/

    function init_layers() {

        var l = _GUI.layers = {};

        l.display = new _UIElement.Instance({
            id: 'layer_display',
            fullwindow: true
        });

        l.ui = new _UIElement.Instance({
            id: 'layer_ui',
            pointerEvents: false,
            fullwindow: true
        });

        l.uiPriority = new _UIElement.Instance({
            id: 'layer_uiPriority',
            pointerEvents: false,
            fullwindow: true
        });

        l.overlayDisplay = new _UIElement.Instance({
            id: 'layer_overlayDisplay',
            pointerEvents: false,
            fullwindow: true
        });

        l.overlayAll = new _UIElement.Instance({
            id: 'layer_overlayAll',
            pointerEvents: false,
            fullwindow: true
        });

        l.errors = new _UIElement.Instance({
            domElement: shared.html.errorContainer,
            pointerEvents: false,
            fullwindow: true
        });

    }

    /*===================================================
    
    buttons
    
    =====================================================*/

    function init_buttons() {

        var b = _GUI.buttons = {};

        // fullscreen disabled until allows alphanumeric input
        b.fullscreenEnter = new _Button.Instance({
            id: 'fullscreenEnter',
            image: shared.pathToIcons + 'fullscreen_32.png',
            imageSize: _GUI.sizes.iconSmall,
            size: _GUI.sizes.iconSmallContainer,
            tooltip: 'Fullscreen',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            callback: fullscreen_enter,
            context: this,
            alignment: 'bottomright',
            enabled: false
        });

        b.fullscreenEnter.hide({
            remove: true,
            time: 0
        });

        b.fullscreenExit = new _Button.Instance({
            id: 'fullscreenExit',
            image: shared.pathToIcons + 'fullscreen_exit_32.png',
            imageSize: _GUI.sizes.iconSmall,
            size: _GUI.sizes.iconSmallContainer,
            tooltip: 'Exit Fullscreen',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            callback: fullscreen_exit,
            context: this,
            alignment: 'bottomright',
            enabled: false
        });

        b.fullscreenExit.hide({
            remove: true,
            time: 0
        });


        b.end = new _Button.Instance({
            id: 'end',
            image: shared.pathToIcons + 'confirm_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Really Quit?',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true
        });

        b.save = new _Button.Instance({
            id: 'save',
            image: shared.pathToIcons + 'save_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Save progress',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        });

        b.load = new _Button.Instance({
            id: 'load',
            image: shared.pathToIcons + 'load_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: {
                content: 'Load a saved game',
                contentDisabled: '(no save found!)'
            },
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        });

        b.mainMenu = new _Button.Instance({
            id: 'mainMenu',
            image: shared.pathToIcons + 'computer_alt_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Main Menu',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true
        });

        b.companionMenu = new _Button.Instance({
            id: 'companionMenu',
            image: shared.pathToIcons + 'companion_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Companions!',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        });

        b.houseMenu = new _Button.Instance({
            id: 'houseMenu',
            image: shared.pathToIcons + 'home_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'House Parts',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        });

        b.map = new _Button.Instance({
            id: 'map',
            image: shared.pathToIcons + 'whale_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Map',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        });

    }

    /*===================================================
    
    menus
    
    =====================================================*/

    function init_menus() {

        var m = _GUI.menus = {};

        // init
        m.start = new _Menu.Instance({
            id: 'start'
        });

        m.main = new _Menu.Instance({
            id: 'main'
        });

        m.options = new _Menu.Instance({
            id: 'options'
        });

        m.navigation = new _Menu.Instance({
            id: 'navigation'
        });

        m.end = new _Menu.Instance({
            id: 'end'
        });

        m.footer = new _UIElement.Instance({
            domElement: shared.html.footerMenu
        });

    }

    function build_start_menu() {

        var m = _GUI.menus,
            b = _GUI.buttons;

        m.start.hide({
            remove: true,
            time: 0
        });

        m.start.add(
        new _Button.Instance({
            id: 'play',
            text: 'Play!',
            theme: 'white',
            size: _GUI.sizes.buttonMedium,
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            cssmap: {
                'font-size': "30px",
                'font-family': "'CoustardRegular', Georgia, serif"
            },
            alignment: 'center'
        }), b.load, m.options);

        m.start.childrenAlwaysVisible.push(m.start.childrenByID.play);

        m.start.arrange_circle({
            degrees: 360,
            radius: _GUI.sizes.buttonMedium + _GUI.sizes.buttonSpacing
        });

    }

    function build_main_menu() {

        var m = _GUI.menus,
            b = _GUI.buttons;

        m.main.hide({
            remove: true,
            hide: 0
        });

        m.main.add(
        new _Button.Instance({
            id: 'resume',
            text: 'Resume',
            width: _GUI.sizes.buttonMedium,
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            cssmap: {
                'font-size': "30px",
                'font-family': "'CoustardRegular', Georgia, serif"
            },
            alignment: 'center'
        }), b.save, b.load, m.options, m.end);

        m.main.childrenAlwaysVisible.push(m.main.childrenByID.resume);

        m.main.arrange_circle({
            degrees: 360,
            radius: _GUI.sizes.buttonMedium + _GUI.sizes.buttonSpacing
        });

    }

    function build_navigation_menu() {

        var m = _GUI.menus,
            b = _GUI.buttons;

        m.navigation.hide({
            remove: true,
            hide: 0
        });

        m.navigation.add(
        b.companionMenu, b.houseMenu, b.map, b.mainMenu, 9999);

        m.navigation.arrange_line();

    }

    function build_options_menu() {

        var m = _GUI.menus;

        m.options.buttonOpen = new _Button.Instance({
            id: 'open',
            image: shared.pathToIcons + 'cog_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Options',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true
        });

        m.options.buttonClose = _GUI.generate_button_back();

        m.options.add(
        new _Button.Instance({
            id: 'quality',
            theme: 'white',
            image: shared.pathToIcons + 'computer_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Quality',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        }), new _Button.Instance({
            id: 'keybindings',
            theme: 'white',
            image: shared.pathToIcons + 'keyboard_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Keybindings',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        }), new _Button.Instance({
            id: 'mouse',
            theme: 'white',
            image: shared.pathToIcons + 'mouse_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Hand Orientation',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        }), new _Button.Instance({
            id: 'volume',
            theme: 'white',
            image: shared.pathToIcons + 'sound_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Volume',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        }), new _Button.Instance({
            id: 'accessibility',
            theme: 'white',
            image: shared.pathToIcons + 'accessibility_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'Accessibility',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true,
            enabled: false
        }));

        m.options.arrange_circle({
            degreeStart: 0,
            direction: -1,
            radius: _GUI.sizes.buttonMedium + _GUI.sizes.buttonSpacing
        });

    }

    function build_end_menu() {

        var m = _GUI.menus,
            b = _GUI.buttons;

        m.end.buttonOpen = new _Button.Instance({
            id: 'open',
            image: shared.pathToIcons + 'exit_64.png',
            imageSize: _GUI.sizes.iconMedium,
            size: _GUI.sizes.iconMediumContainer,
            tooltip: 'End Game',
            spacing: _GUI.sizes.buttonSpacing,
            circle: true
        });

        m.end.buttonClose = _GUI.generate_button_back();

        m.end.add(b.end);

        m.end.arrange_circle({
            degreeStart: 0,
            radius: _GUI.sizes.buttonMedium + _GUI.sizes.buttonSpacing,
            forceShapeOnOpen: true
        });

    }

    function build_footer_menu() {

        var m = _GUI.menus;

        m.footer.width = m.footer.domElement.width();
        m.footer.height = m.footer.domElement.height();
        m.footer.domElement.removeClass('sticky_footer');
        m.footer.alignment = 'bottomcenter';

    }

    /*===================================================
    
    build
    
    =====================================================*/

    function build_gui() {

        var l = _GUI.layers,
            b = _GUI.buttons,
            m = _GUI.menus,
            c = _GUI.container;

        // menus
        build_start_menu();

        build_navigation_menu();

        build_options_menu();

        build_end_menu();

        build_main_menu();

        build_footer_menu();

        // layers
        c.add(l.display, l.overlayDisplay, l.ui, l.uiPriority, l.overlayAll, l.errors, m.footer);

    }

    /*===================================================
    
    fullscreen
    
    =====================================================*/

    function fullscreen_enter() {

        var b = _GUI.buttons,
            c = _GUI.container,
            parent;

        _GUI.fullscreen_api.requestFullScreen(c.domElement.get(0));

        parent = b.fullscreenEnter.parent;

        b.fullscreenEnter.hide({
            remove: true,
            callback: function () {
                b.fullscreenExit.show({
                    parent: parent
                });
            }
        });

        document.addEventListener(_GUI.fullscreen_api.fullScreenEventName, on_fullscreen_changed);

    }

    function on_fullscreen_changed() {

        if (_GUI.fullscreen_api.isFullScreen() !== true) {

            fullscreen_exit();

        }

    }

    function fullscreen_exit() {

        var b = _GUI.buttons,
            c = _GUI.container,
            parent;

        document.removeEventListener(_GUI.fullscreen_api.fullScreenEventName, on_fullscreen_changed);

        _GUI.fullscreen_api.cancelFullScreen(c.domElement.get(0));

        parent = b.fullscreenExit.parent;

        b.fullscreenExit.hide({
            remove: true,
            callback: function () {
                b.fullscreenEnter.show({
                    parent: parent
                });
            }
        });

    }

    /*===================================================
    
    ui groups
    
    =====================================================*/

    function show_group(groupName, parameters) {

        var i, l, group, children, parents, child, parent, parametersChild;

        if (_GUI.groups.hasOwnProperty(groupName)) {

            group = _GUI.groups[groupName];

            children = group.children;
            parents = group.parents;

            for (i = 0, l = children.length; i < l; i++) {

                child = children[i];
                parent = parents[i];

                parametersChild = main.extend(parameters, {});
                parametersChild.parent = parametersChild.parent || parent;

                child.show(parametersChild);

            }

        }

    }

    function hide_group(groupName, parameters) {

        var i, l, group, children, child;

        if (_GUI.groups.hasOwnProperty(groupName)) {

            group = _GUI.groups[groupName];

            children = group.children;

            for (i = 0, l = children.length; i < l; i++) {

                child = children[i];

                child.hide(parameters);

            }

        }

    }

    function add_to_group(groupName, childParentPairs) {

        var i, l, pair, child, parent, group, index;

        childParentPairs = main.ensure_array(childParentPairs);

        for (i = 0, l = childParentPairs.length; i < l; i++) {

            pair = childParentPairs[i];

            child = pair.child;

            parent = pair.parent;

            // add to active list
            index = _GUI.active.indexOf(child);

            if (index === -1) {

                _GUI.active.push(child);

            }

            if (typeof groupName === 'string') {

                // if group does not exist, create
                if (_GUI.groups.hasOwnProperty(groupName) === false) {

                    _GUI.groupsNames.push(groupName);
                    _GUI.groups[groupName] = {
                        children: [],
                        parents: []
                    };

                }

                group = _GUI.groups[groupName];

                index = group.children.indexOf(child);

                if (index === -1) {

                    group.children.push(child);
                    group.parents.push(parent);

                }

            }

        }

    }

    function remove_from_group(groupName, uielements) {

        var i, l, j, k, uielement, group, index;

        // search specific group
        if (_GUI.groups.hasOwnProperty(groupName)) {

            uielements = main.ensure_array(uielements);

            for (i = 0, l = uielements.length; i < l; i++) {

                uielement = uielements[i];

                group = _GUI.groups[groupName];

                index = group.children.indexOf(uielement);

                // if found, remove from group
                if (index !== -1) {

                    group.children.splice(index, 1);
                    group.parents.splice(index, 1);

                    // if nothing left in group, delete group
                    if (group.children.length === 0) {

                        index = _GUI.groupsNames.indexOf(groupName);

                        if (index !== -1) {

                            _GUI.groupsNames.splice(index, 1);

                        }

                        delete _GUI.groups[groupName];

                    }

                }

            }

        } else {

            // search for and remove from all groups
            for (i = _GUI.groupsNames.length - 1; i >= 0; i--) {

                remove_from_group(uielements, _GUI.groupsNames[i]);

            }

        }

    }

    function clean_groups(groupsNames, parameters) {

        var i, l, groupName, group, uielement;

        groupsNames = main.ensure_array(groupsNames);

        // if no group names passed, default to all groups
        if (groupsNames.length === 0) {

            groupsNames = _GUI.groupsNames.slice(0);

        }

        // clean each group
        for (i = 0, l = groupsNames.length; i < l; i++) {

            groupName = groupsNames[i];

            if (_GUI.groups.hasOwnProperty(groupName)) {

                group = _GUI.groups[groupName];

                for (i = 0, l = group.children.length; i < l; i++) {

                    uielement = group.children[i];

                    uielement.hide(parameters);

                }

                remove_from_group(groupName, group.children);

            }

        }

    }

}(KAIOPUA));

/*
 *
 * Messenger.js
 * UI to show messages to user.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/ui/Messenger.js",
        _Messenger = {},
        _UIElement, _Game, _GUI, active = false;

    /*===================================================
    
    public
    
    =====================================================*/

    main.asset_register(assetPath, {
        data: _Messenger,
        requirements: ["assets/modules/ui/UIElement.js", "assets/modules/core/Game.js", "assets/modules/ui/GUI.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(uie, g, gui) {
        console.log('internal messenger', _Messenger);

        _UIElement = uie;
        _Game = g;
        _GUI = gui;

        // properties
        _Messenger.timeLive = 2000;
        _Messenger.widthPctMax = 0.5;
        _Messenger.heightPctMax = 0.5;
        _Messenger.pulseTimeShow = 1000;
        _Messenger.pulseTimeHide = 1000;
        _Messenger.pulseOpacityShow = 1;
        _Messenger.pulseOpacityHide = 0.2;

        _Messenger.container = new _UIElement.Instance({
            id: 'messenger',
            alignment: 'center'
        });

        _Messenger.image = new _UIElement.Instance({
            id: 'image',
            elementType: 'img',
            cssmap: {
                'position': 'relative'
            }
        });

        _Messenger.title = new _UIElement.Instance({
            id: 'title',
            html: 'We <3 You',
            classes: 'title text_huge',
            cssmap: {
                'position': 'relative',
                'color': '#ffffff'
            }
        });

        _Messenger.body = new _UIElement.Instance({
            id: 'body',
            html: "Thanks for playing!",
            cssmap: {
                'position': 'relative',
                'color': '#ffffff'
            }
        });

        _Messenger.confirm = new _UIElement.Instance({
            id: 'confirm',
            html: "<p>press anything to continue</p>",
            classes: 'highlight text_small',
            cssmap: {
                'position': 'relative',
                'margin-top': '20px'
            }
        });

        _Messenger.confirm.hide({
            time: 0
        });

        // functions
        _Messenger.show_message = show_message;
        _Messenger.hide_message = hide_message;

    }

    /*===================================================
    
    message
    
    =====================================================*/

    function show_message(parameters) {

        var image, imageElement, title, body, callback;

        // hide current message
        _Messenger.hide_message();

        // handle parameters
        parameters = parameters || {};

        image = parameters.image;

        title = parameters.title;

        body = parameters.body;

        active = parameters.active || false;

        // image
        if (typeof image === 'string') {

            imageElement = _Messenger.image.domElement.get(0);

            imageElement.src = image;
            imageElement.onload = function () {
                _Messenger.image.align_once(_Messenger.image.alignment);
            }

            _Messenger.image.width = main.is_number(parameters.imageWidth) ? parameters.imageWidth : (main.is_number(parameters.imageSize) ? parameters.imageSize : 'auto');
            _Messenger.image.height = main.is_number(parameters.imageHeight) ? parameters.imageHeight : (main.is_number(parameters.imageSize) ? parameters.imageSize : 'auto');

            _Messenger.image.show({
                parent: _Messenger.container
            });

        } else {

            _Messenger.image.hide({
                remove: true,
                time: 0
            });

        }

        // title
        if (typeof title !== 'undefined') {

            _Messenger.title = update_message_element(_Messenger.title, title);

            _Messenger.title.show({
                parent: _Messenger.container
            });

        } else {

            _Messenger.title.hide({
                remove: true,
                time: 0
            });

        }

        // body
        if (typeof body !== 'undefined') {

            _Messenger.body = update_message_element(_Messenger.body, body);

            _Messenger.body.show({
                parent: _Messenger.container
            });

        } else {

            _Messenger.body.hide({
                remove: true,
                time: 0
            });

        }

        // if active message
        if (active === true) {

            _Game.pause(true);

            _GUI.transitioner.show({
                opacity: parameters.transitionerOpacity
            });

            // container
            callback = active_message_callback;

        } else {

            callback = passive_message_callback;

        }

        // ui
        _Messenger.container.width = 'auto';
        _Messenger.container.height = 'auto';

        _Messenger.container.show({
            parent: _GUI.layers.ui,
            callback: callback,
            callbackContext: this
        });

        // check width/height
        if (_Messenger.container.width > shared.screenWidth * _Messenger.widthPctMax) {

            _Messenger.container.width = shared.screenWidth * _Messenger.widthPctMax;

        }
        if (_Messenger.container.height > shared.screenHeight * _Messenger.heightPctMax) {

            _Messenger.container.height = shared.screenHeight * _Messenger.heightPctMax;

        }

        // align
        _Messenger.container.align();

    }

    function hide_message() {

        // signals
        shared.signals.keyup.remove(hide_message);
        shared.signals.mouseup.remove(hide_message);

        // clear timeout
        if (typeof _Messenger.liveTimeoutID !== 'undefined') {

            clearRequestTimeout(_Messenger.liveTimeoutID);

        }

        // was active message
        if (active === true) {

            active = false;

            _Game.resume();

        }

        // confirm
        _Messenger.confirm.hide({
            remove: true
        });

        // container
        _Messenger.container.hide({
            remove: true
        });

    }

    function update_message_element(element, parameters) {

        if (typeof parameters === 'string') {

            element.html = parameters;

        } else {

            // hide/remove previous
            element.hide({
                remove: true
            });

            // create new
            parameters.id = 'title';

            element = new _UIElement.Instance(parameters);

        }

        return element;

    }

    /*===================================================
    
    active
    
    =====================================================*/

    function active_message_callback() {

        _Messenger.confirm.pulse({
            parent: _Messenger.container,
            timeShow: _Messenger.pulseTimeShow,
            timeHide: _Messenger.pulseTimeHide,
            opacityShow: _Messenger.pulseOpacityShow,
            opacityHide: _Messenger.pulseOpacityHide
        });

        // signals
        shared.signals.keyup.add(hide_message);
        shared.signals.mouseup.add(hide_message);

    }

    /*===================================================
    
	passive
    
    =====================================================*/

    function passive_message_callback() {

        _Messenger.liveTimeoutID = requestTimeout(hide_message, _Messenger.timeLive);

    }

}(KAIOPUA));

/*
 *
 * ErrorHandler.js
 * Handles compatibility checks and user viewable errors.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/utils/ErrorHandler.js",
        _ErrorHandler = {},
        errorState = false,
        errorCurrent = {},
        errorHash = 'error=',
        errorTypes = {
            general: {
                header: "Well, that was embarrasing.",
                explanation: "We're very sorry about the error, but any progress you've made has been saved. <a href='" + shared.originLink + "'>All you need to do is reload the page.</a>"
            },
            webgl_browser: {
                header: "Oops! We need WebGL!",
                explanation: "We are sorry, but it appears that your browser does not support WebGL. For more information visit <a href='http://get.webgl.org' target='_blank'>Get WebGL</a> or try upgrading to one of these friendly browsers:",
                browser_extra: true
            },
            webgl_other: {
                header: "Oops! We need WebGL!",
                explanation: "Although your browser seems to support WebGL, it appears as if your computer does not. For more information visit the <a href='http://get.webgl.org/troubleshooting/' target='_blank'>WebGL troubleshooting</a> page."
            },
            fourohfour: {
                header: "We can't seem to find that page.",
                explanation: "Sorry, but the page you were trying to view does not exist. This is probably the result of either a mistyped address or an out-of-date link."
            },
            forbidden: {
                header: "We're afraid we can't let you do that.",
                explanation: "Sorry, but the page you were trying to view is locked or hidden for a reason we can't tell you."
            }
        },
        webglNames = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"],
        browser_html = "<div class='browsers_each chrome'><a href='http://www.google.com/chrome/' target='_blank'>Chrome</a></div><div class='browsers_each firefox'><a href='http://www.mozilla.org/firefox/' target='_blank'>Firefox</a></div><div class='browsers_each safari'><a href='http://www.apple.com/safari/' target='_blank'>Safari</a></div>";

    /*===================================================
    
    public properties
    
    =====================================================*/

    _ErrorHandler.check = check;
    _ErrorHandler.generate = generate;
    _ErrorHandler.process = process;
    _ErrorHandler.clear = clear;

    Object.defineProperty(_ErrorHandler, 'errorState', {
        get: function () {
            return errorState;
        }
    });

    main.asset_register(assetPath, {
        data: _ErrorHandler
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    // clear current errors
    clear();

    // check internal
    check_internal();

    function check_internal() {
        var canvas, context, errorType, i, l;

        // webgl browser check
        if (!window.WebGLRenderingContext) {
            errorType = 'webgl_browser';
        } else {
            canvas = document.createElement('canvas');

            // try each browser's webgl type
            for (i = 0, l = webglNames.length; i < l; i += 1) {
                try {
                    context = canvas.getContext(webglNames[i]);
                } catch (e) {}
                if (context !== null && typeof context !== 'undefined') {
                    break;
                }
            }

            // if none found, there is another problem
            if (context === null || typeof context === 'undefined') {
                errorType = 'webgl_other';
            }
        }

        // if error found, flag
        if (typeof errorType !== 'undefined') {
            flag(errorType);
        }
    }

    /*===================================================
    
    functions
    
    =====================================================*/

    // remove error state
    function clear() {
        shared.html.errorContainer.empty();
        errorCurrent = {};
        errorState = false;
    }

    // flag error
    function flag(errorType) {
        if (typeof errorType !== 'undefined') {
            window.location.hash = errorHash + errorType;
        }
    }

    // read flagged error
    function read() {
        var hashError, hashErrorIndex;

        // check url hash for error message
        hashError = window.location.hash.toString().replace(/#/, '');
        hashErrorIndex = hashError.indexOf(errorHash);
        if (hashErrorIndex != -1) {
            // get error type
            errorCurrent.type = hashError.replace(/error=/i, '');

            // set error state
            errorState = true;
        }
    }

    // check for errors
    function check() {
        // clear current errors
        clear();

        // read flagged errors
        read();

        return errorState;
    }

    // process error state
    function process(origin, lineNumber) {
        if (errorState === true) {
            // show current
            show(errorCurrent.type, origin, lineNumber);

            // set url back to origin link with history states
            // always hide unnecessary information from users
            history.pushState({
                "pState": shared.originLink
            }, '', shared.originLink);

            // trigger shared error signal
            shared.signals.error.dispatch(errorCurrent.type, origin || 'Unknown Origin', lineNumber || 'N/A');
        }
    }

    // generate error
    function generate(error, origin, lineNumber) {
        if (typeof error !== 'undefined') {
            // flag error
            flag(error);

            // check for flagged errors
            check();

            // process errors
            process(origin, lineNumber);
        }
    }

    // show error to user
    function show(error, origin, lineNumber) {
        var errorType, header, explanation, nerdtalk, extra, article, articleHeight, footerModifier = 0,
            animSpeed = 500;

        // does id not match a specific error
        if (errorTypes.hasOwnProperty(error)) {
            errorType = error;
        } else {
            errorType = 'general';
        }

        // header
        header = document.createElement('header');
        $(header).addClass('title_alt text_huge');
        $(header).html(errorTypes[errorType].header);

        // explanation
        explanation = document.createElement('p');
        $(explanation).addClass("error_explanation");
        $(explanation).html(errorTypes[errorType].explanation);

        // extra
        if (errorTypes[errorType].browser_extra === true) {
            extra = document.createElement('div');
            $(extra).addClass("browsers");
            $(extra).html(browser_html);
        }

        // article
        article = document.createElement('article');
        $(article).addClass("error info_panel unselectable");
        $(article).attr('id', errorType);

        // add to display
        $(article).append(header);
        $(article).append(explanation);
        shared.html.errorContainer.append(article);

        // set height and negative margin-top
        // no need to position, css top/left at 50%
        articleHeight = $(header).outerHeight() + $(explanation).outerHeight();
        if (typeof shared.html.staticMenu !== 'undefined') {
            footerModifier = shared.html.staticMenu.outerHeight() * 0.5;
        }

        // append extra if needed
        if (typeof extra !== 'undefined') {
            $(article).append(extra);
            articleHeight = articleHeight + $(extra).outerHeight();
            $(extra).fadeOut(0).fadeIn(animSpeed);
        }

        // error message, origin, and line number
        if (typeof origin !== 'undefined' && typeof lineNumber !== 'undefined') {

            nerdtalk = document.createElement('p');
            $(nerdtalk).addClass("nerdtalk");
            $(nerdtalk).html("the error was -> '" + error + "' in " + origin + " at line # " + lineNumber);
            $(article).append(nerdtalk);
            articleHeight = articleHeight + $(nerdtalk).outerHeight();
            $(nerdtalk).fadeOut(0).fadeIn(animSpeed);

        }

        // fade and slide smoothly to new values
        $(header).fadeOut(0).fadeIn(animSpeed);
        $(explanation).fadeOut(0).fadeIn(animSpeed);
        $(article).animate({
            'height': articleHeight,
            'margin-top': Math.round(-((articleHeight * 0.5) + footerModifier))
        }, animSpeed);

        // store
        errorCurrent.domElements = {
            article: article,
            header: header,
            explanation: explanation,
            extra: extra
        };
    }

}(KAIOPUA));

/*
 *
 * MathHelper.js
 * Math utility helper module.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/utils/MathHelper.js",
        _MathHelper = {};

    /*===================================================
    
    public properties
    
    =====================================================*/

    _MathHelper.is_number = function (n) {

        return isNaN(n) === false && isFinite(n);

    };

    _MathHelper.clamp = function (n, min, max) {

        return Math.max(min, Math.min(max, n));

    };

    _MathHelper.max_magnitude = function (n1, n2) {

        var n1abs = Math.abs(n1),
            n2abs = Math.abs(n2),
            max = Math.max(n1abs, n2abs);

        return (max === n1abs) ? n1 : n2;

    };

    _MathHelper.round = function (n, places) {

        var dec = (_MathHelper.is_number(places) && places > 0) ? Math.pow(10, places) : 1;

        return Math.round(n * dec) / dec;

    };

    _MathHelper.sign = function (n) {

        return n > 0 ? 1 : n === 0 ? 0 : -1;

    };

    _MathHelper.round_towards_zero = function (n) {

        return n < 0 ? Math.ceil(n) : Math.floor(n);

    };

    _MathHelper.degree_between_180 = function (n) {

        n = n % 360;

        return (n > 180) ? n - 360 : (n < -180) ? n + 360 : n;

    };

    _MathHelper.degree_to_rad = function (n) {

        return n / 180 * Math.PI;

    };

    _MathHelper.rad_to_degree = function (n) {

        return n * 180 / Math.PI;

    };

    _MathHelper.get_orthonormal_vectors = function (v1) {

        // returns 2 orthographic ( perpendicular ) vectors to the first
        var i, min = 0,
            minAxis, v1absx = Math.abs(v1.x),
            v1absy = Math.abs(v1.y),
            v1absz = Math.abs(v1.z),
            v2 = new THREE.Vector3(),
            v3 = new THREE.Vector3();

        // use Gram-Schmidt orthogonalisation to find first perpendicular vector
        min = Math.min(v1absx, v1absy, v1absz);

        // min is x
        if (min === v1absx) {

            minAxis = 'x';

        }
        // min is y
        else if (min === v1absy) {

            minAxis = 'y';

        }
        // min is z
        else {

            minAxis = 'z';

        }

        v2[minAxis] = 1;
        v2.x -= v1[minAxis] * v1.x;
        v2.y -= v1[minAxis] * v1.y;
        v2.z -= v1[minAxis] * v1.z;

        v3.cross(v1, v2);

        console.log('v1', v1, 'v2', v2, 'v3', v3);

        return {
            v1: v1,
            v2: v2,
            v3: v3
        };

    };

    _MathHelper.get_rotation_to_normal = function (normal, normalAxis) {

        // returns a 4x4 matrix that defines a rotation to a normal
        var vectors = _MathHelper.get_orthonormal_vectors(normal),
            v1 = vectors.v1,
            v2 = vectors.v2,
            v3 = vectors.v3,
            matrix;

        // normal on the x axis
        if (normalAxis === 'x') {

            matrix = new THREE.Matrix4(
            v1.x, v2.x, v3.x, 0, v1.y, v2.y, v3.y, 0, v1.z, v2.z, v3.z, 0, 0, 0, 0, 1);

        }
        // normal on the z axis
        else if (normalAxis === 'z') {

            matrix = new THREE.Matrix4(
            v2.x, v3.x, v1.x, 0, v2.y, v3.y, v1.y, 0, v2.z, v3.z, v1.z, 0, 0, 0, 0, 1);

        }
        // normal is on the y axis
        else {

            matrix = new THREE.Matrix4(
            v2.x, v1.x, v3.x, 0, v2.y, v1.y, v3.y, 0, v2.z, v1.z, v3.z, 0, 0, 0, 0, 1);

        }

        console.log('matrix', matrix, ' decomposed rot', matrix.decompose()[1]);

        return matrix;

    };

    _MathHelper.rotate_matrix2d_90 = function (matrix2d, degrees) {

        var i, l, turns;

        // snap degrees to closest multiple of increment
        turns = _MathHelper.round_towards_zero((degrees % 360) / 90);

        degrees = 90 * turns;

        // rotate matrix2d
        if (turns !== 0) {

            // positive rotation
            if (degrees > 0) {

                for (i = 0, l = Math.abs(turns); i < l; i++) {

                    matrix2d = _MathHelper.rotate_matrix2d_clockwise_90(matrix2d);

                }

            }
            // negative rotation
            else {

                for (i = 0, l = Math.abs(turns); i < l; i++) {

                    matrix2d = _MathHelper.rotate_matrix2d_anticlockwise_90(matrix2d);

                }

            }

        }

        return matrix2d;

    };

    _MathHelper.rotate_matrix2d_clockwise_90 = function (matrix2d) {

        var i, l, j, k, dimensions = matrix2d.dimensions(),
            rows = dimensions.rows,
            cols = dimensions.cols,
            matrix2dRotated = Matrix.Zero(cols, rows),
            elements = matrix2d.elements,
            elementsRot = matrix2dRotated.elements;

        // 90 degree positive / clockwise rotation of 2d ( n x m ) matrix
        for (i = 0, l = cols; i < l; i++) {

            for (j = 0, k = rows; j < k; j++) {

                elementsRot[i][j] = elements[rows - 1 - j][i];

            }

        }

        return matrix2dRotated;

    }

    _MathHelper.rotate_matrix2d_anticlockwise_90 = function (matrix2d) {

        var i, l, j, k, dimensions = matrix2d.dimensions(),
            rows = dimensions.rows,
            cols = dimensions.cols,
            matrix2dRotated = Matrix.Zero(cols, rows),
            elements = matrix2d.elements,
            elementsRot = matrix2dRotated.elements;

        // 90 degree negative / anticlockwise rotation of 2d ( n x m ) matrix
        for (i = 0, l = rows; i < l; i++) {

            for (j = 0, k = cols; j < k; j++) {

                elementsRot[cols - 1 - j][i] = elements[i][j];

            }

        }

        return matrix2dRotated;

    }

    _MathHelper.trig_table = function (increment, degreeMin, degreeMax) {

        var i, l, rad, table = {
            sin: {},
            cos: {}
        };

        increment = _MathHelper.is_number(increment) ? increment : 1;
        degreeMin = _MathHelper.is_number(degreeMin) ? degreeMin : -180;
        degreeMax = _MathHelper.is_number(degreeMax) ? degreeMax : 180;

        for (i = degreeMin, l = degreeMax; i < l; i += increment) {

            rad = _MathHelper.degree_to_rad(i);

            table.sin[i] = Math.sin(rad);
            table.cos[i] = Math.cos(rad);

        }

        return table;

    }

    main.asset_register(assetPath, {
        data: _MathHelper
    });

}(KAIOPUA));

/*
 *
 * ObjectHelper.js
 * Contains utility functionality for basic models.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/utils/ObjectHelper.js",
        _ObjectHelper = {},
        _MathHelper, utilVec31Follow, utilVec32Follow, utilVec31Bounds, utilVec32Bounds, utilVec31Dimensions, utilVec31Axis, utilVec31Offset, utilVec31OffsetRot, utilVec32OffsetRot, utilVec33OffsetRot, utilVec34OffsetRot, utilVec35OffsetRot, utilVec36OffsetRot, utilVec37OffsetRot, utilVec38OffsetRot, utilVec39OffsetRot, utilVec41OffsetRot, utilQ1Follow, utilQ2Follow, utilQ3Follow, utilQ4Follow, utilQ1Axis, utilQ1CenterRot, utilQ2CenterRot, utilMat41Follow, utilMat41Bounds, utilMat41Center, utilMat41CenterRot;

    /*===================================================
    
    public properties
    
    =====================================================*/

    _ObjectHelper.extract_children_from_objects = extract_children_from_objects;
    _ObjectHelper.extract_parents_from_objects = extract_parents_from_objects;

    _ObjectHelper.object_apply_matrix = object_apply_matrix;
    _ObjectHelper.object_push_bounds = object_push_bounds;

    _ObjectHelper.dimensions = dimensions;

    _ObjectHelper.center_offset = center_offset;
    _ObjectHelper.object_center = object_center;

    _ObjectHelper.q_to_axis = q_to_axis;
    _ObjectHelper.rotation_offset = rotation_offset;
    _ObjectHelper.object_center_rotation = object_center_rotation;

    _ObjectHelper.object_follow_object = object_follow_object;

    main.asset_register(assetPath, {
        data: _ObjectHelper,
        requirements: ["assets/modules/utils/MathHelper.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(mh) {
        console.log('internal object helper');
        _MathHelper = mh;

        // utility
        utilVec31Follow = new THREE.Vector3();
        utilVec32Follow = new THREE.Vector3();
        utilVec31Bounds = new THREE.Vector3();
        utilVec32Bounds = new THREE.Vector3();
        utilVec31Dimensions = new THREE.Vector3();
        utilVec31Axis = new THREE.Vector3();
        utilVec31Offset = new THREE.Vector3();
        utilVec31OffsetRot = new THREE.Vector3();
        utilVec32OffsetRot = new THREE.Vector3();
        utilVec33OffsetRot = new THREE.Vector3();
        utilVec34OffsetRot = new THREE.Vector3();
        utilVec35OffsetRot = new THREE.Vector3();
        utilVec36OffsetRot = new THREE.Vector3();
        utilVec37OffsetRot = new THREE.Vector3();
        utilVec38OffsetRot = new THREE.Vector3();
        utilVec39OffsetRot = new THREE.Vector3();
        utilVec41OffsetRot = new THREE.Vector4();
        utilQ1Follow = new THREE.Quaternion();
        utilQ2Follow = new THREE.Quaternion();
        utilQ3Follow = new THREE.Quaternion();
        utilQ4Follow = new THREE.Quaternion();
        utilQ1Axis = new THREE.Quaternion();
        utilQ1CenterRot = new THREE.Quaternion();
        utilQ2CenterRot = new THREE.Quaternion();
        utilMat41Follow = new THREE.Matrix4();
        utilMat41Bounds = new THREE.Matrix4();
        utilMat41Center = new THREE.Matrix4();
        utilMat41CenterRot = new THREE.Matrix4();

    }

    /*===================================================
    
    hierarchy support
    
    =====================================================*/

    function extract_children_from_objects(objects, cascade) {

        var i, l, object;

        objects = main.ensure_array(objects);

        for (i = 0, l = objects.length; i < l; i++) {

            cascade = extract_child_cascade(objects[i], cascade);

        }

        return cascade;

    }

    function extract_child_cascade(object, cascade) {

        var i, l, children;

        cascade = main.ensure_array(cascade);

        if (typeof object !== 'undefined') {

            children = object.children;

            cascade = cascade.concat(children);

            for (i = 0, l = children.length; i < l; i++) {

                cascade = extract_child_cascade(children[i], cascade);

            }

        }

        return cascade;

    }

    function extract_parents_from_objects(objects, cascade) {

        var i, l;

        objects = main.ensure_array(objects);

        for (i = 0, l = objects.length; i < l; i++) {

            cascade = extract_parent_cascade(objects[i], cascade);

        }

        return cascade;

    }

    function extract_parent_cascade(object, cascade) {

        var i, l;

        cascade = cascade || [];

        while (typeof object.parent !== 'undefined') {

            cascade.push(object.parent);

            object = object.parent;

        }

        return cascade;

    }

    /*===================================================
    
    apply matrix
    
    =====================================================*/

    function object_apply_matrix(object, matrix) {

        var i, l, j, k, geometry = object instanceof THREE.Mesh ? object.geometry : object,
            morphTargets = geometry.morphTargets,
            morphTarget, vertices, vertex;

        // apply offset matrix to geometry
        geometry.applyMatrix(matrix);

        // adjust morph targets
        for (i = 0, l = morphTargets.length; i < l; i++) {

            morphTarget = morphTargets[i];

            vertices = morphTarget.vertices;

            for (j = 0, k = vertices.length; j < k; j++) {

                vertex = vertices[j];

                matrix.multiplyVector3(vertex.position);

            }

        }

        // force recompute bounds
        geometry.computeBoundingSphere();

        geometry.computeBoundingBox();

        // additional adjustments if object is mesh
        if (object instanceof THREE.Mesh) {

            object.boundRadius = geometry.boundingSphere.radius;

        }

    }

    function dimensions(object, ignoreScale) {

        var mesh = object instanceof THREE.Mesh ? object : false,
            geometry = mesh ? mesh.geometry : object,
            dimensions = utilVec31Dimensions,
            bbox;

        // if needs calculation
        if (typeof geometry.boundingBox !== 'undefined') {
            geometry.computeBoundingBox();
        }

        bbox = geometry.boundingBox;

        if (bbox) {

            // get original dimensions
            dimensions.set(bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y, bbox.max.z - bbox.min.z);

            // scale to mesh's scale
            if (ignoreScale !== true && mesh) {

                dimensions.multiplySelf(mesh.scale);

            }

        } else {

            dimensions.set(0, 0, 0);

        }

        return dimensions;

    }

    /*===================================================
    
    bounds
    
    =====================================================*/

    function object_push_bounds(object, bounds) {

        var geometry = object instanceof THREE.Mesh ? object.geometry : object,
            objectWorldMatrix = object instanceof THREE.Mesh ? object.matrixWorld : utilMat41Bounds,
            objectBounds, objectMin = utilVec31Bounds,
            objectMax = utilVec32Bounds,
            min = bounds.min,
            max = bounds.max;

        if (!geometry.boundingBox) {

            geometry.computeBoundingBox();

        }

        objectBounds = geometry.boundingBox;
        objectMin.copy(objectBounds.min);
        objectMax.copy(objectBounds.max);

        objectWorldMatrix.multiplyVector3(objectMin);
        objectWorldMatrix.multiplyVector3(objectMax);

        if (objectMin.x < min.x) {

            min.x = objectMin.x;

        }

        if (objectMax.x > max.x) {

            max.x = objectMax.x;

        }

        if (objectMin.y < min.y) {

            min.y = objectMin.y;

        }

        if (objectMax.y > max.y) {

            max.y = objectMax.y;

        }

        if (objectMin.z < min.z) {

            min.z = objectMin.z;

        }

        if (objectMax.z > max.z) {

            max.z = objectMax.z;

        }

        return bounds;

    }

    /*===================================================
    
    center offset
    
    =====================================================*/

    function center_offset(object) {

        var geometry = object instanceof THREE.Mesh ? object.geometry : object,
            offset = utilVec31Offset,
            bbox;

        if (!geometry.boundingBox) {

            geometry.computeBoundingBox();

        }

        bbox = geometry.boundingBox;

        offset.add(bbox.min, bbox.max).multiplyScalar(-0.5);

        return offset;

    }

    function object_center(object) {

        var offset = center_offset(object),
            offsetMat4 = utilMat41Center.setTranslation(offset.x, offset.y, offset.z);

        // apply offset
        object_apply_matrix(object, offsetMat4);

        // additional adjustments if object is mesh
        if (object instanceof THREE.Mesh) {

            // adjust position
            object.position.subSelf(offset);

        }

        return offset;

    }

    /*===================================================
    
    rotation offset
    
    =====================================================*/

    function q_to_axis(axisTo, axisFrom, axisFromRightAngle) {

        var ca = shared.cardinalAxes,
            dist, axis = utilVec31Axis,
            angle, qToA = utilQ1Axis;

        // current axes
        axisFrom = axisFrom || ca.up;

        axisFromRightAngle = axisFromRightAngle || ca.forward;

        // find dist between current axis up and average of normals
        dist = _MathHelper.clamp(axisFrom.dot(axisTo), -1, 1);

        // if up axes are not same
        if (dist !== 1) {

            // axis / angle
            angle = Math.acos(dist);
            axis.cross(axisFrom, axisTo).normalize();

            // if new axis is exactly opposite of current
            // replace new axis with the forward axis
            if (axis.length() === 0) {

                axis.copy(axisFromRightAngle);

            }

            // rotation change
            qToA.setFromAxisAngle(axis, angle);

        } else {

            qToA.set(0, 0, 0, 1);

        }

        return qToA;

    }

    function rotation_offset(object, axisUp, axisForward) {

        var i, l, geometry = object instanceof THREE.Mesh ? object.geometry : object,
            faces = geometry.faces,
            vertices = geometry.vertices,
            face, vpa, vpb, vpc, vpd, nvpa = utilVec31OffsetRot,
            nvpb = utilVec32OffsetRot,
            nvpc = utilVec33OffsetRot,
            nvpd = utilVec34OffsetRot,
            len = Math.sqrt(1 / 2),
            expectedPosA = utilVec35OffsetRot.set(len, -len, 0),
            // ( -len, len, 0 )
            expectedPosB = utilVec36OffsetRot.set(len, len, 0),
            // ( -len, -len, 0 )
            expectedPosC = utilVec37OffsetRot.set(-len, len, 0),
            // ( len, -len, 0 )
            expectedPosD = utilVec38OffsetRot.set(-len, -len, 0),
            // ( len, len, 0 )
            v4VEAvg = utilVec41OffsetRot.set(0, 0, 0, 0),
            normalAvg = utilVec39OffsetRot.set(0, 0, 0),
            ca = shared.cardinalAxes,
            offset;

        // for all face normals
        for (i = 0, l = faces.length; i < l; i++) {

            face = faces[i];

            normalAvg.addSelf(face.normal);

            vpa = vertices[face.a].position;
            vpb = vertices[face.b].position;
            vpc = vertices[face.c].position;

            nvpa.copy(vpa).normalize();
            nvpb.copy(vpb).normalize();
            nvpc.copy(vpc).normalize();

            v4VEAvg.addSelf(q_to_axis(nvpa, expectedPosA));
            v4VEAvg.addSelf(q_to_axis(nvpb, expectedPosB));
            v4VEAvg.addSelf(q_to_axis(nvpc, expectedPosC));

            if (face instanceof THREE.Face4) {

                vpd = vertices[face.d].position;

                nvpd.copy(vpd).normalize();
                v4VEAvg.addSelf(q_to_axis(nvpd, expectedPosD));

            }

        }

        // find averages
        normalAvg.normalize();

        v4VEAvg.normalize();

        // handle axes
        // use physics axis if available, or default to global up
        axisUp = axisUp || ((typeof object.physics !== 'undefined') ? object.physics.axes.up : ca.up);
        axisForward = axisForward || ((typeof object.physics !== 'undefined') ? object.physics.axes.forward : ca.forward);

        // find quaternion to go from average of normals to current axis up 
        offset = q_to_axis(axisUp, normalAvg, axisForward);

        // rotate offset to re-orient faces as square (not diamond)
        // TODO: seems to tilt slightly off the more this rotates
        offset.multiplySelf(v4VEAvg);
        /*
		var vectors = _MathHelper.get_orthonormal_vectors( normalAvg.clone() ),
			xlg = new THREE.Geometry(),
			ylg = new THREE.Geometry(),
			zlg = new THREE.Geometry(),
			xline,
			yline,
			zline;
		
		offset.multiplyVector3( vectors.v1 );
		offset.multiplyVector3( vectors.v2 );
		offset.multiplyVector3( vectors.v3 );
		
		xlg.vertices.push( new THREE.Vertex( new THREE.Vector3() ) );
		xlg.vertices.push( new THREE.Vertex( vectors.v3.multiplyScalar( 100 ) ) );
		
		ylg.vertices.push( new THREE.Vertex( new THREE.Vector3() ) );
		ylg.vertices.push( new THREE.Vertex( vectors.v1.multiplyScalar( 100 ) ) );
		
		zlg.vertices.push( new THREE.Vertex( new THREE.Vector3() ) );
		zlg.vertices.push( new THREE.Vertex( vectors.v2.multiplyScalar( 100 ) ) );
		
		xline = new THREE.Line( xlg, new THREE.LineBasicMaterial( { color: 0xFF0000, linewidth: 8 } ), THREE.LinePieces ),
		yline = new THREE.Line( ylg, new THREE.LineBasicMaterial( { color: 0x00FF00, linewidth: 8 } ), THREE.LinePieces ),
		zline = new THREE.Line( zlg, new THREE.LineBasicMaterial( { color: 0x0000FF, linewidth: 8 } ), THREE.LinePieces );
		
		object.add( xline );
		object.add( yline );
		object.add( zline );
		*/
        return offset;

    }

    function object_center_rotation(object) {

        var offset = rotation_offset(object),
            offsetMat4 = utilMat41CenterRot.setRotationFromQuaternion(offset),
            objectMatQ = utilQ1CenterRot;
        objectNewQ = utilQ2CenterRot;

        // apply offset to object
        object_apply_matrix(object, offsetMat4);

        // additional adjustments if object is mesh
        if (object instanceof THREE.Mesh) {

            if (object.useQuaternion === true) {

                // quaternion rotations
                objectNewQ.multiply(offset.inverse(), object.quaternion);

                object.quaternion.copy(objectNewQ);

            } else {

                // matrix rotations
                objectMatQ.setFromRotationMatrix(object.matrix);

                objectNewQ.multiply(offset.inverse(), objectMatQ);

                object.matrix.setRotationFromQuaternion(objectNewQ);

            }

        }

    }

    /*===================================================
    
    follow
    
    =====================================================*/

    function object_follow_object(follower, leader, rotationBase, rotationOffset, positionOffset) {

        var leaderScale = leader.scale,
            leaderScaleMax = Math.max(leaderScale.x, leaderScale.y, leaderScale.z),
            leaderMatrixWorld = leader.matrixWorld,
            leaderQWorld = utilQ1Follow.setFromRotationMatrix(leaderMatrixWorld),
            leaderPWorld = utilVec31Follow.copy(leaderMatrixWorld.getPosition()),
            followerP = follower.position,
            followerQ = follower.quaternion,
            followerBaseRot = utilQ2Follow,
            followerOffsetRot = utilQ3Follow,
            followerOffsetPos = utilVec32Follow,
            parentInverseMatrix = utilMat41Follow,
            parentInverseQ = utilQ4Follow,
            skipBaseRot, skipOffsetRot, skipOffsetPos;

        // follower base rotation
        if (rotationBase instanceof THREE.Quaternion) {

            followerBaseRot.copy(rotationBase);

        } else if (rotationBase instanceof THREE.Vector3) {

            followerBaseRot.setFromEuler(rotationBase).normalize();

        } else {

            followerBaseRot.set(0, 0, 0, 1);

            skipBaseRot = true;

        }

        // follower offset rotation
        if (rotationOffset instanceof THREE.Quaternion) {

            followerOffsetRot.copy(rotationOffset);

        } else if (rotationOffset instanceof THREE.Vector3) {

            followerOffsetRot.setFromEuler(rotationOffset).normalize();

        } else {

            followerOffsetRot.set(0, 0, 0, 1);

            skipOffsetRot = true;

        }

        // follower offset position
        if (positionOffset instanceof THREE.Vector3) {

            followerOffsetPos.set(positionOffset.x, positionOffset.y, positionOffset.z).multiplyScalar(leaderScaleMax);

        } else {

            skipOffsetPos = true;

        }

        // modify offset position
        if (skipOffsetPos !== true) {

            if (skipBaseRot !== true) {

                followerBaseRot.multiplyVector3(followerOffsetPos);

            }

            if (skipOffsetRot !== true) {

                followerOffsetRot.multiplyVector3(followerOffsetPos);

            }

            if (follower.parent !== leader) {

                leaderQWorld.multiplyVector3(followerOffsetPos);

            }

        }

        // if parents are not the same
        if (follower.parent instanceof THREE.Object3D && follower.parent !== leader && follower.parent !== leader.parent) {

            // get inverse position and rotation
            parentInverseMatrix.getInverse(follower.parent.matrixWorld);
            parentInverseQ.setFromRotationMatrix(parentInverseMatrix);

            // modify offset position and leader world position
            // to account for follower being affected by parent matrix
            if (skipOffsetPos !== true) {

                parentInverseQ.multiplyVector3(followerOffsetPos);

            }

            parentInverseQ.multiplyVector3(leaderPWorld);

            // copy inverse as base
            followerP.copy(parentInverseMatrix.getPosition());
            followerQ.copy(parentInverseQ);

        }
        // reset pos / rot
        else {

            followerP.set(0, 0, 0);
            followerQ.set(0, 0, 0, 1);

        }

        // position
        if (follower.parent !== leader) {

            followerP.addSelf(leaderPWorld);

        }

        if (skipOffsetPos !== true) {

            followerP.addSelf(followerOffsetPos);

        }

        // rotation
        if (follower.parent !== leader) {

            followerQ.multiplySelf(leaderQWorld);

        }

        if (skipOffsetRot !== true) {

            followerQ.multiplySelf(followerOffsetRot);

        }

        if (skipBaseRot !== true) {

            followerQ.multiplySelf(followerBaseRot);

        }

    }

}(KAIOPUA));

/*
 *
 * ObjectMaker.js
 * Handles generation of misc objects.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/utils/ObjectMaker.js",
        _ObjectMaker = {},
        _Model;

    /*===================================================
    
    public properties
    
    =====================================================*/

    _ObjectMaker.make_skybox = make_skybox;

    main.asset_register(assetPath, {
        data: _ObjectMaker,
        requirements: ["assets/modules/core/Model.js"],
        callbacksOnReqs: init_internal,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init_internal(m) {
        console.log('internal objectmaker');
        _Model = m;

    }

    /*===================================================
    
    maker functions
    
    =====================================================*/

    // generates a skybox from array of images
    function make_skybox(imagesAssetPath, mapping, instance) {

        var textureCube, shader, material;

        instance = instance || {};

        // get images from assets
        ap = imagesAssetPath;

        // cube texture
        textureCube = new THREE.Texture(null, mapping);

        main.asset_require([
            ap + "_posx.jpg", ap + "_negx.jpg", ap + "_posy.jpg", ap + "_negy.jpg", ap + "_posz.jpg", ap + "_negz.jpg"], function (posx, negx, posy, negy, posz, negz) {

            textureCube.image = [posx, negx, posy, negy, posz, negz];
            textureCube.needsUpdate = true;

        });

        // shader
        shader = $.extend(true, {}, THREE.ShaderUtils.lib["cube"]);
        shader.uniforms["tCube"].texture = textureCube;

        // material
        material = new THREE.ShaderMaterial({

            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: shader.uniforms,
            depthWrite: false

        });

        // instance
        instance = new _Model.Instance({
            geometry: new THREE.CubeGeometry(100, 100, 100),
            materials: material,
            shading: THREE.SmoothShading,
            flipSided: true
        }, instance);

        return instance;

    }

}(KAIOPUA));

/*
 *
 * Dev.js
 * Initializes Logger, Stats, and DAT-GUI for development purposes.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var shared = main.shared = main.shared || {},
        assetPath = "assets/modules/utils/Dev.js",
        _Dev = {},
        _DevCommands, domElement, isOpen = true,
        stats, logger, gui, guiContainer, guiHeight, statsPaused = true;

    /*===================================================
    
    public properties
    
    =====================================================*/

    _Dev.toggle = togglePanel;
    _Dev.log = function (msg, expand) {
        if (typeof logger !== 'undefined') {
            logger.log(msg, expand);
        }
    };
    _Dev.log_error = function (error, url, lineNumber) {
        if (typeof logger !== 'undefined') {
            logger.log('[ERROR] ' + error);
            logger.log('[ERROR] in file: ' + url);
            logger.log('[ERROR] line # ' + lineNumber);
        }
    };
    _Dev.gui = function () {
        return gui;
    };
    _Dev.resize = resize;
    _Dev.isOpen = function () {
        return isOpen;
    };
    _Dev.domElement = function () {
        return domElement;
    };

    main.asset_register(assetPath, {
        data: _Dev,
        requirements: ["assets/modules/utils/DevCommands.js", "js/lib/Logger.js", "js/lib/Stats.js", "js/lib/DAT.GUI.js"],
        callbacksOnReqs: init,
        wait: true
    });

    /*===================================================
    
    internal init
    
    =====================================================*/

    function init(d) {

        _DevCommands = d;

        // stats
        stats = new Stats();
        stats.domElement.style.position = 'absolute';

        // logger
        logger = new Logger();
        $(logger.domElement).css({
            position: 'absolute',
            overflow: 'auto',
            padding: '0',
            opacity: '0.8',
            backgroundColor: '#333',
            color: '#fcd700',
            'font-size': '13px'
        });
        // override log function to autoscroll to bottom of domElement
        logger.oldLog = logger.log;
        logger.log = function (msg, expand) {
            logger.oldLog(msg, expand);
            logger.domElement.scrollTop = logger.domElement.scrollHeight;
        };

        // gui
        // DAT.GUI hacked to add property to disable drag
        gui = new DAT.GUI({
            height: 200,
            dragAllowed: false,
            closeString: 'Close Dev Console',
            openString: 'Open Dev Console'
        });
        guiContainer = $('#guidat');
        gui.domElement.style.margin = '0';

        // gui elements
        gui.add(_DevCommands, 'current').name('CMD?').onFinishChange(function (newCmd) {
            logger.log('[DEV CMD] ' + newCmd);
            _DevCommands.execute(newCmd);
        });
        gui.add(logger, 'clear').name('Clear Log');

        // force the gui to calculate the correct height
        // there must be a better way
        gui.toggle();
        gui.toggle();

        // set logger height explicitly to gui height
        // DAT.GUI hacked to add property totalHeight and targetHeight
        logger.domElement.style.height = gui.totalHeight + 'px';

        // container
        domElement = document.createElement('div');
        domElement.id = 'dev_utils';
        domElement.style.position = 'absolute';
        domElement.style.left = '0px';
        domElement.style.top = '0px';

        // add all dev utils to container
        domElement.appendChild(logger.domElement);
        domElement.appendChild(stats.domElement);
        $(domElement).append(guiContainer);

        // add dev utils to window
        $(document.body).append(domElement);

        // add listeners to gui toggle
        gui.toggleButton.addEventListener('mouseup', function (e) {
            togglePanel(e);
            e.preventDefault();
            return false;
        }, false);

        // turn dev off initially
        togglePanel();

        // resize signal
        resize(shared.screenWidth, shared.screenHeight);
        shared.signals.windowresized.add(resize);

        // add dev commands
        _DevCommands.add({
            cmd_hist: function (modifier) {
                if (modifier === 'clear') {
                    logger.log('Cleared dev cmd history!');
                    _DevCommands.clear_history();
                } else {
                    logger.log('Showing dev cmd history:');
                    logger.log(_DevCommands.get_history(), true);
                }
            }
        });

    }

    /*===================================================
    
    functions
    
    =====================================================*/

    // stats functions
    function stats_start() {
        if (statsPaused === true) {
            statsPaused = false;
            stats_update();
        }
    }

    function stats_stop() {
        statsPaused = true;
    }

    function stats_update() {
        if (statsPaused === false) {
            requestAnimationFrame(stats_update);
            stats.update();
        }
    }

    // self toggle on/off
    function togglePanel(e) {
        // open?
        isOpen = !isOpen;

        // close gui if open
        if (typeof e === 'undefined' || (typeof e === 'undefined' && gui.appearanceVars()[0] === true)) {
            gui.toggle();
        }

        // turn logger and stats off
        $(logger.domElement).toggle();
        $(stats.domElement).toggle();

        // start stats
        if (isOpen) {
            stats_start();
        } else {
            stats_stop();
        }
    }

    // resize dev utils
    function resize(W, H) {
        var statsDE = stats.domElement,
            logDE = logger.domElement,
            guiDE = gui.domElement,
            spaceW = 5,
            spaceH = 5,
            initX = spaceW,
            initY = spaceH,
            currX = initX,
            currY = initY,
            statsW = $(statsDE).width(),
            guiW = guiContainer.width();

        // gui - far right
        guiContainer.css({
            right: spaceW,
            top: spaceH
        });

        // stats
        $(statsDE).css({
            left: W - statsW - $(guiDE).width() - (spaceW * 2),
            top: spaceH
        });

        // logger
        $(logDE).css({
            left: spaceW,
            top: spaceH
        });
        $(logDE).width(W - (spaceW * 3) - $(guiDE).width());
    }

}(KAIOPUA));

/*
 *
 * DevCommands.js
 * Adds dynamic commands to dev panel.
 *
 * @author Collin Hover / http://collinhover.com/
 *
 */
(function (main) {

    var assetPath = "assets/modules/utils/DevCommands.js",
        _DevCommands = {},
        commands = [],
        callbacks = {},
        current = "",
        history = [];

    /*===================================================
    
    public properties
    
    =====================================================*/

    _DevCommands.current = current;
    _DevCommands.add = add;
    _DevCommands.execute = execute;
    _DevCommands.get_history = function () {
        return history.slice(0);
    };
    _DevCommands.clear_history = function () {
        history = [];
    };

    main.asset_register(assetPath, {
        data: _DevCommands
    });

    // add list of commands
    // cmds can be an object with any number of name + callback pairs
    // or an array of above
    function add(cmds) {
        var i, l, key;

        if (typeof cmds !== 'undefined') {
            // is array?
            if (cmds.hasOwnProperty('length') === true) {
                // parse each recursively
                for (i = 0, l = cmds.length; i < l; i += 1) {
                    add(cmds[i]);
                }
            }
            // else assume object
            else {
                for (key in cmds) {
                    if (cmds.hasOwnProperty(key) === true) {
                        // check if already exists in commands
                        for (i = 0, l = commands.length; i < l; i += 1) {
                            if (commands[i] === key) {
                                throw ('Duplicate dev command: ' + key);
                            }
                        }

                        // add name to commands
                        commands.push(key);

                        // add callback to callbacks
                        callbacks[key] = cmds[key];
                    }
                }
            }
        }
    }

    // execute a dev command
    // assumes cmd is a single string of comma separated values
    // anything before first comma is command, all following are arguments
    function execute(cmd) {
        var i, l, cmdParts, cmdPiece, command, args = [],
            callback;
        if (typeof cmd === 'string') {
            // parse cmd
            cmdParts = cmd.split(",");

            // remove all non-essential white spaces in each part of cmd
            for (i = 0, l = cmdParts.length; i < l; i += 1) {
                cmdParts[i] = cmdParts[i].replace(/(^\s*)|(\s*$)/gi, "");
            }

            // store command
            history[history.length] = command = cmdParts[0];

            // store args
            args = cmdParts.slice(1);

            // search
            for (i = 0, l = commands.length; i < l; i += 1) {
                if (commands[i] === command) {
                    // store callback
                    callback = callbacks[command];
                    break;
                }
            }

            // execute
            if (typeof callback !== 'undefined') {
                callback.apply(this, args);
            }
        }
    }

}(KAIOPUA));